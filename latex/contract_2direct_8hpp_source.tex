\hypertarget{contract_2direct_8hpp_source}{}\doxysection{direct.\+hpp}
\label{contract_2direct_8hpp_source}\index{include/particleintegrals/contract/direct.hpp@{include/particleintegrals/contract/direct.hpp}}
\mbox{\hyperlink{contract_2direct_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/* }}
\DoxyCodeLine{2 \textcolor{comment}{ *  This file is part of the Chronus Quantum (ChronusQ) software package}}
\DoxyCodeLine{3 \textcolor{comment}{ *  }}
\DoxyCodeLine{4 \textcolor{comment}{ *  Copyright (C) 2014-\/2022 Li Research Group (University of Washington)}}
\DoxyCodeLine{5 \textcolor{comment}{ *  }}
\DoxyCodeLine{6 \textcolor{comment}{ *  This program is free software; you can redistribute it and/or modify}}
\DoxyCodeLine{7 \textcolor{comment}{ *  it under the terms of the GNU General Public License as published by}}
\DoxyCodeLine{8 \textcolor{comment}{ *  the Free Software Foundation; either version 2 of the License, or}}
\DoxyCodeLine{9 \textcolor{comment}{ *  (at your option) any later version.}}
\DoxyCodeLine{10 \textcolor{comment}{ *  }}
\DoxyCodeLine{11 \textcolor{comment}{ *  This program is distributed in the hope that it will be useful,}}
\DoxyCodeLine{12 \textcolor{comment}{ *  but WITHOUT ANY WARRANTY; without even the implied warranty of}}
\DoxyCodeLine{13 \textcolor{comment}{ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}}
\DoxyCodeLine{14 \textcolor{comment}{ *  GNU General Public License for more details.}}
\DoxyCodeLine{15 \textcolor{comment}{ *  }}
\DoxyCodeLine{16 \textcolor{comment}{ *  You should have received a copy of the GNU General Public License along}}
\DoxyCodeLine{17 \textcolor{comment}{ *  with this program; if not, write to the Free Software Foundation, Inc.,}}
\DoxyCodeLine{18 \textcolor{comment}{ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-\/1301 USA.}}
\DoxyCodeLine{19 \textcolor{comment}{ *  }}
\DoxyCodeLine{20 \textcolor{comment}{ *  Contact the Developers:}}
\DoxyCodeLine{21 \textcolor{comment}{ *    E-\/Mail: xsli@uw.edu}}
\DoxyCodeLine{22 \textcolor{comment}{ *  }}
\DoxyCodeLine{23 \textcolor{comment}{ */}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{integrals_8hpp}{integrals.hpp}}>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{inhouseaointegral_8hpp}{particleintegrals/inhouseaointegral.hpp}}>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{matout_8hpp}{util/matout.hpp}}>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{blas1_8hpp}{cqlinalg/blas1.hpp}}>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{blasext_8hpp}{cqlinalg/blasext.hpp}}>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{blasutil_8hpp}{cqlinalg/blasutil.hpp}}>}}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{threads_8hpp}{util/threads.hpp}}>}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{mpi_8hpp}{util/mpi.hpp}}>}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{timer_8hpp}{util/timer.hpp}}>}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{math_8hpp}{util/math.hpp}}>}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{gtodirecttpi_8hpp}{particleintegrals/twopints/gtodirecttpi.hpp}}>}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{giaodirecteri_8hpp}{particleintegrals/twopints/giaodirecteri.hpp}}>}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{gradints_2direct_8hpp}{particleintegrals/gradints/direct.hpp}}>}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43 \textcolor{preprocessor}{\#define \_FULL\_DIRECT}}
\DoxyCodeLine{44 \textcolor{comment}{//\#define \_SUB\_TIMINGS}}
\DoxyCodeLine{45 \textcolor{comment}{//\#define \_REPORT\_INTEGRAL\_TIMINGS}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47 \textcolor{comment}{//\#define \_PRECOMPUTE\_SHELL\_PAIRS}}
\DoxyCodeLine{48 }
\DoxyCodeLine{49 \textcolor{preprocessor}{\#define \_SHZ\_SCREEN}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#define \_SEPARATED\_SHZ\_SCREEN}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{preprocessor}{\#ifndef \_FULL\_DIRECT}}
\DoxyCodeLine{54 \textcolor{preprocessor}{  \#define \_BATCH\_DIRECT}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 \textcolor{preprocessor}{\#if defined(\_FULL\_DIRECT) }}
\DoxyCodeLine{58 \textcolor{preprocessor}{  \#define \_USE\_EIGHT\_FOLD}}
\DoxyCodeLine{59 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{60 \textcolor{preprocessor}{  \#define \_USE\_FOUR\_FOLD}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63 \textcolor{preprocessor}{\#ifndef \_FULL\_DIRECT}}
\DoxyCodeLine{64 \textcolor{preprocessor}{  \#warning "{}Batch Direct ERI contraction is broken for complex"{}}}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{66 }
\DoxyCodeLine{67 \textcolor{preprocessor}{\#define GetRealPtr(X,I,J,N) reinterpret\_cast<double*>(X + I + J*N)}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceChronusQ}{ChronusQ}} \{}
\DoxyCodeLine{70 }
\DoxyCodeLine{71   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatsT>}
\DoxyCodeLine{72   \textcolor{keywordtype}{void} \mbox{\hyperlink{namespaceChronusQ_ade3d6fad69f4d04c7a642580c77ddb1b}{ShellBlockNorm}}(std::vector<libint2::Shell> \&shSet, MatsT *MAT, }
\DoxyCodeLine{73     \textcolor{keywordtype}{size\_t} LDM, \textcolor{keywordtype}{double} *ShBlk) \{}
\DoxyCodeLine{74 }
\DoxyCodeLine{75     \textcolor{keywordtype}{size\_t} nShell = shSet.size();}
\DoxyCodeLine{76 }
\DoxyCodeLine{77     \textcolor{keywordtype}{size\_t} n1,n2;}
\DoxyCodeLine{78     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} s1(0ul), bf1(0ul); s1 < nShell; s1++, bf1 += n1) \{}
\DoxyCodeLine{79       n1 = shSet[s1].size();}
\DoxyCodeLine{80     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} s2(0ul), bf2(0ul); s2 < nShell; s2++, bf2 += n2) \{}
\DoxyCodeLine{81       n2 = shSet[s2].size();}
\DoxyCodeLine{82 }
\DoxyCodeLine{83       MatsT *block = MAT + bf1 + bf2*LDM;}
\DoxyCodeLine{84       ShBlk[s1 + s2*nShell] = lapack::lange(lapack::Norm::Inf,n1,n2,block,LDM);}
\DoxyCodeLine{85 }
\DoxyCodeLine{86     \}}
\DoxyCodeLine{87     \}}
\DoxyCodeLine{88 }
\DoxyCodeLine{89   \};}
\DoxyCodeLine{90 }
\DoxyCodeLine{91 }
\DoxyCodeLine{92   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{93   \textcolor{keywordtype}{double} * \mbox{\hyperlink{namespaceChronusQ_ade3d6fad69f4d04c7a642580c77ddb1b}{ShellBlockNorm}}(std::vector<libint2::Shell> \&shSet, T *MAT, }
\DoxyCodeLine{94     \textcolor{keywordtype}{size\_t} LDM, \mbox{\hyperlink{classChronusQ_1_1CQMemManager}{CQMemManager}} \&mem) \{}
\DoxyCodeLine{95 }
\DoxyCodeLine{96     \textcolor{keywordtype}{size\_t} nShell = shSet.size();}
\DoxyCodeLine{97     \textcolor{keywordtype}{double} *ShBlk = mem.template malloc<double>(nShell*nShell);}
\DoxyCodeLine{98 }
\DoxyCodeLine{99     \mbox{\hyperlink{namespaceChronusQ_ade3d6fad69f4d04c7a642580c77ddb1b}{ShellBlockNorm}}(shSet,MAT,LDM,ShBlk);}
\DoxyCodeLine{100 }
\DoxyCodeLine{101     \textcolor{keywordflow}{return} ShBlk;}
\DoxyCodeLine{102 }
\DoxyCodeLine{103   \};}
\DoxyCodeLine{104 }
\DoxyCodeLine{105 }
\DoxyCodeLine{106   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatsT, \textcolor{keyword}{typename} IntsT>}
\DoxyCodeLine{107   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GTODirectTPIContraction_a9f36964aad737467eccb9c168b01ff85}{GTODirectTPIContraction<MatsT,IntsT>::directScaffold}}(}
\DoxyCodeLine{108     \mbox{\hyperlink{structChronusQ_1_1MPI__Comm}{MPI\_Comm}} comm, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} screen,}
\DoxyCodeLine{109     std::vector<\mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction}{TwoBodyContraction<MatsT>}}> \&list,\mbox{\hyperlink{structChronusQ_1_1EMPerturbation}{EMPerturbation}}\&)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{110 }
\DoxyCodeLine{111     \mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<IntsT>}} \&eri =}
\DoxyCodeLine{112         \textcolor{keyword}{dynamic\_cast<}\mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<IntsT>}}\&\textcolor{keyword}{>}(this-\/>ints\_);}
\DoxyCodeLine{113     \mbox{\hyperlink{classChronusQ_1_1CQMemManager}{CQMemManager}}\& memManager\_ = eri.\mbox{\hyperlink{classChronusQ_1_1ParticleIntegrals_a4980f581ea843bd4ca6be7ac88064274}{memManager}}();}
\DoxyCodeLine{114     \mbox{\hyperlink{structChronusQ_1_1BasisSet}{BasisSet}}\& basisSet\_ = eri.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a4a476a2dc5e606ee34f0a973b9ddce5c}{basisSet}}();}
\DoxyCodeLine{115 }
\DoxyCodeLine{116     \textcolor{keywordtype}{size\_t} nthreads  = \mbox{\hyperlink{namespaceChronusQ_a3320ee560c87921c8d84885db82e9917}{GetNumThreads}}();}
\DoxyCodeLine{117     \textcolor{keywordtype}{size\_t} LAThreads = \mbox{\hyperlink{namespaceChronusQ_a3152808c4819d6cbf8a29aef92728866}{GetLAThreads}}();}
\DoxyCodeLine{118     \textcolor{keywordtype}{size\_t} mpiRank   = \mbox{\hyperlink{namespaceChronusQ_ac9433164d43ee9f6f0c49e49698f680f}{MPIRank}}(comm);}
\DoxyCodeLine{119     \textcolor{keywordtype}{size\_t} mpiSize   = \mbox{\hyperlink{namespaceChronusQ_a6ef99d456575a9727c4d7d4eb8149416}{MPISize}}(comm);}
\DoxyCodeLine{120 }
\DoxyCodeLine{121     \mbox{\hyperlink{namespaceChronusQ_a7b13ac1d1109f4a015feaab04cb3eaee}{SetLAThreads}}(1); \textcolor{comment}{// Turn off parallelism in LA functions}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NB   = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a40ad4a89b440bf71e0ef6ba317d8123f}{nBasis}};}
\DoxyCodeLine{124     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NMat = list.size();}
\DoxyCodeLine{125     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NS   = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a936871b121472a416ee6f947ccdea4b4}{nShell}};}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 }
\DoxyCodeLine{128 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{129     \textcolor{comment}{// Check whether any of the contractions are non-\/hermetian}}
\DoxyCodeLine{130     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} AnyNonHer = std::any\_of(list.begin(),list.end(),}
\DoxyCodeLine{131       []( \mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction}{TwoBodyContraction<MatsT>}} \& x ) -\/> \textcolor{keywordtype}{bool} \{ return not x.HER; \});}
\DoxyCodeLine{132 }
\DoxyCodeLine{133     \textcolor{comment}{// Compute schwarz bounds if we haven't already}}
\DoxyCodeLine{134     \textcolor{keywordflow}{if}(eri.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a5fe8f1b07ffeec39f48faae7987cdfdf}{schwarz}}() == \textcolor{keyword}{nullptr}) eri.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_ac90ba6c59e4593db8986495779bea090}{computeSchwarz}}();}
\DoxyCodeLine{135 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 }
\DoxyCodeLine{138 \textcolor{comment}{/*}}
\DoxyCodeLine{139 \textcolor{comment}{    if( mpiSize > 1 )}}
\DoxyCodeLine{140 \textcolor{comment}{      for(auto \&C : list )}}
\DoxyCodeLine{141 \textcolor{comment}{        prettyPrintSmart(std::cerr,"{}X in Direct"{},C.X,NB,NB,NB);}}
\DoxyCodeLine{142 \textcolor{comment}{*/}}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 }
\DoxyCodeLine{145     \textcolor{comment}{// Create thread-\/safe libint2::Engine's}}
\DoxyCodeLine{146       }
\DoxyCodeLine{147     std::vector<libint2::Engine> engines(nthreads);}
\DoxyCodeLine{148 }
\DoxyCodeLine{149     \textcolor{comment}{// Construct engine for master thread}}
\DoxyCodeLine{150     engines[0] = libint2::Engine(libint2::Operator::coulomb,}
\DoxyCodeLine{151       basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}}, basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a90bfe80774a23ae70d381783a1d275ac}{maxL}}, 0);}
\DoxyCodeLine{152 }
\DoxyCodeLine{153 }
\DoxyCodeLine{154 }
\DoxyCodeLine{155 }
\DoxyCodeLine{156 }
\DoxyCodeLine{157     \textcolor{comment}{// Allocate scratch for raw integral batches}}
\DoxyCodeLine{158     \textcolor{keywordtype}{size\_t} maxShellSize = }
\DoxyCodeLine{159       std::max\_element(basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.begin(),basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.end(),}
\DoxyCodeLine{160         [](libint2::Shell \&sh1, libint2::Shell \&sh2) \{}
\DoxyCodeLine{161           return sh1.size() < sh2.size();}
\DoxyCodeLine{162         \})-\/>size();}
\DoxyCodeLine{163 }
\DoxyCodeLine{164     \textcolor{keywordtype}{size\_t} lenIntBuffer = }
\DoxyCodeLine{165       maxShellSize * maxShellSize * maxShellSize * maxShellSize; }
\DoxyCodeLine{166 }
\DoxyCodeLine{167     lenIntBuffer *= \textcolor{keyword}{sizeof}(MatsT) / \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double});}
\DoxyCodeLine{168 }
\DoxyCodeLine{169     \textcolor{keywordtype}{size\_t} nBuffer = 2;}
\DoxyCodeLine{170 }
\DoxyCodeLine{171     \textcolor{keywordtype}{size\_t} nAlloc = nBuffer*lenIntBuffer*nthreads*\textcolor{keyword}{sizeof}(double) + }
\DoxyCodeLine{172       nthreads*NMat*NB*NB*\textcolor{keyword}{sizeof}(MatsT) +}
\DoxyCodeLine{173       list.size()*NS*NS*\textcolor{keyword}{sizeof}(double);}
\DoxyCodeLine{174 \textcolor{comment}{//  std::cerr << "{}DIRECT CONTRACTION "{} << nAlloc / 1e9 << std::endl;}}
\DoxyCodeLine{175 }
\DoxyCodeLine{176 }
\DoxyCodeLine{177     \textcolor{keywordtype}{double} * intBuffer = }
\DoxyCodeLine{178       memManager\_.malloc<\textcolor{keywordtype}{double}>(nBuffer*lenIntBuffer*nthreads);}
\DoxyCodeLine{179    }
\DoxyCodeLine{180     \textcolor{keywordtype}{double} *intBuffer2 = intBuffer + nthreads*lenIntBuffer;}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 }
\DoxyCodeLine{183     \textcolor{comment}{// Allocate thread local storage to store integral contractions}}
\DoxyCodeLine{184     \textcolor{comment}{// XXX: Don't allocate anything if serial}}
\DoxyCodeLine{185     std::vector<std::vector<MatsT*>> AXthreads;}
\DoxyCodeLine{186     MatsT *AXRaw = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{187     \textcolor{keywordflow}{if}(nthreads != 1) \{}
\DoxyCodeLine{188       AXRaw = memManager\_.malloc<MatsT>(nthreads*NMat*NB*NB);}
\DoxyCodeLine{189       memset(AXRaw,0,nthreads*NMat*NB*NB*\textcolor{keyword}{sizeof}(MatsT));}
\DoxyCodeLine{190     \}}
\DoxyCodeLine{191 }
\DoxyCodeLine{192     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ithread = 0, iMat = 0; ithread < nthreads; ithread++) \{}
\DoxyCodeLine{193       AXthreads.emplace\_back();}
\DoxyCodeLine{194       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jMat = 0; jMat < NMat; jMat++, iMat++) \{}
\DoxyCodeLine{195         \textcolor{keywordflow}{if}(nthreads == 1) \{}
\DoxyCodeLine{196           AXthreads.back().push\_back(list[jMat].AX);}
\DoxyCodeLine{197         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{198           AXthreads.back().push\_back(AXRaw + iMat*NB*NB);}
\DoxyCodeLine{199         \}}
\DoxyCodeLine{200       \}}
\DoxyCodeLine{201     \}}
\DoxyCodeLine{202 }
\DoxyCodeLine{203 }
\DoxyCodeLine{204 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{205     \textcolor{comment}{// Compute shell block norms}}
\DoxyCodeLine{206     \textcolor{keywordtype}{double} *ShBlkNorms\_raw = }
\DoxyCodeLine{207       memManager\_.malloc<\textcolor{keywordtype}{double}>(list.size()*NS*NS);}
\DoxyCodeLine{208 }
\DoxyCodeLine{209     std::vector<double*> ShBlkNorms;}
\DoxyCodeLine{210     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0, iOff = 0; iMat < NMat; iMat++, }
\DoxyCodeLine{211       iOff += NS*NS ) \{}
\DoxyCodeLine{212 }
\DoxyCodeLine{213       \mbox{\hyperlink{namespaceChronusQ_ade3d6fad69f4d04c7a642580c77ddb1b}{ShellBlockNorm}}(basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}},list[iMat].X,NB,}
\DoxyCodeLine{214         ShBlkNorms\_raw + iOff);}
\DoxyCodeLine{215 }
\DoxyCodeLine{216       ShBlkNorms.emplace\_back(ShBlkNorms\_raw + iOff);}
\DoxyCodeLine{217 }
\DoxyCodeLine{218     \}}
\DoxyCodeLine{219 }
\DoxyCodeLine{220     \textcolor{keywordtype}{double} maxShBlk = 0.;}
\DoxyCodeLine{221     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0; iMat < NMat; iMat++)}
\DoxyCodeLine{222       maxShBlk = std::max(maxShBlk,}
\DoxyCodeLine{223         *std::max\_element(ShBlkNorms[iMat],ShBlkNorms[iMat] + NS*NS) ); }
\DoxyCodeLine{224 }
\DoxyCodeLine{225 }
\DoxyCodeLine{226     \textcolor{keywordtype}{size\_t} NP4 = }
\DoxyCodeLine{227       basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}} * basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}} * basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}} * }
\DoxyCodeLine{228       basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}};}
\DoxyCodeLine{229 }
\DoxyCodeLine{230     engines[0].set\_precision(}
\DoxyCodeLine{231       std::min(}
\DoxyCodeLine{232         std::numeric\_limits<double>::epsilon(),}
\DoxyCodeLine{233         eri.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a51ce753ee588706401406d4216c1ba74}{threshSchwarz}}() / maxShBlk}
\DoxyCodeLine{234       ) / NP4}
\DoxyCodeLine{235     );}
\DoxyCodeLine{236 }
\DoxyCodeLine{237 }
\DoxyCodeLine{238 }
\DoxyCodeLine{239     \textcolor{comment}{// Get the max over all the matricies for}}
\DoxyCodeLine{240     \textcolor{comment}{// the shell block norms}}
\DoxyCodeLine{241     \textcolor{comment}{// OVERWRITES ShBlkNorms[0]}}
\DoxyCodeLine{242     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0; k < NS*NS; k++) \{}
\DoxyCodeLine{243 }
\DoxyCodeLine{244       \textcolor{keywordtype}{double} mx = std::abs(ShBlkNorms[0][k]);}
\DoxyCodeLine{245       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 1; iMat < NMat; iMat++)}
\DoxyCodeLine{246         mx = std::max(mx,std::abs(ShBlkNorms[iMat][k]));}
\DoxyCodeLine{247       ShBlkNorms[0][k] = mx;}
\DoxyCodeLine{248 }
\DoxyCodeLine{249     \}}
\DoxyCodeLine{250 }
\DoxyCodeLine{251 }
\DoxyCodeLine{252     \textcolor{keywordflow}{if}( AnyNonHer )}
\DoxyCodeLine{253     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0; i < NS; i++)}
\DoxyCodeLine{254     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0; j <= i; j++) \{}
\DoxyCodeLine{255       \textcolor{keywordtype}{double} mx = }
\DoxyCodeLine{256         std::max(std::abs(ShBlkNorms[0][i + j*NS]),}
\DoxyCodeLine{257                  std::abs(ShBlkNorms[0][j + i*NS]));}
\DoxyCodeLine{258 }
\DoxyCodeLine{259       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 1; iMat < NMat; iMat++)}
\DoxyCodeLine{260         mx = std::max(mx,}
\DoxyCodeLine{261           std::max(std::abs(ShBlkNorms[iMat][i + j*NS]),}
\DoxyCodeLine{262                    std::abs(ShBlkNorms[iMat][j + i*NS])));}
\DoxyCodeLine{263 }
\DoxyCodeLine{264       ShBlkNorms[0][i + j*NS] = mx;}
\DoxyCodeLine{265       ShBlkNorms[0][j + i*NS] = mx;}
\DoxyCodeLine{266 }
\DoxyCodeLine{267     \}}
\DoxyCodeLine{268 }
\DoxyCodeLine{269 }
\DoxyCodeLine{270 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{271     \textcolor{comment}{// Set precision}}
\DoxyCodeLine{272     engines[0].set\_precision(std::numeric\_limits<double>::epsilon());}
\DoxyCodeLine{273 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{274 }
\DoxyCodeLine{275 }
\DoxyCodeLine{276     \textcolor{comment}{// Copy master thread engine to other threads}}
\DoxyCodeLine{277     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 1; i < nthreads; i++) engines[i] = engines[0];}
\DoxyCodeLine{278 }
\DoxyCodeLine{279 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{280     std::chrono::duration<double> durInner(0.), durCont(0.), durSymm(0.),}
\DoxyCodeLine{281       durZero(0.);}
\DoxyCodeLine{282 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{283 }
\DoxyCodeLine{284     \textcolor{comment}{// Keeping track of number of integrals skipped}}
\DoxyCodeLine{285     std::vector<size\_t> nSkip(nthreads,0);}
\DoxyCodeLine{286 }
\DoxyCodeLine{287 }
\DoxyCodeLine{288     \textcolor{comment}{// MPI info}}
\DoxyCodeLine{289     \textcolor{keywordtype}{size\_t} mpiChunks = (NS * (NS + 1) / 2) / mpiSize;}
\DoxyCodeLine{290     \textcolor{keywordtype}{size\_t} mpiS12St  = mpiRank * mpiChunks;}
\DoxyCodeLine{291     \textcolor{keywordtype}{size\_t} mpiS12End = (mpiRank + 1) * mpiChunks;}
\DoxyCodeLine{292     \textcolor{keywordflow}{if}( mpiRank == (mpiSize -\/ 1) ) mpiS12End = (NS * (NS + 1) / 2);}
\DoxyCodeLine{293 }
\DoxyCodeLine{294 \textcolor{comment}{/*}}
\DoxyCodeLine{295 \textcolor{comment}{    double t1 = MPI\_Wtime();}}
\DoxyCodeLine{296 \textcolor{comment}{    auto topDirect = std::chrono::high\_resolution\_clock::now();}}
\DoxyCodeLine{297 \textcolor{comment}{*/}}
\DoxyCodeLine{298     \textcolor{keyword}{auto} topDirect = \mbox{\hyperlink{namespaceChronusQ_a715f671201f0f6e77216fcf1f72adbaf}{tick}}();}
\DoxyCodeLine{299 \textcolor{preprocessor}{    \#pragma omp parallel}}
\DoxyCodeLine{300     \{}
\DoxyCodeLine{301 }
\DoxyCodeLine{302     \textcolor{comment}{// Set up thread local storage}}
\DoxyCodeLine{303 }
\DoxyCodeLine{304     \textcolor{comment}{// SMP info}}
\DoxyCodeLine{305     \textcolor{keywordtype}{size\_t} thread\_id = \mbox{\hyperlink{namespaceChronusQ_aa348a017ee78c3450480773ddc542e5c}{GetThreadID}}();}
\DoxyCodeLine{306 }
\DoxyCodeLine{307     \textcolor{keyword}{auto} \&engine = engines[thread\_id];}
\DoxyCodeLine{308     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& buf\_vec = engine.results();}
\DoxyCodeLine{309     }
\DoxyCodeLine{310     \textcolor{keyword}{auto} \&AX\_loc = AXthreads[thread\_id];}
\DoxyCodeLine{311 }
\DoxyCodeLine{312 }
\DoxyCodeLine{313     \textcolor{keywordtype}{double} * intBuffer\_loc  = intBuffer  + thread\_id*lenIntBuffer;}
\DoxyCodeLine{314     \textcolor{keywordtype}{double} * intBuffer2\_loc = intBuffer2 + thread\_id*lenIntBuffer;}
\DoxyCodeLine{315 }
\DoxyCodeLine{316 }
\DoxyCodeLine{317     \textcolor{keywordtype}{size\_t} n1,n2;}
\DoxyCodeLine{318 }
\DoxyCodeLine{319     \textcolor{comment}{// Always Loop over s2 <= s1}}
\DoxyCodeLine{320     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} s1(0ul), bf1\_s(0ul), s12(0ul); s1 < NS; bf1\_s+=n1, s1++) \{ }
\DoxyCodeLine{321       n1 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1].size(); \textcolor{comment}{// Size of Shell 1}}
\DoxyCodeLine{322 }
\DoxyCodeLine{323     \textcolor{keyword}{auto} sigPair12\_it = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a9ce9c1c8374ab7f969f8fbf661fcd9ac}{shData}}.at(s1).begin();}
\DoxyCodeLine{324     \textcolor{keywordflow}{for}( \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t}\& s2 : basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a6ec4c9f444b6971af4f7d8a0f833af53}{sigShellPair}}[s1] ) \{}
\DoxyCodeLine{325       \textcolor{keywordtype}{size\_t} bf2\_s = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a85f991b14d3877ba9dd6d5f3568ce2cc}{mapSh2Bf}}[s2];}
\DoxyCodeLine{326       n2 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2].size(); \textcolor{comment}{// Size of Shell 2}}
\DoxyCodeLine{327 }
\DoxyCodeLine{328       \textcolor{keyword}{const} \textcolor{keyword}{auto} * sigPair12 = sigPair12\_it-\/>get();}
\DoxyCodeLine{329       sigPair12\_it++;}
\DoxyCodeLine{330 }
\DoxyCodeLine{331 \textcolor{preprocessor}{\#ifdef CQ\_ENABLE\_MPI}}
\DoxyCodeLine{332       \textcolor{comment}{// MPI partition s12 blocks}}
\DoxyCodeLine{333       \textcolor{keywordflow}{if}( (s12 < mpiS12St) or (s12 >= mpiS12End) ) \{ s12++; \textcolor{keywordflow}{continue}; \}}
\DoxyCodeLine{334 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{335 }
\DoxyCodeLine{336       \textcolor{comment}{// Round-\/Robbin work distribution}}
\DoxyCodeLine{337       \textcolor{keywordflow}{if}( (s12++) \% nthreads != thread\_id ) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{338 }
\DoxyCodeLine{339 }
\DoxyCodeLine{340       \textcolor{comment}{// Cache variables for shells 1 and 2}}
\DoxyCodeLine{341         }
\DoxyCodeLine{342 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{343       \textcolor{comment}{// Deneneracy factor for s1,s2 pair}}
\DoxyCodeLine{344       \textcolor{keywordtype}{double} s12\_deg = (s1 == s2) ? 1.0 : 2.0;}
\DoxyCodeLine{345 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{346 }
\DoxyCodeLine{347 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{348       \textcolor{keywordtype}{double} shz12 = 0, shMax12 = 0;}
\DoxyCodeLine{349       \textcolor{keywordflow}{if}( screen ) \{}
\DoxyCodeLine{350         shz12 = eri.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a5fe8f1b07ffeec39f48faae7987cdfdf}{schwarz}}()[s1 + s2*NS];}
\DoxyCodeLine{351         shMax12 = ShBlkNorms[0][s1 + s2*NS];}
\DoxyCodeLine{352       \}}
\DoxyCodeLine{353 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{354 }
\DoxyCodeLine{355 }
\DoxyCodeLine{356 }
\DoxyCodeLine{357 \textcolor{preprocessor}{\#ifdef \_BATCH\_DIRECT}}
\DoxyCodeLine{358 }
\DoxyCodeLine{359 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{360       \textcolor{keyword}{auto} topZero = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{361 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{362 }
\DoxyCodeLine{363       \textcolor{comment}{// Zero out the integral buffer (hot spot)}}
\DoxyCodeLine{364       memset(intBuffer\_loc,0,lenIntBuffer);}
\DoxyCodeLine{365 }
\DoxyCodeLine{366 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{367       \textcolor{keyword}{auto} botZero = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{368       durZero += botZero -\/ topZero;}
\DoxyCodeLine{369 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{370 }
\DoxyCodeLine{371       \textcolor{keywordtype}{double} *intBuffCur = intBuffer\_loc;}
\DoxyCodeLine{372 }
\DoxyCodeLine{373 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{374 }
\DoxyCodeLine{375 }
\DoxyCodeLine{376 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{377       \textcolor{keyword}{auto} topInner = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{378 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 }
\DoxyCodeLine{381 \textcolor{comment}{// The upper bound of s3 is s1 for the 8-\/fold symmetry and}}
\DoxyCodeLine{382 \textcolor{comment}{// nShell for 4-\/fold.}}
\DoxyCodeLine{383 \textcolor{preprocessor}{\#ifdef \_USE\_EIGHT\_FOLD}}
\DoxyCodeLine{384 \textcolor{preprocessor}{  \#define S3\_MAX s1}}
\DoxyCodeLine{385 \textcolor{preprocessor}{\#elif defined(\_USE\_FOUR\_FOLD)}}
\DoxyCodeLine{386   \textcolor{comment}{// the "{}-\/"{} is for the <= in the loop}}
\DoxyCodeLine{387 \textcolor{preprocessor}{  \#define S3\_MAX NS -\/ 1}}
\DoxyCodeLine{388 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{389 }
\DoxyCodeLine{390       \textcolor{keywordtype}{size\_t} n3,n4;}
\DoxyCodeLine{391 }
\DoxyCodeLine{392       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} s3(0ul), bf3\_s(0ul), s34(0ul); s3 <= \mbox{\hyperlink{contract_2direct_8hpp_ac708ebfb62ad4528bedaeffbe28a3e06}{S3\_MAX}}; s3++, bf3\_s += n3) \{ }
\DoxyCodeLine{393         n3 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3].size(); \textcolor{comment}{// Size of Shell 3}}
\DoxyCodeLine{394 }
\DoxyCodeLine{395 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{396 }
\DoxyCodeLine{397         \textcolor{keywordtype}{double} shMax123 = 0;}
\DoxyCodeLine{398         \textcolor{keywordflow}{if}( screen ) \{}
\DoxyCodeLine{399           \textcolor{comment}{// Pre-\/calculate shell-\/block norm max's that only}}
\DoxyCodeLine{400           \textcolor{comment}{// depend on shells 1,2 and 3}}
\DoxyCodeLine{401           shMax123 = }
\DoxyCodeLine{402             std::max(ShBlkNorms[0][s1 + s3*NS], }
\DoxyCodeLine{403                      ShBlkNorms[0][s2 + s3*NS]);}
\DoxyCodeLine{404 }
\DoxyCodeLine{405           shMax123 = std::max(shMax123,shMax12);}
\DoxyCodeLine{406         \}}
\DoxyCodeLine{407 }
\DoxyCodeLine{408 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{409         }
\DoxyCodeLine{410 \textcolor{comment}{// The upper bound of s4 is either s2 or s3 based on s1 and s3 for}}
\DoxyCodeLine{411 \textcolor{comment}{// the 8-\/fold symmetry and s3 for the 4-\/fold symmetry}}
\DoxyCodeLine{412 \textcolor{preprocessor}{\#ifdef \_USE\_EIGHT\_FOLD}}
\DoxyCodeLine{413         \textcolor{keywordtype}{size\_t} s4\_max = (s1 == s3) ? s2 : s3;}
\DoxyCodeLine{414 \textcolor{preprocessor}{\#elif defined(\_USE\_FOUR\_FOLD)}}
\DoxyCodeLine{415         \textcolor{keywordtype}{size\_t} s4\_max =  s3;}
\DoxyCodeLine{416 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{417 }
\DoxyCodeLine{418       \textcolor{keyword}{auto} sigPair34\_it = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a9ce9c1c8374ab7f969f8fbf661fcd9ac}{shData}}.at(s3).begin();}
\DoxyCodeLine{419       \textcolor{keywordflow}{for}( \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t}\& s4 : basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a6ec4c9f444b6971af4f7d8a0f833af53}{sigShellPair}}[s3] ) \{}
\DoxyCodeLine{420 }
\DoxyCodeLine{421         \textcolor{keywordflow}{if} (s4 > s4\_max)}
\DoxyCodeLine{422           \textcolor{keywordflow}{break};  \textcolor{comment}{// for each s3, s4 are stored in monotonically increasing}}
\DoxyCodeLine{423                   \textcolor{comment}{// order}}
\DoxyCodeLine{424 }
\DoxyCodeLine{425         \textcolor{keyword}{const} \textcolor{keyword}{auto} * sigPair34 = sigPair34\_it-\/>get();}
\DoxyCodeLine{426         sigPair34\_it++;}
\DoxyCodeLine{427                     }
\DoxyCodeLine{428         \textcolor{keywordtype}{size\_t} bf4\_s = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a85f991b14d3877ba9dd6d5f3568ce2cc}{mapSh2Bf}}[s4];}
\DoxyCodeLine{429         n4 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4].size(); \textcolor{comment}{// Size of Shell 4}}
\DoxyCodeLine{430 }
\DoxyCodeLine{431 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{432 }
\DoxyCodeLine{433         \textcolor{keywordtype}{double} shMax = 0;}
\DoxyCodeLine{434 }
\DoxyCodeLine{435         \textcolor{keywordflow}{if}( screen ) \{}
\DoxyCodeLine{436           \textcolor{comment}{// Compute Shell norm max}}
\DoxyCodeLine{437           shMax = }
\DoxyCodeLine{438             std::max(ShBlkNorms[0][s1 + s4*NS],}
\DoxyCodeLine{439             std::max(ShBlkNorms[0][s2 + s4*NS],}
\DoxyCodeLine{440                      ShBlkNorms[0][s3 + s4*NS]));}
\DoxyCodeLine{441 }
\DoxyCodeLine{442           shMax = std::max(shMax,shMax123);}
\DoxyCodeLine{443 }
\DoxyCodeLine{444           \textcolor{keywordflow}{if}((shMax * shz12 * eri.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a5fe8f1b07ffeec39f48faae7987cdfdf}{schwarz}}()[s3 + s4*NS]) <}
\DoxyCodeLine{445              eri.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a51ce753ee588706401406d4216c1ba74}{threshSchwarz}}()) \{ nSkip[thread\_id]++; \textcolor{keywordflow}{continue}; \}}
\DoxyCodeLine{446         \}}
\DoxyCodeLine{447 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{448       }
\DoxyCodeLine{449 }
\DoxyCodeLine{450 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{451 }
\DoxyCodeLine{452         \textcolor{comment}{// Degeneracy factor for s3,s4 pair}}
\DoxyCodeLine{453         \textcolor{keywordtype}{double} s34\_deg = (s3 == s4) ? 1.0 : 2.0;}
\DoxyCodeLine{454 }
\DoxyCodeLine{455         \textcolor{comment}{// Degeneracy factor for s1, s2, s3, s4 quartet}}
\DoxyCodeLine{456         \textcolor{keywordtype}{double} s12\_34\_deg = (s1 == s3) ? (s2 == s4 ? 1.0 : 2.0) : 2.0;}
\DoxyCodeLine{457 }
\DoxyCodeLine{458         \textcolor{comment}{// Total degeneracy factor}}
\DoxyCodeLine{459         \textcolor{keywordtype}{double} s1234\_deg = s12\_deg * s34\_deg * s12\_34\_deg;}
\DoxyCodeLine{460 }
\DoxyCodeLine{461 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{462 }
\DoxyCodeLine{463         \textcolor{comment}{// Evaluate ERI for shell quartet (s1 s2 | s3 s4)}}
\DoxyCodeLine{464         engine.compute2<}
\DoxyCodeLine{465           libint2::Operator::coulomb, libint2::BraKet::xx\_xx, 0>(}
\DoxyCodeLine{466           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1],}
\DoxyCodeLine{467           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2],}
\DoxyCodeLine{468           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3],}
\DoxyCodeLine{469           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4]}
\DoxyCodeLine{470 \textcolor{preprocessor}{\#ifdef \_PRECOMPUTE\_SHELL\_PAIRS}}
\DoxyCodeLine{471           ,sigPair12,sigPair34}
\DoxyCodeLine{472 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{473         );}
\DoxyCodeLine{474 }
\DoxyCodeLine{475         \textcolor{comment}{// Libint2 internal screening}}
\DoxyCodeLine{476         \textcolor{keyword}{const} \textcolor{keywordtype}{double} *buff = buf\_vec[0];}
\DoxyCodeLine{477 }
\DoxyCodeLine{478         \textcolor{keywordflow}{if}(buff == \textcolor{keyword}{nullptr}) \{ nSkip[thread\_id]++; \textcolor{keywordflow}{continue}; \}}
\DoxyCodeLine{479 }
\DoxyCodeLine{480 \textcolor{preprocessor}{\#ifdef \_BATCH\_DIRECT}}
\DoxyCodeLine{481 }
\DoxyCodeLine{482         \textcolor{comment}{// Copy over buffer}}
\DoxyCodeLine{483         \textcolor{comment}{//std::copy\_n(buff,n1*n2*n3*n4,intBuffCur);}}
\DoxyCodeLine{484         memcpy(intBuffCur,buff,n1*n2*n3*n4*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double}));}
\DoxyCodeLine{485         intBuffCur += n1*n2*n3*n4;}
\DoxyCodeLine{486 }
\DoxyCodeLine{487 \textcolor{preprocessor}{\#elif defined(\_FULL\_DIRECT)}}
\DoxyCodeLine{488 }
\DoxyCodeLine{489 \textcolor{comment}{// Flag to turn contraction on and off}}
\DoxyCodeLine{490 \textcolor{preprocessor}{\#if 1}}
\DoxyCodeLine{491         \textcolor{comment}{// Scale the buffer by the degeneracy factor and store}}
\DoxyCodeLine{492         \textcolor{comment}{// in infBuffer}}
\DoxyCodeLine{493         std::transform(buff,buff + n1*n2*n3*n4,intBuffer\_loc,}
\DoxyCodeLine{494           [\&](\textcolor{keyword}{auto}\& x)\{ \textcolor{keywordflow}{return} x*0.5*s1234\_deg; \});}
\DoxyCodeLine{495 }
\DoxyCodeLine{496         \textcolor{keywordtype}{size\_t} b1,b2,b3,b4;}
\DoxyCodeLine{497         \textcolor{keywordtype}{double} *Xp1, *Xp2;}
\DoxyCodeLine{498         \textcolor{keywordtype}{double} X1,X2;}
\DoxyCodeLine{499         MatsT      T1,T2,T3,T4;}
\DoxyCodeLine{500         MatsT      *Tp1,*Tp2;}
\DoxyCodeLine{501 }
\DoxyCodeLine{502         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0; iMat < NMat; iMat++) \{}
\DoxyCodeLine{503           }
\DoxyCodeLine{504           \textcolor{comment}{// Hermetian contraction}}
\DoxyCodeLine{505           \textcolor{keywordflow}{if}( list[iMat].HER ) \{ }
\DoxyCodeLine{506             \textcolor{keywordflow}{if}( list[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} )}
\DoxyCodeLine{507             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{508             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++) \{ }
\DoxyCodeLine{509               \textcolor{comment}{// Cache i,j variables}}
\DoxyCodeLine{510               b1 = bf1 + NB*bf2; }
\DoxyCodeLine{511               X1 = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(list[iMat].X  + b1);}
\DoxyCodeLine{512               Xp1 = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(AX\_loc[iMat] + b1);}
\DoxyCodeLine{513             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) }
\DoxyCodeLine{514             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{515 }
\DoxyCodeLine{516               \textcolor{comment}{// J(1,2) += I * X(4,3)}}
\DoxyCodeLine{517               *Xp1 += *\mbox{\hyperlink{contract_2direct_8hpp_aeabcb643c83e6a65cf0f72831edd377d}{GetRealPtr}}(list[iMat].X,bf4,bf3,NB) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{518 }
\DoxyCodeLine{519               \textcolor{comment}{// J(4,3) += I * X(1,2)}}
\DoxyCodeLine{520               *\mbox{\hyperlink{contract_2direct_8hpp_aeabcb643c83e6a65cf0f72831edd377d}{GetRealPtr}}(AX\_loc[iMat],bf4,bf3,NB) +=  X1 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{521 }
\DoxyCodeLine{522               \textcolor{comment}{// J(2,1) and J(3,4) are handled on symmetrization after}}
\DoxyCodeLine{523               \textcolor{comment}{// contraction}}
\DoxyCodeLine{524             \} \textcolor{comment}{// kl loop}}
\DoxyCodeLine{525             \} \textcolor{comment}{// ij loop}}
\DoxyCodeLine{526 }
\DoxyCodeLine{527             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( list[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} )}
\DoxyCodeLine{528             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{529             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++)       }
\DoxyCodeLine{530             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) \{}
\DoxyCodeLine{531 }
\DoxyCodeLine{532               \textcolor{comment}{// Cache i,j,k variables}}
\DoxyCodeLine{533               b1 = bf1 + bf3*NB;}
\DoxyCodeLine{534               b2 = bf2 + bf3*NB;}
\DoxyCodeLine{535 }
\DoxyCodeLine{536               T1 = 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(list[iMat].X[b1]);}
\DoxyCodeLine{537               T2 = 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(list[iMat].X[b2]);}
\DoxyCodeLine{538 }
\DoxyCodeLine{539             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{540 }
\DoxyCodeLine{541               \textcolor{comment}{// Indicies are swapped here to loop over contiguous memory}}
\DoxyCodeLine{542                 }
\DoxyCodeLine{543               \textcolor{comment}{// K(1,3) += 0.5 * I * X(2,4) = 0.5 * I * CONJ(X(4,2)) (**HER**)}}
\DoxyCodeLine{544               AX\_loc[iMat][b1]           += 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(list[iMat].X[bf4+NB*bf2]) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{545 }
\DoxyCodeLine{546               \textcolor{comment}{// K(4,2) += 0.5 * I * X(3,1) = 0.5 * I * CONJ(X(1,3)) (**HER**)}}
\DoxyCodeLine{547               AX\_loc[iMat][bf4 + bf2*NB] += T1 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{548 }
\DoxyCodeLine{549               \textcolor{comment}{// K(4,1) += 0.5 * I * X(3,2) = 0.5 * I * CONJ(X(2,3)) (**HER**)}}
\DoxyCodeLine{550               AX\_loc[iMat][bf4 + bf1*NB] += T2 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{551 }
\DoxyCodeLine{552               \textcolor{comment}{// K(2,3) += 0.5 * I * X(1,4) = 0.5 * I * CONJ(X(4,1)) (**HER**)}}
\DoxyCodeLine{553               AX\_loc[iMat][b2]           += 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(list[iMat].X[bf4+NB*bf1]) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{554 }
\DoxyCodeLine{555             \} \textcolor{comment}{// l loop}}
\DoxyCodeLine{556             \} \textcolor{comment}{// ijk}}
\DoxyCodeLine{557 }
\DoxyCodeLine{558           \textcolor{comment}{// Nonhermetian contraction}}
\DoxyCodeLine{559           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{560 }
\DoxyCodeLine{561             \textcolor{keywordflow}{if}( list[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} )}
\DoxyCodeLine{562             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{563             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++) \{ }
\DoxyCodeLine{564               \textcolor{comment}{// Cache i,j variables}}
\DoxyCodeLine{565               b1 = bf1 + NB*bf2; }
\DoxyCodeLine{566               T1 = *(list[iMat].X  + b1);}
\DoxyCodeLine{567               Tp1 = (AX\_loc[iMat] + b1);}
\DoxyCodeLine{568 }
\DoxyCodeLine{569               b2 = bf2 + NB*bf1; }
\DoxyCodeLine{570               T2 = *(list[iMat].X  + b2);}
\DoxyCodeLine{571               Tp2 = (AX\_loc[iMat] + b2);}
\DoxyCodeLine{572             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) }
\DoxyCodeLine{573             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{574 }
\DoxyCodeLine{575               \textcolor{comment}{// J(1,2) += I * X(4,3)}}
\DoxyCodeLine{576               *Tp1 += 0.5*( list[iMat].X[bf4 + bf3*NB] + list[iMat].X[bf3 + bf4*NB]) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{577 }
\DoxyCodeLine{578               \textcolor{comment}{// J(3,4) += I * X(2,1)}}
\DoxyCodeLine{579               AX\_loc[iMat][bf3 + bf4*NB] +=  0.5*(T2+T1) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{580 }
\DoxyCodeLine{581               \textcolor{comment}{// J(2,1) += I * X(3,4)}}
\DoxyCodeLine{582               *Tp2 += 0.5*( list[iMat].X[bf4 + bf3*NB] + list[iMat].X[bf3 + bf4*NB]) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{583 }
\DoxyCodeLine{584               \textcolor{comment}{// J(4,3) += I * X(1,2)}}
\DoxyCodeLine{585               AX\_loc[iMat][bf4 + bf3*NB] +=  0.5*(T2+T1) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{586 }
\DoxyCodeLine{587             \} \textcolor{comment}{// kl loop}}
\DoxyCodeLine{588             \} \textcolor{comment}{// ij loop}}
\DoxyCodeLine{589 }
\DoxyCodeLine{590             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( list[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} )}
\DoxyCodeLine{591             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{592             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++)       }
\DoxyCodeLine{593             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) \{}
\DoxyCodeLine{594 }
\DoxyCodeLine{595               \textcolor{comment}{// Cache i,j,k variables}}
\DoxyCodeLine{596               b1 = bf1 + bf3*NB;}
\DoxyCodeLine{597               b2 = bf2 + bf3*NB;}
\DoxyCodeLine{598 }
\DoxyCodeLine{599               T1 = 0.5 * list[iMat].X[b1];}
\DoxyCodeLine{600               T2 = 0.5 * list[iMat].X[b2];}
\DoxyCodeLine{601 }
\DoxyCodeLine{602               b3 = bf3 + bf1*NB;}
\DoxyCodeLine{603               b4 = bf3 + bf2*NB;}
\DoxyCodeLine{604 }
\DoxyCodeLine{605               T3 = 0.5 * list[iMat].X[b3];}
\DoxyCodeLine{606               T4 = 0.5 * list[iMat].X[b4];}
\DoxyCodeLine{607             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{608 }
\DoxyCodeLine{609               \textcolor{comment}{// K(3,1) += 0.5 * I * X(4,2)}}
\DoxyCodeLine{610               AX\_loc[iMat][b3]           += 0.5 * list[iMat].X[bf4+NB*bf2] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{611 }
\DoxyCodeLine{612               \textcolor{comment}{// K(4,2) += 0.5 * I * X(3,1)}}
\DoxyCodeLine{613               AX\_loc[iMat][bf4 + bf2*NB] += T3 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{614  }
\DoxyCodeLine{615               \textcolor{comment}{// K(4,1) += 0.5 * I * X(3,2)}}
\DoxyCodeLine{616               AX\_loc[iMat][bf4 + bf1*NB] += T4 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{617 }
\DoxyCodeLine{618               \textcolor{comment}{// K(3,2) += 0.5 * I * X(4,1)}}
\DoxyCodeLine{619               AX\_loc[iMat][b4]           += 0.5 * list[iMat].X[bf4+NB*bf1] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{620 }
\DoxyCodeLine{621               \textcolor{comment}{// K(1,3) += 0.5 * I * X(2,4)}}
\DoxyCodeLine{622               AX\_loc[iMat][b1]           += 0.5 * list[iMat].X[bf2+NB*bf4] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{623 }
\DoxyCodeLine{624               \textcolor{comment}{// K(2,4) += 0.5 * I * X(1,3)}}
\DoxyCodeLine{625               AX\_loc[iMat][bf2 + bf4*NB] += T1 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{626  }
\DoxyCodeLine{627               \textcolor{comment}{// K(1,4) += 0.5 * I * X(2,3)}}
\DoxyCodeLine{628               AX\_loc[iMat][bf1 + bf4*NB] += T2 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{629 }
\DoxyCodeLine{630               \textcolor{comment}{// K(2,3) += 0.5 * I * X(1,4)}}
\DoxyCodeLine{631               AX\_loc[iMat][b2]           += 0.5 * list[iMat].X[bf1+NB*bf4] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{632 }
\DoxyCodeLine{633             \} \textcolor{comment}{// l loop}}
\DoxyCodeLine{634             \} \textcolor{comment}{// ijk}}
\DoxyCodeLine{635 }
\DoxyCodeLine{636           \} \textcolor{comment}{// Symmetry check}}
\DoxyCodeLine{637 }
\DoxyCodeLine{638         \} \textcolor{comment}{// iMat loop}}
\DoxyCodeLine{639 }
\DoxyCodeLine{640 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{641 }
\DoxyCodeLine{642 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{643 }
\DoxyCodeLine{644       \} \textcolor{comment}{// loop s4}}
\DoxyCodeLine{645       \} \textcolor{comment}{// loop s3}}
\DoxyCodeLine{646 }
\DoxyCodeLine{647 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{648       \textcolor{keyword}{auto} botInner = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{649 }
\DoxyCodeLine{650       durInner += botInner -\/ topInner;}
\DoxyCodeLine{651 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{652 }
\DoxyCodeLine{653 \textcolor{preprocessor}{\#ifdef \_BATCH\_DIRECT}}
\DoxyCodeLine{654 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{655       assert(nthreads == 1);}
\DoxyCodeLine{656 }
\DoxyCodeLine{657 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{658       \textcolor{keyword}{auto} topSymm = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{659 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{660 }
\DoxyCodeLine{661       \textcolor{comment}{// Reorder and expand integrals into square matricies}}
\DoxyCodeLine{662       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} s3 = 0ul, bf3\_s = 0ul, ijkl = 0ul; s3 < NS; s3++, }
\DoxyCodeLine{663         bf3\_s += n3) \{ }
\DoxyCodeLine{664         n3 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3].size();}
\DoxyCodeLine{665 }
\DoxyCodeLine{666       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} s4 = 0ul, bf4\_s = 0ul; s4 <= s3; s4++, bf4\_s += n4) \{ }
\DoxyCodeLine{667         n4 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4].size();}
\DoxyCodeLine{668 }
\DoxyCodeLine{669         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s; i < n1; i++, bf1++)      }
\DoxyCodeLine{670         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++)       }
\DoxyCodeLine{671         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) }
\DoxyCodeLine{672         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{673 }
\DoxyCodeLine{674           intBuffer2\_loc[bf4 + bf3*NB + j*nSQ\_ + i*nSQ\_*n2] = intBuffer\_loc[ijkl];}
\DoxyCodeLine{675           intBuffer2\_loc[bf3 + bf4*NB + j*nSQ\_ + i*nSQ\_*n2] = intBuffer\_loc[ijkl];}
\DoxyCodeLine{676 }
\DoxyCodeLine{677         \}}
\DoxyCodeLine{678 }
\DoxyCodeLine{679       \}}
\DoxyCodeLine{680       \}}
\DoxyCodeLine{681 }
\DoxyCodeLine{682 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{683       \textcolor{keyword}{auto} botSymm = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{684       durSymm += botSymm -\/ topSymm;}
\DoxyCodeLine{685 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{686       }
\DoxyCodeLine{687      }
\DoxyCodeLine{688 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{689       \textcolor{keyword}{auto} topCont = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{690 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{691 }
\DoxyCodeLine{692 }
\DoxyCodeLine{693 }
\DoxyCodeLine{694       \textcolor{comment}{// Perform batched contractions}}
\DoxyCodeLine{695       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} \&C : list ) \{}
\DoxyCodeLine{696 }
\DoxyCodeLine{697         \textcolor{comment}{// J Contraction}}
\DoxyCodeLine{698         \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} ) \{}
\DoxyCodeLine{699 }
\DoxyCodeLine{700           blas::gemm(blas::Layout::ColMajor,blas::Op::Trans,blas::Op::NoTrans,n1*n2,1,nSQ\_,T(1.),intBuffer2\_loc,nSQ\_,C.X,nSQ\_,}
\DoxyCodeLine{701             T(0.),\textcolor{keyword}{reinterpret\_cast<}G*\textcolor{keyword}{>}(intBuffer\_loc),n1*n2);}
\DoxyCodeLine{702 }
\DoxyCodeLine{703           \textcolor{comment}{// Populate the lower triangle of J contraction storage}}
\DoxyCodeLine{704           \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s; i < n1; i++, bf1++)      }
\DoxyCodeLine{705           \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++)}
\DoxyCodeLine{706             C.AX[bf1 + bf2*NB] = intBuffer\_loc[j + i*n2]; }
\DoxyCodeLine{707 }
\DoxyCodeLine{708         \textcolor{comment}{// K Contraction}}
\DoxyCodeLine{709         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} ) \{}
\DoxyCodeLine{710 }
\DoxyCodeLine{711           \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s; i < n1; i++, bf1++)      }
\DoxyCodeLine{712           \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++) \{}
\DoxyCodeLine{713 }
\DoxyCodeLine{714 \textcolor{comment}{/*}}
\DoxyCodeLine{715 \textcolor{comment}{            // T(m,n) = I(m,k) * X(n,k)}}
\DoxyCodeLine{716 \textcolor{comment}{            blas::gemm(blas::Layout::ColMajor,blas::Op::NoTrans,blas::Op::Trans,NB,NB,NB,T(1.),intBuffer2 +j*nSQ\_ + i*n2*nSQ\_,NB,}}
\DoxyCodeLine{717 \textcolor{comment}{              C.X,NB,T(0.),reinterpret\_cast<G*>(intBuffer),NB);}}
\DoxyCodeLine{718 \textcolor{comment}{}}
\DoxyCodeLine{719 \textcolor{comment}{            for(auto nu = 0; nu < NB; nu++) \{}}
\DoxyCodeLine{720 \textcolor{comment}{              C.AX[nu + bf1*NB] += intBuffer[nu + bf2*NB];}}
\DoxyCodeLine{721 \textcolor{comment}{              if(s1 != s2) \{ }}
\DoxyCodeLine{722 \textcolor{comment}{                C.AX[nu + bf2*NB] += intBuffer[nu + bf1*NB];}}
\DoxyCodeLine{723 \textcolor{comment}{              \}}}
\DoxyCodeLine{724 \textcolor{comment}{            \}}}
\DoxyCodeLine{725 \textcolor{comment}{*/}}
\DoxyCodeLine{726 }
\DoxyCodeLine{727             blas::gemm(blas::Layout::ColMajor,blas::Op::NoTrans,blas::Op::Trans,NB,1,NB,T(1.),intBuffer2\_loc +j*nSQ\_ + i*n2*nSQ\_,NB,}
\DoxyCodeLine{728               C.X + bf2,NB,T(0.),\textcolor{keyword}{reinterpret\_cast<}G*\textcolor{keyword}{>}(intBuffer\_loc),NB);}
\DoxyCodeLine{729             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} nu = 0; nu < NB; nu++) }
\DoxyCodeLine{730               C.AX[nu + bf1*NB] += intBuffer\_loc[nu];}
\DoxyCodeLine{731 }
\DoxyCodeLine{732             \textcolor{keywordflow}{if}( s1 != s2 ) \{}
\DoxyCodeLine{733 }
\DoxyCodeLine{734               blas::gemm(blas::Layout::ColMajor,blas::Op::NoTrans,blas::Op::Trans,NB,1,NB,T(1.),intBuffer2\_loc +j*nSQ\_ + i*n2*nSQ\_,NB,}
\DoxyCodeLine{735                 C.X + bf1,NB,T(0.),\textcolor{keyword}{reinterpret\_cast<}G*\textcolor{keyword}{>}(intBuffer\_loc),NB);}
\DoxyCodeLine{736               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} nu = 0; nu < NB; nu++) }
\DoxyCodeLine{737                 C.AX[nu + bf2*NB] += intBuffer\_loc[nu];}
\DoxyCodeLine{738 }
\DoxyCodeLine{739             \}}
\DoxyCodeLine{740 }
\DoxyCodeLine{741           \} \textcolor{comment}{// ij loop}}
\DoxyCodeLine{742 }
\DoxyCodeLine{743         \} \textcolor{comment}{// Exchange check}}
\DoxyCodeLine{744       \} \textcolor{comment}{// Loop over contractions}}
\DoxyCodeLine{745 }
\DoxyCodeLine{746 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{747       \textcolor{keyword}{auto} botCont = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{748       durCont += botCont -\/ topCont;}
\DoxyCodeLine{749 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{750 }
\DoxyCodeLine{751 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{752 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{753 }
\DoxyCodeLine{754     \}; \textcolor{comment}{// s2}}
\DoxyCodeLine{755     \}; \textcolor{comment}{// s1}}
\DoxyCodeLine{756 }
\DoxyCodeLine{757 }
\DoxyCodeLine{758     \}; \textcolor{comment}{// OpenMP context}}
\DoxyCodeLine{759 }
\DoxyCodeLine{760 \textcolor{comment}{/*}}
\DoxyCodeLine{761 \textcolor{comment}{    auto botDirect = std::chrono::high\_resolution\_clock::now();}}
\DoxyCodeLine{762 \textcolor{comment}{}}
\DoxyCodeLine{763 \textcolor{comment}{    double t2 = MPI\_Wtime();}}
\DoxyCodeLine{764 \textcolor{comment}{*/}}
\DoxyCodeLine{765 }
\DoxyCodeLine{766     \textcolor{keyword}{auto} durDirect = \mbox{\hyperlink{namespaceChronusQ_a3b2153e93af4532ff5b1e75d8af453b0}{tock}}(topDirect);}
\DoxyCodeLine{767 }
\DoxyCodeLine{768 \textcolor{preprocessor}{\#ifdef \_REPORT\_INTEGRAL\_TIMINGS}}
\DoxyCodeLine{769     \textcolor{keywordtype}{size\_t} nIntSkip = std::accumulate(nSkip.begin(),nSkip.end(),0);}
\DoxyCodeLine{770     std::cerr << \textcolor{stringliteral}{"{}Screened "{}} << nIntSkip << std::endl;}
\DoxyCodeLine{771 }
\DoxyCodeLine{772 \textcolor{comment}{//  std::chrono::duration<double> durDirect = botDirect -\/ topDirect;}}
\DoxyCodeLine{773     \textcolor{comment}{//std::cerr << "{}Direct Contraction took "{} << durDirect.count() << "{} s\(\backslash\)n"{}; }}
\DoxyCodeLine{774     std::cerr << \textcolor{stringliteral}{"{}Direct Contraction took "{}} <<  durDirect << \textcolor{stringliteral}{"{} s\(\backslash\)n"{}}; }
\DoxyCodeLine{775 }
\DoxyCodeLine{776 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{777     std::cerr << \textcolor{stringliteral}{"{}  "{}} << durInner.count() << \textcolor{stringliteral}{"{} ("{}} << durInner.count() / durDirect.count() * 100 }
\DoxyCodeLine{778               << \textcolor{stringliteral}{"{}\%) Inner loop"{}} << std::endl;}
\DoxyCodeLine{779 \textcolor{preprocessor}{\#ifndef \_FULL\_DIRECT}}
\DoxyCodeLine{780     std::cerr << \textcolor{stringliteral}{"{}  "{}} << durZero.count() << \textcolor{stringliteral}{"{} ("{}} << durZero.count() / durDirect.count() * 100 }
\DoxyCodeLine{781               << \textcolor{stringliteral}{"{}\%) Zeroing buffer"{}} << std::endl;}
\DoxyCodeLine{782     std::cerr << \textcolor{stringliteral}{"{}  "{}} << durSymm.count() << \textcolor{stringliteral}{"{} ("{}} << durSymm.count() / durDirect.count() * 100 }
\DoxyCodeLine{783               << \textcolor{stringliteral}{"{}\%) Symmetrization loop"{}} << std::endl;}
\DoxyCodeLine{784     std::cerr << \textcolor{stringliteral}{"{}  "{}} << durCont.count() << \textcolor{stringliteral}{"{} ("{}} << durCont.count() / durDirect.count() * 100 }
\DoxyCodeLine{785               << \textcolor{stringliteral}{"{}\%) Contraction loop"{}} << std::endl;}
\DoxyCodeLine{786 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{787 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{788     std::cerr << std::endl;}
\DoxyCodeLine{789 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{790 }
\DoxyCodeLine{791 }
\DoxyCodeLine{792 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{793 }
\DoxyCodeLine{794     MatsT* SCR = memManager\_.malloc<MatsT>(NB*NB);}
\DoxyCodeLine{795     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} iMat = 0; iMat < NMat;  iMat++ ) }
\DoxyCodeLine{796     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} iTh  = 0; iTh < nthreads; iTh++) \{}
\DoxyCodeLine{797   }
\DoxyCodeLine{798     \textcolor{comment}{//prettyPrintSmart(std::cerr,"{}AX "{} + std::to\_string(iMat) + "{} "{} + std::to\_string(iTh),}}
\DoxyCodeLine{799     \textcolor{comment}{//  AXthreads[iTh][iMat],NB,NB,NB);}}
\DoxyCodeLine{800 }
\DoxyCodeLine{801       \textcolor{keywordflow}{if}( list[iMat].HER ) \{}
\DoxyCodeLine{802 }
\DoxyCodeLine{803         \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'C'},NB,NB,MatsT(0.5),AXthreads[iTh][iMat],NB,MatsT(0.5),}
\DoxyCodeLine{804           AXthreads[iTh][iMat],NB,SCR,NB);}
\DoxyCodeLine{805 }
\DoxyCodeLine{806         \textcolor{keywordflow}{if}( nthreads != 1 )}
\DoxyCodeLine{807           \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'N'},NB,NB,MatsT(1.),SCR,NB,MatsT(1.), list[iMat].AX,NB,list[iMat].AX,NB);}
\DoxyCodeLine{808         \textcolor{keywordflow}{else}}
\DoxyCodeLine{809           \mbox{\hyperlink{namespaceChronusQ_ae8f5db3509402cc0920cf103d5fb9952}{SetMat}}(\textcolor{charliteral}{'N'},NB,NB,MatsT(1.),SCR,NB,list[iMat].AX,NB);}
\DoxyCodeLine{810 }
\DoxyCodeLine{811       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{812 }
\DoxyCodeLine{813         \textcolor{keywordflow}{if}( nthreads != 1 )}
\DoxyCodeLine{814           \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'N'},NB,NB,MatsT(0.5),AXthreads[iTh][iMat],NB,}
\DoxyCodeLine{815             MatsT(1.), list[iMat].AX,NB,list[iMat].AX,NB);}
\DoxyCodeLine{816         \textcolor{keywordflow}{else} }
\DoxyCodeLine{817           blas::scal(NB*NB,MatsT(0.5),list[iMat].AX,1);}
\DoxyCodeLine{818 }
\DoxyCodeLine{819 }
\DoxyCodeLine{820       \textcolor{comment}{//std::transform(AXthreads[iTh][iMat], AXthreads[iTh][iMat] + NB*NB, }}
\DoxyCodeLine{821       \textcolor{comment}{//  list[iMat].AX, []( G x ) -\/> G \{ return x / 4.; \} );}}
\DoxyCodeLine{822       \}}
\DoxyCodeLine{823 }
\DoxyCodeLine{824     \};}
\DoxyCodeLine{825     memManager\_.free(SCR);}
\DoxyCodeLine{826     }
\DoxyCodeLine{827 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{828 }
\DoxyCodeLine{829     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \&C : list ) \{}
\DoxyCodeLine{830 }
\DoxyCodeLine{831       \textcolor{comment}{// Symmetrize J contraction}}
\DoxyCodeLine{832       \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} ) }
\DoxyCodeLine{833         \mbox{\hyperlink{namespaceChronusQ_a8de87c3f9b6b79c38f5be581c31dade9}{HerMat}}(\textcolor{charliteral}{'L'},NB,C.AX,NB);}
\DoxyCodeLine{834   }
\DoxyCodeLine{835       \textcolor{comment}{// Inplace transpose of K contraction}}
\DoxyCodeLine{836       \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} ) }
\DoxyCodeLine{837         \mbox{\hyperlink{namespaceChronusQ_abbee1773b3f12915d6c51842e34dc06d}{IMatCopy}}(\textcolor{charliteral}{'C'},NB,NB,MatsT(1.),C.AX,NB,NB);}
\DoxyCodeLine{838 }
\DoxyCodeLine{839     \} \textcolor{comment}{// Loop over contractions}}
\DoxyCodeLine{840 }
\DoxyCodeLine{841 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{842 }
\DoxyCodeLine{843 }
\DoxyCodeLine{844 \textcolor{preprocessor}{\#ifdef CQ\_ENABLE\_MPI}}
\DoxyCodeLine{845     \textcolor{comment}{// Combine all G[X] contributions onto Root process}}
\DoxyCodeLine{846     \textcolor{keywordflow}{if}( mpiSize > 1 ) \{}
\DoxyCodeLine{847 }
\DoxyCodeLine{848       \textcolor{comment}{// FIXME: This should be able to be done with MPI\_IN\_PLACE for}}
\DoxyCodeLine{849       \textcolor{comment}{// the root process}}
\DoxyCodeLine{850         }
\DoxyCodeLine{851       MatsT* mpiScr;}
\DoxyCodeLine{852       \textcolor{keywordflow}{if}( mpiRank == 0 ) mpiScr = memManager\_.malloc<MatsT>(NB*NB);}
\DoxyCodeLine{853 }
\DoxyCodeLine{854       \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \&C : list ) \{}
\DoxyCodeLine{855 \textcolor{comment}{//      prettyPrintSmart(std::cerr,"{}AX in Direct"{},C.AX,NB,NB,NB);}}
\DoxyCodeLine{856 }
\DoxyCodeLine{857         mxx::reduce( C.AX, NB*NB, mpiScr, 0, std::plus<MatsT>(), comm );}
\DoxyCodeLine{858 }
\DoxyCodeLine{859         \textcolor{comment}{// Copy over the output buffer on root}}
\DoxyCodeLine{860         \textcolor{keywordflow}{if}( mpiRank == 0 ) std::copy\_n(mpiScr,NB*NB,C.AX);}
\DoxyCodeLine{861 }
\DoxyCodeLine{862       \}}
\DoxyCodeLine{863 }
\DoxyCodeLine{864       \textcolor{keywordflow}{if}( mpiRank == 0 ) memManager\_.free(mpiScr);}
\DoxyCodeLine{865 }
\DoxyCodeLine{866     \}}
\DoxyCodeLine{867 }
\DoxyCodeLine{868 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{869 }
\DoxyCodeLine{870 }
\DoxyCodeLine{871 }
\DoxyCodeLine{872 }
\DoxyCodeLine{873 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{874     \textcolor{keyword}{auto} topFree = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{875 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{876 }
\DoxyCodeLine{877     \textcolor{comment}{// Free scratch space}}
\DoxyCodeLine{878     memManager\_.free(intBuffer);}
\DoxyCodeLine{879 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{880     memManager\_.free(ShBlkNorms\_raw);}
\DoxyCodeLine{881 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{882     \textcolor{keywordflow}{if}(AXRaw != \textcolor{keyword}{nullptr}) memManager\_.free(AXRaw);}
\DoxyCodeLine{883 }
\DoxyCodeLine{884 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{885     \textcolor{keyword}{auto} botFree = std::chrono::high\_resolution\_clock::now();}
\DoxyCodeLine{886 }
\DoxyCodeLine{887     std::chrono::duration<double> durFree = botFree -\/ topFree;}
\DoxyCodeLine{888 }
\DoxyCodeLine{889     std::cerr << \textcolor{stringliteral}{"{}Free took "{}} << durFree.count() << \textcolor{stringliteral}{"{}s"{}} << std::endl;}
\DoxyCodeLine{890 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{891 }
\DoxyCodeLine{892 }
\DoxyCodeLine{893     \textcolor{comment}{// Turn threads for LA back on}}
\DoxyCodeLine{894     \mbox{\hyperlink{namespaceChronusQ_a7b13ac1d1109f4a015feaab04cb3eaee}{SetLAThreads}}(LAThreads);}
\DoxyCodeLine{895 }
\DoxyCodeLine{896   \};}
\DoxyCodeLine{897 }
\DoxyCodeLine{898 }
\DoxyCodeLine{899 }
\DoxyCodeLine{900   \textcolor{keyword}{template} <>}
\DoxyCodeLine{901   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GTODirectTPIContraction_a9f36964aad737467eccb9c168b01ff85}{GTODirectTPIContraction<dcomplex,dcomplex>::directScaffold}}(}
\DoxyCodeLine{902       \mbox{\hyperlink{structChronusQ_1_1MPI__Comm}{MPI\_Comm}} comm, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} screen,}
\DoxyCodeLine{903       std::vector<\mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction}{TwoBodyContraction<dcomplex>}}> \&list, \mbox{\hyperlink{structChronusQ_1_1EMPerturbation}{EMPerturbation}} \&pert)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{904 }
\DoxyCodeLine{905     \mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<dcomplex>}} \&eri =}
\DoxyCodeLine{906         \textcolor{keyword}{dynamic\_cast<}\mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<dcomplex>}}\&\textcolor{keyword}{>}(this-\/>ints\_);}
\DoxyCodeLine{907     \mbox{\hyperlink{classChronusQ_1_1CQMemManager}{CQMemManager}}\& memManager\_ = eri.\mbox{\hyperlink{classChronusQ_1_1ParticleIntegrals_a4980f581ea843bd4ca6be7ac88064274}{memManager}}();}
\DoxyCodeLine{908     \mbox{\hyperlink{structChronusQ_1_1BasisSet}{BasisSet}}\& basisSet\_ = eri.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a4a476a2dc5e606ee34f0a973b9ddce5c}{basisSet}}();}
\DoxyCodeLine{909      }
\DoxyCodeLine{910 }
\DoxyCodeLine{911     \textcolor{keywordtype}{size\_t} nthreads  = \mbox{\hyperlink{namespaceChronusQ_a3320ee560c87921c8d84885db82e9917}{GetNumThreads}}();}
\DoxyCodeLine{912     \textcolor{keywordtype}{size\_t} LAThreads = \mbox{\hyperlink{namespaceChronusQ_a3152808c4819d6cbf8a29aef92728866}{GetLAThreads}}();}
\DoxyCodeLine{913     \textcolor{keywordtype}{size\_t} mpiRank   = \mbox{\hyperlink{namespaceChronusQ_ac9433164d43ee9f6f0c49e49698f680f}{MPIRank}}(comm);}
\DoxyCodeLine{914     \textcolor{keywordtype}{size\_t} mpiSize   = \mbox{\hyperlink{namespaceChronusQ_a6ef99d456575a9727c4d7d4eb8149416}{MPISize}}(comm);}
\DoxyCodeLine{915 }
\DoxyCodeLine{916     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NB   = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a40ad4a89b440bf71e0ef6ba317d8123f}{nBasis}};}
\DoxyCodeLine{917     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NMat = list.size();}
\DoxyCodeLine{918     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NS   = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a936871b121472a416ee6f947ccdea4b4}{nShell}};}
\DoxyCodeLine{919 }
\DoxyCodeLine{920     \textcolor{keyword}{auto} magAmp = pert.\mbox{\hyperlink{structChronusQ_1_1EMPerturbation_a074c4e7a01eb60481943b4c96a9c9749}{getDipoleAmp}}(\mbox{\hyperlink{namespaceChronusQ_a835c683852c41dbda49a81d46ec94fd9a79930d8d7bb5d90a171f83bdb0a2451f}{Magnetic}});  }
\DoxyCodeLine{921 }
\DoxyCodeLine{922     \textcolor{comment}{// Allocate scratch for raw integral batches}}
\DoxyCodeLine{923     \textcolor{keywordtype}{size\_t} maxShellSize = }
\DoxyCodeLine{924       std::max\_element(basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.begin(),basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.end(),}
\DoxyCodeLine{925         [](libint2::Shell \&sh1, libint2::Shell \&sh2) \{}
\DoxyCodeLine{926           return sh1.size() < sh2.size();}
\DoxyCodeLine{927         \})-\/>size();}
\DoxyCodeLine{928 }
\DoxyCodeLine{929     \textcolor{keywordtype}{size\_t} lenIntBuffer = }
\DoxyCodeLine{930       maxShellSize * maxShellSize * maxShellSize * maxShellSize; }
\DoxyCodeLine{931 }
\DoxyCodeLine{932     \textcolor{keywordtype}{size\_t} nBuffer = 2;}
\DoxyCodeLine{933 }
\DoxyCodeLine{934     \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} * intBuffer = }
\DoxyCodeLine{935       memManager\_.malloc<\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}>(nBuffer*lenIntBuffer*nthreads);}
\DoxyCodeLine{936    }
\DoxyCodeLine{937     \textcolor{comment}{// double *intBuffer2 = intBuffer + nthreads*lenIntBuffer;}}
\DoxyCodeLine{938 }
\DoxyCodeLine{939     \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} * alterintBuffer = }
\DoxyCodeLine{940       memManager\_.malloc<\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}>(nBuffer*lenIntBuffer*nthreads);}
\DoxyCodeLine{941 }
\DoxyCodeLine{942     \textcolor{comment}{// Allocate thread local storage to store integral contractions}}
\DoxyCodeLine{943     \textcolor{comment}{// XXX: Don't allocate anything if serial}}
\DoxyCodeLine{944     std::vector<std::vector<dcomplex*>> AXthreads;}
\DoxyCodeLine{945     \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} *AXRaw = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{946     \textcolor{keywordflow}{if}(nthreads != 1) \{}
\DoxyCodeLine{947       AXRaw = memManager\_.malloc<\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}>(nthreads*NMat*NB*NB);    }
\DoxyCodeLine{948       memset(AXRaw,0,nthreads*NMat*NB*NB*\textcolor{keyword}{sizeof}(\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}));}
\DoxyCodeLine{949     \}}
\DoxyCodeLine{950 }
\DoxyCodeLine{951     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} ithread = 0, iMat = 0; ithread < nthreads; ithread++) \{}
\DoxyCodeLine{952       AXthreads.emplace\_back();}
\DoxyCodeLine{953       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} jMat = 0; jMat < NMat; jMat++, iMat++) \{}
\DoxyCodeLine{954         \textcolor{keywordflow}{if}(nthreads == 1) \{}
\DoxyCodeLine{955           AXthreads.back().push\_back(list[jMat].AX);}
\DoxyCodeLine{956         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{957           AXthreads.back().push\_back(AXRaw + iMat*NB*NB);}
\DoxyCodeLine{958         \}}
\DoxyCodeLine{959       \}}
\DoxyCodeLine{960     \}}
\DoxyCodeLine{961 }
\DoxyCodeLine{962 }
\DoxyCodeLine{963     \textcolor{comment}{// MPI info}}
\DoxyCodeLine{964     \textcolor{keywordtype}{size\_t} mpiChunks = (NS * (NS + 1) / 2) / mpiSize;}
\DoxyCodeLine{965     \textcolor{keywordtype}{size\_t} mpiS12St  = mpiRank * mpiChunks;}
\DoxyCodeLine{966     \textcolor{keywordtype}{size\_t} mpiS12End = (mpiRank + 1) * mpiChunks;}
\DoxyCodeLine{967     \textcolor{keywordflow}{if}( mpiRank == (mpiSize -\/ 1) ) mpiS12End = (NS * (NS + 1) / 2);}
\DoxyCodeLine{968 }
\DoxyCodeLine{969 }
\DoxyCodeLine{970 }
\DoxyCodeLine{971 }
\DoxyCodeLine{972 }
\DoxyCodeLine{973 }
\DoxyCodeLine{974     \textcolor{comment}{// start parallel}}
\DoxyCodeLine{975 \textcolor{preprocessor}{    \#pragma omp parallel}}
\DoxyCodeLine{976     \{}
\DoxyCodeLine{977 }
\DoxyCodeLine{978     \textcolor{comment}{// Set up thread local storage}}
\DoxyCodeLine{979 }
\DoxyCodeLine{980     \textcolor{comment}{// SMP info}}
\DoxyCodeLine{981     \textcolor{keywordtype}{size\_t} thread\_id = \mbox{\hyperlink{namespaceChronusQ_aa348a017ee78c3450480773ddc542e5c}{GetThreadID}}();}
\DoxyCodeLine{982 }
\DoxyCodeLine{983     \textcolor{keyword}{auto} \&AX\_loc = AXthreads[thread\_id];}
\DoxyCodeLine{984 }
\DoxyCodeLine{985 }
\DoxyCodeLine{986     \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} * intBuffer\_loc  = intBuffer  + thread\_id*lenIntBuffer;}
\DoxyCodeLine{987     \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} * alterintBuffer\_loc  = alterintBuffer  + thread\_id*lenIntBuffer;}
\DoxyCodeLine{988 }
\DoxyCodeLine{989 }
\DoxyCodeLine{990     \textcolor{keywordtype}{size\_t} n1,n2;}
\DoxyCodeLine{991 }
\DoxyCodeLine{992     \textcolor{comment}{// Always Loop over s2 <= s1}}
\DoxyCodeLine{993     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} s1(0ul), bf1\_s(0ul), s12(0ul); s1 < NS; bf1\_s+=n1, s1++) \{ }
\DoxyCodeLine{994       n1 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1].size(); \textcolor{comment}{// Size of Shell 1}}
\DoxyCodeLine{995 }
\DoxyCodeLine{996     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} s2 = 0 ; s2 <= s1 ; s2++ ) \{}
\DoxyCodeLine{997       \textcolor{keywordtype}{size\_t} bf2\_s = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a85f991b14d3877ba9dd6d5f3568ce2cc}{mapSh2Bf}}[s2];}
\DoxyCodeLine{998       n2 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2].size(); \textcolor{comment}{// Size of Shell 2}}
\DoxyCodeLine{999 }
\DoxyCodeLine{1000 \textcolor{preprocessor}{\#ifdef CQ\_ENABLE\_MPI}}
\DoxyCodeLine{1001       \textcolor{comment}{// MPI partition s12 blocks}}
\DoxyCodeLine{1002       \textcolor{keywordflow}{if}( (s12 < mpiS12St) or (s12 >= mpiS12End) ) \{ s12++; \textcolor{keywordflow}{continue}; \}}
\DoxyCodeLine{1003 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1004 }
\DoxyCodeLine{1005       \textcolor{comment}{// Round-\/Robbin work distribution}}
\DoxyCodeLine{1006       \textcolor{keywordflow}{if}( (s12++) \% nthreads != thread\_id ) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{1007 }
\DoxyCodeLine{1008 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{1009       \textcolor{comment}{// Deneneracy factor for s1,s2 pair}}
\DoxyCodeLine{1010       \textcolor{keywordtype}{double} s12\_deg = (s1 == s2) ? 1.0 : 2.0;}
\DoxyCodeLine{1011 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1012 }
\DoxyCodeLine{1013 }
\DoxyCodeLine{1014       \textcolor{comment}{//SS Start generate shellpair1 }}
\DoxyCodeLine{1015 }
\DoxyCodeLine{1016       libint2::ShellPair pair1\_to\_use;}
\DoxyCodeLine{1017       pair1\_to\_use.init( basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1],basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2],-\/1000);}
\DoxyCodeLine{1018 }
\DoxyCodeLine{1019       libint2::ShellPair pair1\_to\_use\_switch;}
\DoxyCodeLine{1020       pair1\_to\_use\_switch.init( basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2],basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1],-\/1000); }
\DoxyCodeLine{1021 }
\DoxyCodeLine{1022 \textcolor{comment}{// The upper bound of s3 is s1 for the 8-\/fold symmetry and}}
\DoxyCodeLine{1023 \textcolor{comment}{// nShell for 4-\/fold.}}
\DoxyCodeLine{1024 \textcolor{preprocessor}{\#ifdef \_USE\_EIGHT\_FOLD}}
\DoxyCodeLine{1025 \textcolor{preprocessor}{  \#define S3\_MAX s1}}
\DoxyCodeLine{1026 \textcolor{preprocessor}{\#elif defined(\_USE\_FOUR\_FOLD)}}
\DoxyCodeLine{1027   \textcolor{comment}{// the "{}-\/"{} is for the <= in the loop}}
\DoxyCodeLine{1028 \textcolor{preprocessor}{  \#define S3\_MAX NS -\/ 1}}
\DoxyCodeLine{1029 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1030 }
\DoxyCodeLine{1031       \textcolor{keywordtype}{size\_t} n3,n4;}
\DoxyCodeLine{1032 }
\DoxyCodeLine{1033       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} s3(0), bf3\_s(0), s34(0); s3 <= \mbox{\hyperlink{contract_2direct_8hpp_ac708ebfb62ad4528bedaeffbe28a3e06}{S3\_MAX}}; s3++, bf3\_s += n3) \{}
\DoxyCodeLine{1034         n3 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3].size(); \textcolor{comment}{// Size of Shell 3}}
\DoxyCodeLine{1035 }
\DoxyCodeLine{1036 }
\DoxyCodeLine{1037 }
\DoxyCodeLine{1038 }
\DoxyCodeLine{1039 }
\DoxyCodeLine{1040 \textcolor{comment}{// The upper bound of s4 is either s2 or s3 based on s1 and s3 for}}
\DoxyCodeLine{1041 \textcolor{comment}{// the 8-\/fold symmetry and s3 for the 4-\/fold symmetry}}
\DoxyCodeLine{1042 \textcolor{preprocessor}{\#ifdef \_USE\_EIGHT\_FOLD}}
\DoxyCodeLine{1043         \textcolor{keywordtype}{size\_t} s4\_max = (s1 == s3) ? s2 : s3;}
\DoxyCodeLine{1044 \textcolor{preprocessor}{\#elif defined(\_USE\_FOUR\_FOLD)}}
\DoxyCodeLine{1045         \textcolor{keywordtype}{size\_t} s4\_max =  s3;}
\DoxyCodeLine{1046 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1047 }
\DoxyCodeLine{1048       \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} s4 = 0 ; s4 <=s4\_max ; s4++ )\{     }
\DoxyCodeLine{1049         \textcolor{keywordflow}{if} (s4 > s4\_max)}
\DoxyCodeLine{1050           \textcolor{keywordflow}{break};  \textcolor{comment}{// for each s3, s4 are stored in monotonically increasing}}
\DoxyCodeLine{1051                   \textcolor{comment}{// order}}
\DoxyCodeLine{1052 }
\DoxyCodeLine{1053 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{1054         \textcolor{keyword}{const} \textcolor{keyword}{auto} * sigPair34 = sigPair34\_it-\/>get();}
\DoxyCodeLine{1055         sigPair34\_it++;}
\DoxyCodeLine{1056 \textcolor{preprocessor}{\#endif }}
\DoxyCodeLine{1057                     }
\DoxyCodeLine{1058         \textcolor{keywordtype}{size\_t} bf4\_s = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a85f991b14d3877ba9dd6d5f3568ce2cc}{mapSh2Bf}}[s4];}
\DoxyCodeLine{1059         n4 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4].size(); \textcolor{comment}{// Size of Shell 4}}
\DoxyCodeLine{1060 }
\DoxyCodeLine{1061 }
\DoxyCodeLine{1062         \textcolor{comment}{//SS start generate shellpair2 and calculate GIAO ERI}}
\DoxyCodeLine{1063 }
\DoxyCodeLine{1064         libint2::ShellPair pair2\_to\_use;}
\DoxyCodeLine{1065         }
\DoxyCodeLine{1066         pair2\_to\_use.init( basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3],basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4],-\/1000);}
\DoxyCodeLine{1067 }
\DoxyCodeLine{1068 \textcolor{comment}{/*}}
\DoxyCodeLine{1069 \textcolor{comment}{        libint2::ShellPair pair2\_to\_use\_switch;}}
\DoxyCodeLine{1070 \textcolor{comment}{        // switch s3 and s4}}
\DoxyCodeLine{1071 \textcolor{comment}{        pair2\_to\_use\_switch.init( basisSet\_.shells[s4],basisSet\_.shells[s3],-\/1000); }}
\DoxyCodeLine{1072 \textcolor{comment}{*/}}
\DoxyCodeLine{1073 }
\DoxyCodeLine{1074 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{1075 }
\DoxyCodeLine{1076         \textcolor{comment}{// Degeneracy factor for s3,s4 pair}}
\DoxyCodeLine{1077         \textcolor{keywordtype}{double} s34\_deg = (s3 == s4) ? 1.0 : 2.0;}
\DoxyCodeLine{1078 }
\DoxyCodeLine{1079         \textcolor{comment}{// Degeneracy factor for s1, s2, s3, s4 quartet}}
\DoxyCodeLine{1080         \textcolor{keywordtype}{double} s12\_34\_deg = (s1 == s3) ? (s2 == s4 ? 1.0 : 2.0) : 2.0;}
\DoxyCodeLine{1081 }
\DoxyCodeLine{1082         \textcolor{comment}{// Total degeneracy factor}}
\DoxyCodeLine{1083         \textcolor{keywordtype}{double} s1234\_deg = s12\_deg * s34\_deg * s12\_34\_deg;}
\DoxyCodeLine{1084 }
\DoxyCodeLine{1085 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1086 }
\DoxyCodeLine{1087         \textcolor{comment}{// Evaluate ERI for shell quartet (s1 s2 | s3 s4)  }}
\DoxyCodeLine{1088 }
\DoxyCodeLine{1089 \textcolor{comment}{// std::cout<<"{}s1 "{}<<s1<<"{} s2 "{}<<s2<<"{} s3 "{}<<s3<<"{} s4 "{}<<s4<<std::endl;}}
\DoxyCodeLine{1090 }
\DoxyCodeLine{1091         \textcolor{comment}{// calculate integral (s1,s2|s3,s4)}}
\DoxyCodeLine{1092         \textcolor{keyword}{auto} two2buff = ComplexGIAOIntEngine::computeGIAOERIabcd(pair1\_to\_use,pair2\_to\_use,}
\DoxyCodeLine{1093           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1],basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2],}
\DoxyCodeLine{1094           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3],basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4],\&magAmp[0]);}
\DoxyCodeLine{1095 }
\DoxyCodeLine{1096 }
\DoxyCodeLine{1097         \textcolor{comment}{// calculate integral (s1,s2|s4,s3)}}
\DoxyCodeLine{1098         \textcolor{keyword}{auto} two2buff\_switch = ComplexGIAOIntEngine::computeGIAOERIabcd(pair1\_to\_use\_switch,pair2\_to\_use,}
\DoxyCodeLine{1099           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2],basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1],}
\DoxyCodeLine{1100           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3],basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4],\&magAmp[0]);}
\DoxyCodeLine{1101         }
\DoxyCodeLine{1102         \textcolor{keyword}{const} \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} *buff = \&(two2buff[0]); }
\DoxyCodeLine{1103         \textcolor{keyword}{const} \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} *buffswitch = \&(two2buff\_switch[0]); }
\DoxyCodeLine{1104 }
\DoxyCodeLine{1105 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{1106 }
\DoxyCodeLine{1107 \textcolor{comment}{// Flag to turn contraction on and off}}
\DoxyCodeLine{1108 \textcolor{preprocessor}{\#if 1}}
\DoxyCodeLine{1109         \textcolor{comment}{// Scale the buffer by the degeneracy factor and store}}
\DoxyCodeLine{1110         \textcolor{comment}{// in infBuffer}}
\DoxyCodeLine{1111 }
\DoxyCodeLine{1112         std::transform(buff,buff + n1*n2*n3*n4 , intBuffer\_loc,}
\DoxyCodeLine{1113           [\&](\textcolor{keyword}{auto}\& x)\{ \textcolor{keywordflow}{return} x*0.5*s1234\_deg; \});}
\DoxyCodeLine{1114 }
\DoxyCodeLine{1115         std::transform(buffswitch,buffswitch+n1*n2*n3*n4 ,alterintBuffer\_loc,}
\DoxyCodeLine{1116           [\&](\textcolor{keyword}{auto}\& x)\{ \textcolor{keywordflow}{return} x*0.5*s1234\_deg; \});}
\DoxyCodeLine{1117 }
\DoxyCodeLine{1118         \textcolor{keywordtype}{size\_t} b1,b2,b3,b4;}
\DoxyCodeLine{1119 }
\DoxyCodeLine{1120         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0; iMat < NMat; iMat++) \{}
\DoxyCodeLine{1121           \textcolor{keyword}{auto}\& C = list[iMat];}
\DoxyCodeLine{1122           }
\DoxyCodeLine{1123           \textcolor{comment}{// Hermetian contraction}}
\DoxyCodeLine{1124           \textcolor{keywordflow}{if}( C.HER ) \{ }
\DoxyCodeLine{1125 }
\DoxyCodeLine{1126             \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} )}
\DoxyCodeLine{1127             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{1128             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++) \{ }
\DoxyCodeLine{1129               \textcolor{comment}{// bf1, bf2 are the index in the matrix}}
\DoxyCodeLine{1130               \textcolor{comment}{// b1 is the index in the whole trunk of number }}
\DoxyCodeLine{1131               \textcolor{comment}{// Cache i,j variables}}
\DoxyCodeLine{1132               b1 = bf1 + NB*bf2; }
\DoxyCodeLine{1133               }
\DoxyCodeLine{1134               \textcolor{comment}{// in GIAO, J is complex. So X1 and Xp1 are not required }}
\DoxyCodeLine{1135               }
\DoxyCodeLine{1136               \textcolor{comment}{// X1 = *reinterpret\_cast<double*>(list[iMat].X  + b1);}}
\DoxyCodeLine{1137               \textcolor{comment}{// Xp1 = reinterpret\_cast<double*>(AX\_loc[iMat] + b1);}}
\DoxyCodeLine{1138             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) }
\DoxyCodeLine{1139             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{}
\DoxyCodeLine{1140 }
\DoxyCodeLine{1141               \textcolor{keywordtype}{int} jikl;}
\DoxyCodeLine{1142               jikl = j*n1*n3*n4 + i*n3*n4 + k*n4 + l;  }
\DoxyCodeLine{1143 }
\DoxyCodeLine{1144 }
\DoxyCodeLine{1145               \textcolor{comment}{// J(1,2) += 1/2[I(1,2|3,4) * X(4,3) + I(1,2|4,3) * X(3,4)]}}
\DoxyCodeLine{1146               AX\_loc[iMat][b1] += 0.5 * (C.X[bf4+bf3*NB] * intBuffer\_loc[ijkl]}
\DoxyCodeLine{1147                             + C.X[bf3+bf4*NB] * std::conj(alterintBuffer\_loc[jikl]));     }
\DoxyCodeLine{1148 }
\DoxyCodeLine{1149               \textcolor{comment}{// J(4,3) += 1/2[I(4,3|2,1) * X(1,2)+I(4,3|1,2) * X(2,1)}}
\DoxyCodeLine{1150               \textcolor{comment}{//         = 1/2[I(1,2|3,4)* *X(1,2)+I(1,2|4,3) * X(2,1)}}
\DoxyCodeLine{1151               AX\_loc[iMat][bf4+bf3*NB] +=  0.5 *( C.X[b1] }
\DoxyCodeLine{1152                                 * std::conj(intBuffer\_loc[ijkl])}
\DoxyCodeLine{1153                             + C.X[bf2+bf1*NB] * std::conj(alterintBuffer\_loc[jikl]));}
\DoxyCodeLine{1154                                                                              }
\DoxyCodeLine{1155               \textcolor{comment}{// J(2,1) and J(3,4) are handled on symmetrization after}}
\DoxyCodeLine{1156               \textcolor{comment}{// contraction}}
\DoxyCodeLine{1157                 }
\DoxyCodeLine{1158             \} \textcolor{comment}{// kl loop}}
\DoxyCodeLine{1159             \} \textcolor{comment}{// ij loop}}
\DoxyCodeLine{1160 }
\DoxyCodeLine{1161             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} )}
\DoxyCodeLine{1162             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{1163             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++)       }
\DoxyCodeLine{1164             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) \{}
\DoxyCodeLine{1165 }
\DoxyCodeLine{1166               \textcolor{comment}{// Cache i,j,k variables}}
\DoxyCodeLine{1167               b1 = bf1 + bf3*NB;}
\DoxyCodeLine{1168               b2 = bf2 + bf3*NB;}
\DoxyCodeLine{1169 }
\DoxyCodeLine{1170               \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} T1 = 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(C.X[b1]);}
\DoxyCodeLine{1171               \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} T2 = 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(C.X[b2]);}
\DoxyCodeLine{1172 }
\DoxyCodeLine{1173             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{1174 }
\DoxyCodeLine{1175               \textcolor{keywordtype}{int} jikl;}
\DoxyCodeLine{1176               jikl = j*n1*n4*n3 + i*n4*n3 + k*n4 + l;  }
\DoxyCodeLine{1177               \textcolor{comment}{// Indicies are swapped here to loop over contiguous memory}}
\DoxyCodeLine{1178                 }
\DoxyCodeLine{1179               \textcolor{comment}{// K(1,3) += 0.5 * I(1,2|4,3) * X(2,4) = 0.5 * I * CONJ(X(4,2)) (**HER**)}}
\DoxyCodeLine{1180               AX\_loc[iMat][b1]           += 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(C.X[bf4+NB*bf2]) * std::conj(alterintBuffer\_loc[jikl]);}
\DoxyCodeLine{1181 }
\DoxyCodeLine{1182               \textcolor{comment}{// K(4,2) += 0.5 * I(4,3|1,2) * X(3,1) = 0.5 * I * CONJ(X(1,3)) (**HER**)}}
\DoxyCodeLine{1183               AX\_loc[iMat][bf4 + bf2*NB] += T1 * std::conj(alterintBuffer\_loc[jikl]);}
\DoxyCodeLine{1184 }
\DoxyCodeLine{1185               \textcolor{comment}{// K(4,1) += 0.5 * I(4,3|2,1) * X(3,2) = 0.5 * I * CONJ(X(2,3)) (**HER**)}}
\DoxyCodeLine{1186               AX\_loc[iMat][bf4 + bf1*NB] += T2 * std::conj( intBuffer\_loc[ijkl] );}
\DoxyCodeLine{1187 }
\DoxyCodeLine{1188               \textcolor{comment}{// K(2,3) += 0.5 * I(2,1|4,3) * X(1,4) = 0.5 * I * CONJ(X(4,1)) (**HER**)}}
\DoxyCodeLine{1189               AX\_loc[iMat][b2]           += 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(C.X[bf4+NB*bf1]) * std::conj( intBuffer\_loc[ijkl] );}
\DoxyCodeLine{1190 }
\DoxyCodeLine{1191             \} \textcolor{comment}{// l loop}}
\DoxyCodeLine{1192             \} \textcolor{comment}{// ijk}}
\DoxyCodeLine{1193 }
\DoxyCodeLine{1194           \} \textcolor{keywordflow}{else} \{    \textcolor{comment}{// here is non Hermitian contraction   }}
\DoxyCodeLine{1195 }
\DoxyCodeLine{1196 }
\DoxyCodeLine{1197             \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} )}
\DoxyCodeLine{1198             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{1199             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++) \{ }
\DoxyCodeLine{1200               \textcolor{comment}{// Cache i,j variables}}
\DoxyCodeLine{1201               b1 = bf1 + NB*bf2; }
\DoxyCodeLine{1202               \textcolor{comment}{// T1 = *(C.X  + b1);}}
\DoxyCodeLine{1203               \textcolor{comment}{// Tp1 = (AX\_loc[iMat] + b1);}}
\DoxyCodeLine{1204 }
\DoxyCodeLine{1205               b2 = bf2 + NB*bf1; }
\DoxyCodeLine{1206               \textcolor{comment}{// T2 = *(list[iMat].X  + b2);}}
\DoxyCodeLine{1207               \textcolor{comment}{// Tp2 = (AX\_loc[iMat] + b2);}}
\DoxyCodeLine{1208             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) }
\DoxyCodeLine{1209             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{1210 }
\DoxyCodeLine{1211 }
\DoxyCodeLine{1212               \textcolor{keywordtype}{int} jikl;}
\DoxyCodeLine{1213               jikl = j*n1*n3*n4 + i*n3*n4 + k*n4 + l;  }
\DoxyCodeLine{1214 }
\DoxyCodeLine{1215 }
\DoxyCodeLine{1216               \textcolor{comment}{// J(1,2) += 1/2*(I(1,2|3,4) * X(4,3) + I(1,2|4,3) * X(3,4) }}
\DoxyCodeLine{1217               AX\_loc[iMat][b1] += 0.5*( C.X[bf4 + bf3*NB]*intBuffer\_loc[ijkl] }
\DoxyCodeLine{1218                          +C.X[bf3 + bf4*NB] * std::conj(alterintBuffer\_loc[jikl]));}
\DoxyCodeLine{1219 }
\DoxyCodeLine{1220               \textcolor{comment}{// J(3,4) += 1/2(I(3,4|1,2) * X(2,1) + I(3,4|2,1) * X(1,2))}}
\DoxyCodeLine{1221               AX\_loc[iMat][bf3 + bf4*NB] += 0.5*( C.X[b2] * intBuffer\_loc[ijkl]}
\DoxyCodeLine{1222                                     +C.X[b1] * alterintBuffer\_loc[jikl]) ;}
\DoxyCodeLine{1223 }
\DoxyCodeLine{1224               \textcolor{comment}{// J(2,1) += 1/2(I(2,1|3,4) * X(4,3) + I(2,1|4,3)* X(3,4))}}
\DoxyCodeLine{1225               AX\_loc[iMat][b2] += 0.5*( C.X[bf4 + bf3*NB] * alterintBuffer\_loc[jikl] }
\DoxyCodeLine{1226                                 + C.X[bf3 + bf4*NB] * std::conj(intBuffer\_loc[ijkl]));}
\DoxyCodeLine{1227 }
\DoxyCodeLine{1228               \textcolor{comment}{// J(4,3) += 1/2[I(4,3|2,1) * X(1,2)+I(4,3|1,2) * X(2,1)}}
\DoxyCodeLine{1229               \textcolor{comment}{//         = 1/2[I(1,2|3,4)* *X(1,2)+I(1,2|4,3) * X(2,1)}}
\DoxyCodeLine{1230               AX\_loc[iMat][bf4+bf3*NB] +=  0.5 * (C.X[b1] }
\DoxyCodeLine{1231                                 * std::conj(intBuffer\_loc[ijkl])}
\DoxyCodeLine{1232                             + C.X[bf2+bf1*NB] * std::conj(alterintBuffer\_loc[jikl]));}
\DoxyCodeLine{1233 }
\DoxyCodeLine{1234             \} \textcolor{comment}{// kl loop}}
\DoxyCodeLine{1235             \} \textcolor{comment}{// ij loop}}
\DoxyCodeLine{1236 }
\DoxyCodeLine{1237             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} )}
\DoxyCodeLine{1238             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{1239             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++)       }
\DoxyCodeLine{1240             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) \{}
\DoxyCodeLine{1241 }
\DoxyCodeLine{1242               \textcolor{comment}{// Cache i,j,k variables}}
\DoxyCodeLine{1243               b1 = bf1 + bf3*NB;}
\DoxyCodeLine{1244               b2 = bf2 + bf3*NB;}
\DoxyCodeLine{1245 }
\DoxyCodeLine{1246               \textcolor{comment}{// T1 = 0.5 * list[iMat].X[b1];}}
\DoxyCodeLine{1247               \textcolor{comment}{// T2 = 0.5 * list[iMat].X[b2];}}
\DoxyCodeLine{1248 }
\DoxyCodeLine{1249               b3 = bf3 + bf1*NB;}
\DoxyCodeLine{1250               b4 = bf3 + bf2*NB;}
\DoxyCodeLine{1251 }
\DoxyCodeLine{1252               \textcolor{comment}{// T3 = 0.5 * list[iMat].X[b3];}}
\DoxyCodeLine{1253               \textcolor{comment}{// T4 = 0.5 * list[iMat].X[b4];}}
\DoxyCodeLine{1254             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{1255 }
\DoxyCodeLine{1256               \textcolor{keywordtype}{int} jikl;}
\DoxyCodeLine{1257               jikl = j*n1*n3*n4 + i*n3*n4 + k*n4 + l;  }
\DoxyCodeLine{1258 }
\DoxyCodeLine{1259               \textcolor{comment}{// K(3,1) += 0.5 * I(3,4|2,1) * X(4,2)}}
\DoxyCodeLine{1260               AX\_loc[iMat][b3]           += 0.5 * C.X[bf4+NB*bf2] * alterintBuffer\_loc[jikl];}
\DoxyCodeLine{1261 }
\DoxyCodeLine{1262               \textcolor{comment}{// K(4,2) += 0.5 * I(4,3|1,2) * X(3,1)}}
\DoxyCodeLine{1263               AX\_loc[iMat][bf4 + bf2*NB] += 0.5 * C.X[b3] * std::conj(alterintBuffer\_loc[jikl]);}
\DoxyCodeLine{1264  }
\DoxyCodeLine{1265               \textcolor{comment}{// K(4,1) += 0.5 * I(4,3|2,1) * X(3,2)}}
\DoxyCodeLine{1266               AX\_loc[iMat][bf4 + bf1*NB] += 0.5 * C.X[b4] * std::conj(intBuffer\_loc[ijkl]);}
\DoxyCodeLine{1267 }
\DoxyCodeLine{1268               \textcolor{comment}{// K(3,2) += 0.5 * I(3,4|1,2) * X(4,1)}}
\DoxyCodeLine{1269               AX\_loc[iMat][b4]           += 0.5 * C.X[bf4+NB*bf1] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1270 }
\DoxyCodeLine{1271               \textcolor{comment}{// K(1,3) += 0.5 * I(1,2|4,3) * X(2,4)}}
\DoxyCodeLine{1272               AX\_loc[iMat][b1]           += 0.5 * C.X[bf2+NB*bf4] * std::conj(alterintBuffer\_loc[jikl]);}
\DoxyCodeLine{1273 }
\DoxyCodeLine{1274               \textcolor{comment}{// K(2,4) += 0.5 * I(2,1|3,4) * X(1,3)}}
\DoxyCodeLine{1275               AX\_loc[iMat][bf2 + bf4*NB] += 0.5 * C.X[b1] * alterintBuffer\_loc[jikl];}
\DoxyCodeLine{1276  }
\DoxyCodeLine{1277               \textcolor{comment}{// K(1,4) += 0.5 * I(1,2|3,4) * X(2,3)}}
\DoxyCodeLine{1278               AX\_loc[iMat][bf1 + bf4*NB] += 0.5 * C.X[b2] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1279 }
\DoxyCodeLine{1280               \textcolor{comment}{// K(2,3) += 0.5 * I(2,1|4,3) * X(1,4)}}
\DoxyCodeLine{1281               AX\_loc[iMat][b2]           += 0.5 * C.X[bf1+NB*bf4] * std::conj(intBuffer\_loc[ijkl]);}
\DoxyCodeLine{1282 }
\DoxyCodeLine{1283             \} \textcolor{comment}{// l loop}}
\DoxyCodeLine{1284             \} \textcolor{comment}{// ijk}}
\DoxyCodeLine{1285 }
\DoxyCodeLine{1286           \} \textcolor{comment}{// non Hermitian finished }}
\DoxyCodeLine{1287 }
\DoxyCodeLine{1288 }
\DoxyCodeLine{1289         \} \textcolor{comment}{// iMat loop}}
\DoxyCodeLine{1290 }
\DoxyCodeLine{1291 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1292 \textcolor{comment}{// this is for if 1}}
\DoxyCodeLine{1293 }
\DoxyCodeLine{1294 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1295 \textcolor{comment}{// this is for ifdef defined(\_FULL\_DIRECT) }}
\DoxyCodeLine{1296 }
\DoxyCodeLine{1297 }
\DoxyCodeLine{1298       \} \textcolor{comment}{// loop s4}}
\DoxyCodeLine{1299       \} \textcolor{comment}{// loop s3}}
\DoxyCodeLine{1300 }
\DoxyCodeLine{1301 }
\DoxyCodeLine{1302 }
\DoxyCodeLine{1303     \}; \textcolor{comment}{// s2}}
\DoxyCodeLine{1304     \}; \textcolor{comment}{// s1}}
\DoxyCodeLine{1305 }
\DoxyCodeLine{1306     \} \textcolor{comment}{// end parallel}}
\DoxyCodeLine{1307 }
\DoxyCodeLine{1308 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{1309 }
\DoxyCodeLine{1310     \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}* SCR = memManager\_.malloc<\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}>(NB*NB);}
\DoxyCodeLine{1311     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} iMat = 0; iMat < NMat;  iMat++ ) }
\DoxyCodeLine{1312     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} iTh  = 0; iTh < nthreads; iTh++) \{}
\DoxyCodeLine{1313   }
\DoxyCodeLine{1314     \textcolor{comment}{//prettyPrintSmart(std::cerr,"{}AX "{} + std::to\_string(iMat) + "{} "{} + std::to\_string(iTh),}}
\DoxyCodeLine{1315     \textcolor{comment}{//  AXthreads[iTh][iMat],NB,NB,NB);}}
\DoxyCodeLine{1316 }
\DoxyCodeLine{1317       \textcolor{keywordflow}{if}( list[iMat].HER ) \{}
\DoxyCodeLine{1318 }
\DoxyCodeLine{1319         \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'C'},NB,NB,\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}(0.5),AXthreads[iTh][iMat],NB,\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}(0.5),}
\DoxyCodeLine{1320           AXthreads[iTh][iMat],NB,SCR,NB);}
\DoxyCodeLine{1321 }
\DoxyCodeLine{1322         \textcolor{keywordflow}{if}( nthreads != 1 )}
\DoxyCodeLine{1323           \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'N'},NB,NB,\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}(1.),SCR,NB,\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}(1.), list[iMat].AX,NB,list[iMat].AX,NB);}
\DoxyCodeLine{1324         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1325           \mbox{\hyperlink{namespaceChronusQ_ae8f5db3509402cc0920cf103d5fb9952}{SetMat}}(\textcolor{charliteral}{'N'},NB,NB,\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}(1.),SCR,NB,list[iMat].AX,NB);}
\DoxyCodeLine{1326 }
\DoxyCodeLine{1327       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1328 }
\DoxyCodeLine{1329         \textcolor{keywordflow}{if}( nthreads != 1 )}
\DoxyCodeLine{1330           \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'N'},NB,NB,\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}(0.5),AXthreads[iTh][iMat],NB,}
\DoxyCodeLine{1331             \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}(1.), list[iMat].AX,NB,list[iMat].AX,NB);}
\DoxyCodeLine{1332         \textcolor{keywordflow}{else} }
\DoxyCodeLine{1333           blas::scal(NB*NB,\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}(0.5),list[iMat].AX,1);}
\DoxyCodeLine{1334 }
\DoxyCodeLine{1335 }
\DoxyCodeLine{1336       \}}
\DoxyCodeLine{1337 }
\DoxyCodeLine{1338     \};}
\DoxyCodeLine{1339     memManager\_.free(SCR);}
\DoxyCodeLine{1340     }
\DoxyCodeLine{1341 }
\DoxyCodeLine{1342 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1343 }
\DoxyCodeLine{1344 \textcolor{preprocessor}{\#ifdef CQ\_ENABLE\_MPI}}
\DoxyCodeLine{1345     \textcolor{comment}{// Combine all G[X] contributions onto Root process}}
\DoxyCodeLine{1346     \textcolor{keywordflow}{if}( mpiSize > 1 ) \{}
\DoxyCodeLine{1347 }
\DoxyCodeLine{1348       \textcolor{comment}{// FIXME: This should be able to be done with MPI\_IN\_PLACE for}}
\DoxyCodeLine{1349       \textcolor{comment}{// the root process}}
\DoxyCodeLine{1350         }
\DoxyCodeLine{1351       \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}* mpiScr;}
\DoxyCodeLine{1352       \textcolor{keywordflow}{if}( mpiRank == 0 ) mpiScr = memManager\_.malloc<\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}>(NB*NB);}
\DoxyCodeLine{1353 }
\DoxyCodeLine{1354       \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \&C : list ) \{}
\DoxyCodeLine{1355 \textcolor{comment}{//      prettyPrintSmart(std::cerr,"{}AX in Direct"{},C.AX,NB,NB,NB);}}
\DoxyCodeLine{1356 }
\DoxyCodeLine{1357         mxx::reduce( C.AX, NB*NB, mpiScr, 0, std::plus<dcomplex>(), comm );}
\DoxyCodeLine{1358 }
\DoxyCodeLine{1359         \textcolor{comment}{// Copy over the output buffer on root}}
\DoxyCodeLine{1360         \textcolor{keywordflow}{if}( mpiRank == 0 ) std::copy\_n(mpiScr,NB*NB,C.AX);}
\DoxyCodeLine{1361 }
\DoxyCodeLine{1362       \}}
\DoxyCodeLine{1363 }
\DoxyCodeLine{1364       \textcolor{keywordflow}{if}( mpiRank == 0 ) memManager\_.free(mpiScr);}
\DoxyCodeLine{1365 }
\DoxyCodeLine{1366     \}}
\DoxyCodeLine{1367 }
\DoxyCodeLine{1368 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1369 }
\DoxyCodeLine{1370 }
\DoxyCodeLine{1371     \textcolor{comment}{// Free scratch space}}
\DoxyCodeLine{1372     memManager\_.free(intBuffer);}
\DoxyCodeLine{1373     memManager\_.free(alterintBuffer);}
\DoxyCodeLine{1374 }
\DoxyCodeLine{1375     \textcolor{keywordflow}{if}(AXRaw != \textcolor{keyword}{nullptr}) memManager\_.free(AXRaw);}
\DoxyCodeLine{1376 }
\DoxyCodeLine{1377 }
\DoxyCodeLine{1378 }
\DoxyCodeLine{1379 }
\DoxyCodeLine{1380 }
\DoxyCodeLine{1381   \}}
\DoxyCodeLine{1382 }
\DoxyCodeLine{1383   \textcolor{keyword}{template} <>}
\DoxyCodeLine{1384   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GTODirectTPIContraction}{GTODirectTPIContraction<double,double>::directScaffold}}(}
\DoxyCodeLine{1385     \mbox{\hyperlink{structChronusQ_1_1MPI__Comm}{MPI\_Comm}} c, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} b, }
\DoxyCodeLine{1386     std::vector<\mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction}{TwoBodyContraction<double>}}> \&list, \mbox{\hyperlink{structChronusQ_1_1EMPerturbation}{EMPerturbation}} \&pert)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1387     \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}GIAO + Real is an invalid option"{}},std::cout);  }
\DoxyCodeLine{1388   \}}
\DoxyCodeLine{1389 }
\DoxyCodeLine{1390   \textcolor{keyword}{template} <>}
\DoxyCodeLine{1391   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GTODirectTPIContraction}{GTODirectTPIContraction<dcomplex,double>::directScaffold}}(}
\DoxyCodeLine{1392     \mbox{\hyperlink{structChronusQ_1_1MPI__Comm}{MPI\_Comm}} c, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} b, }
\DoxyCodeLine{1393     std::vector<\mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction}{TwoBodyContraction<dcomplex>}}> \&list, \mbox{\hyperlink{structChronusQ_1_1EMPerturbation}{EMPerturbation}} \&pert)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1394     \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}GIAO + Real is an invalid option"{}},std::cout);  }
\DoxyCodeLine{1395   \}}
\DoxyCodeLine{1396 }
\DoxyCodeLine{1397 }
\DoxyCodeLine{1398   \textcolor{comment}{// New Direct Code for 2-\/Particle contraction}}
\DoxyCodeLine{1399   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatsT, \textcolor{keyword}{typename} IntsT>}
\DoxyCodeLine{1400   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GTODirectTPIContraction}{GTODirectTPIContraction<MatsT,IntsT>::directScaffoldNew}}(}
\DoxyCodeLine{1401     \mbox{\hyperlink{structChronusQ_1_1MPI__Comm}{MPI\_Comm}} comm, \textcolor{keyword}{const} \textcolor{keywordtype}{bool} screen,}
\DoxyCodeLine{1402     std::vector<\mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction}{TwoBodyContraction<MatsT>}}> \&matList)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1403 }
\DoxyCodeLine{1404     \textcolor{keywordtype}{size\_t} parentId(0);}
\DoxyCodeLine{1405     \textcolor{keywordtype}{size\_t} callLevel(0);}
\DoxyCodeLine{1406 \textcolor{comment}{//    parentId = ProgramTimer::tick("{}Contract Total"{});}}
\DoxyCodeLine{1407 \textcolor{comment}{//    callLevel = ProgramTimer::getCallLevel();}}
\DoxyCodeLine{1408 }
\DoxyCodeLine{1409     \mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<IntsT>}} \&tpi =}
\DoxyCodeLine{1410         \textcolor{keyword}{dynamic\_cast<}\mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<IntsT>}}\&\textcolor{keyword}{>}(this-\/>ints\_);}
\DoxyCodeLine{1411     \mbox{\hyperlink{classChronusQ_1_1CQMemManager}{CQMemManager}}\& memManager\_ = tpi.\mbox{\hyperlink{classChronusQ_1_1ParticleIntegrals_a4980f581ea843bd4ca6be7ac88064274}{memManager}}();}
\DoxyCodeLine{1412     \mbox{\hyperlink{structChronusQ_1_1BasisSet}{BasisSet}}\& basisSet\_  = this-\/>contractSecond ? tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_ae84f994852fca79387512fcfa6143fa4}{basisSet2}}() : tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a4a476a2dc5e606ee34f0a973b9ddce5c}{basisSet}}();}
\DoxyCodeLine{1413     \mbox{\hyperlink{structChronusQ_1_1BasisSet}{BasisSet}}\& basisSet2\_ = this-\/>contractSecond ? tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a4a476a2dc5e606ee34f0a973b9ddce5c}{basisSet}}()  : tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_ae84f994852fca79387512fcfa6143fa4}{basisSet2}}();}
\DoxyCodeLine{1414 }
\DoxyCodeLine{1415     \textcolor{keywordtype}{size\_t} nThreads  = \mbox{\hyperlink{namespaceChronusQ_a3320ee560c87921c8d84885db82e9917}{GetNumThreads}}();}
\DoxyCodeLine{1416     \textcolor{keywordtype}{size\_t} LAThreads = \mbox{\hyperlink{namespaceChronusQ_a3152808c4819d6cbf8a29aef92728866}{GetLAThreads}}();}
\DoxyCodeLine{1417     \textcolor{keywordtype}{size\_t} mpiRank   = \mbox{\hyperlink{namespaceChronusQ_ac9433164d43ee9f6f0c49e49698f680f}{MPIRank}}(comm);}
\DoxyCodeLine{1418     \textcolor{keywordtype}{size\_t} mpiSize   = \mbox{\hyperlink{namespaceChronusQ_a6ef99d456575a9727c4d7d4eb8149416}{MPISize}}(comm);}
\DoxyCodeLine{1419 }
\DoxyCodeLine{1420     \mbox{\hyperlink{namespaceChronusQ_a7b13ac1d1109f4a015feaab04cb3eaee}{SetLAThreads}}(1); \textcolor{comment}{// Turn off parallelism in LA functions}}
\DoxyCodeLine{1421 }
\DoxyCodeLine{1422     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nBasis   = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a40ad4a89b440bf71e0ef6ba317d8123f}{nBasis}};}
\DoxyCodeLine{1423     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} snBasis  = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a40ad4a89b440bf71e0ef6ba317d8123f}{nBasis}};}
\DoxyCodeLine{1424     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nMat     = matList.size();}
\DoxyCodeLine{1425     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nShell   = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a936871b121472a416ee6f947ccdea4b4}{nShell}};}
\DoxyCodeLine{1426     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} snShell  = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a936871b121472a416ee6f947ccdea4b4}{nShell}};}
\DoxyCodeLine{1427 }
\DoxyCodeLine{1428 }
\DoxyCodeLine{1429     \textcolor{comment}{// Check whether any of the contractions are non-\/hermetian}}
\DoxyCodeLine{1430     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} NonHermitian = std::any\_of(matList.begin(),matList.end(),}
\DoxyCodeLine{1431       []( \mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction}{TwoBodyContraction<MatsT>}} \& x ) -\/> \textcolor{keywordtype}{bool} \{ return not x.HER; \});}
\DoxyCodeLine{1432 }
\DoxyCodeLine{1433 }
\DoxyCodeLine{1434     \textcolor{keywordtype}{bool} sameBasisSet12 = \&basisSet\_ == \&basisSet2\_;}
\DoxyCodeLine{1435 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{1436     \textcolor{comment}{// Compute schwarz bounds if we haven't already}}
\DoxyCodeLine{1437     \textcolor{keywordflow}{if}(tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a5fe8f1b07ffeec39f48faae7987cdfdf}{schwarz}}() == \textcolor{keyword}{nullptr} or tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a275af18feaf98aa8d80136bcaaee29cd}{schwarz2}}() == \textcolor{keyword}{nullptr}) }
\DoxyCodeLine{1438       tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_ac90ba6c59e4593db8986495779bea090}{computeSchwarz}}();}
\DoxyCodeLine{1439 }
\DoxyCodeLine{1440     \textcolor{keywordtype}{double} * schwarz1 = this-\/>contractSecond ? tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a275af18feaf98aa8d80136bcaaee29cd}{schwarz2}}() : tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a5fe8f1b07ffeec39f48faae7987cdfdf}{schwarz}}();}
\DoxyCodeLine{1441     \textcolor{keywordtype}{double} * schwarz2 = this-\/>contractSecond ? tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a5fe8f1b07ffeec39f48faae7987cdfdf}{schwarz}}()  : tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a275af18feaf98aa8d80136bcaaee29cd}{schwarz2}}();}
\DoxyCodeLine{1442 }
\DoxyCodeLine{1443     \textcolor{keywordflow}{if} (sameBasisSet12) schwarz2 = schwarz1;}
\DoxyCodeLine{1444 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1445 }
\DoxyCodeLine{1446 }
\DoxyCodeLine{1447     \textcolor{comment}{// Create thread-\/safe libint2::Engines}}
\DoxyCodeLine{1448     std::vector<libint2::Engine> engines(nThreads);}
\DoxyCodeLine{1449 }
\DoxyCodeLine{1450     \textcolor{comment}{// Construct engine for master thread}}
\DoxyCodeLine{1451     engines[0] = libint2::Engine(libint2::Operator::coulomb,}
\DoxyCodeLine{1452       std::max(basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}}, basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}}), }
\DoxyCodeLine{1453       std::max(basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a90bfe80774a23ae70d381783a1d275ac}{maxL}}, basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a90bfe80774a23ae70d381783a1d275ac}{maxL}}),0);}
\DoxyCodeLine{1454 }
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456     \textcolor{comment}{// Allocate scratch for raw integral batches}}
\DoxyCodeLine{1457     \textcolor{keywordtype}{size\_t} maxShellSize = }
\DoxyCodeLine{1458       std::max\_element(basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.begin(),basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.end(),}
\DoxyCodeLine{1459         [](libint2::Shell \&sh1, libint2::Shell \&sh2) \{}
\DoxyCodeLine{1460           return sh1.size() < sh2.size();}
\DoxyCodeLine{1461         \})-\/>size();}
\DoxyCodeLine{1462 }
\DoxyCodeLine{1463     \textcolor{keywordtype}{size\_t} maxShellSize2 = }
\DoxyCodeLine{1464       std::max\_element(basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.begin(),basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.end(),}
\DoxyCodeLine{1465         [](libint2::Shell \&sh1, libint2::Shell \&sh2) \{}
\DoxyCodeLine{1466           return sh1.size() < sh2.size();}
\DoxyCodeLine{1467         \})-\/>size();}
\DoxyCodeLine{1468 }
\DoxyCodeLine{1469     \textcolor{comment}{// lenIntBuffer is allocated to be able to store EPAI's of the }}
\DoxyCodeLine{1470     \textcolor{comment}{// shell with the highest angular momentum}}
\DoxyCodeLine{1471     \textcolor{keywordtype}{size\_t} lenIntBuffer = }
\DoxyCodeLine{1472       maxShellSize * maxShellSize * maxShellSize2 * maxShellSize2; }
\DoxyCodeLine{1473 }
\DoxyCodeLine{1474     lenIntBuffer *= \textcolor{keyword}{sizeof}(MatsT) / \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double});}
\DoxyCodeLine{1475 }
\DoxyCodeLine{1476     \textcolor{keywordtype}{size\_t} nBuffer = 2;}
\DoxyCodeLine{1477 }
\DoxyCodeLine{1478     \textcolor{keywordtype}{double} * intBuffer = }
\DoxyCodeLine{1479       memManager\_.malloc<\textcolor{keywordtype}{double}>(nBuffer*lenIntBuffer*nThreads);}
\DoxyCodeLine{1480    }
\DoxyCodeLine{1481     \textcolor{keywordtype}{double} *intBuffer2 = intBuffer + nThreads*lenIntBuffer;}
\DoxyCodeLine{1482 }
\DoxyCodeLine{1483 }
\DoxyCodeLine{1484     \textcolor{comment}{// Allocate thread local storage to store integral contractions}}
\DoxyCodeLine{1485     std::vector<std::vector<MatsT*>> AXthreads;}
\DoxyCodeLine{1486     MatsT *AXRaw = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1487     \textcolor{keywordflow}{if}(nThreads != 1) \{}
\DoxyCodeLine{1488       AXRaw = memManager\_.malloc<MatsT>(nThreads*nMat*nBasis*nBasis);    }
\DoxyCodeLine{1489       memset(AXRaw,0,nThreads*nMat*nBasis*nBasis*\textcolor{keyword}{sizeof}(MatsT));}
\DoxyCodeLine{1490     \}}
\DoxyCodeLine{1491 }
\DoxyCodeLine{1492     \textcolor{keywordflow}{if}(nThreads == 1) \{}
\DoxyCodeLine{1493       AXthreads.emplace\_back();}
\DoxyCodeLine{1494       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0; iMat < nMat; iMat++)}
\DoxyCodeLine{1495         AXthreads.back().push\_back(matList[iMat].AX);}
\DoxyCodeLine{1496     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1497       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iThread = 0; iThread < nThreads; iThread++) \{}
\DoxyCodeLine{1498         AXthreads.emplace\_back();}
\DoxyCodeLine{1499         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0; iMat < nMat; iMat++) }
\DoxyCodeLine{1500           AXthreads.back().push\_back(AXRaw + iThread*nMat*nBasis*nBasis + iMat*nBasis*nBasis);}
\DoxyCodeLine{1501       \}}
\DoxyCodeLine{1502     \}}
\DoxyCodeLine{1503 }
\DoxyCodeLine{1504 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{1505     \textcolor{comment}{// Compute shell block norms (∞-\/norm) of matList.X}}
\DoxyCodeLine{1506     \textcolor{comment}{// for all matrix}}
\DoxyCodeLine{1507     \textcolor{keywordtype}{size\_t} nShBlkNormsMat = nMat + (nMat == 1 ? 0: 1);}
\DoxyCodeLine{1508     \textcolor{keywordtype}{double} *ShBlkNorms\_raw = memManager\_.malloc<\textcolor{keywordtype}{double}>(nShBlkNormsMat*snShell*snShell);}
\DoxyCodeLine{1509     \textcolor{keywordtype}{double} *ShBlkNorms = ShBlkNorms\_raw; }
\DoxyCodeLine{1510     std::vector<double*> ShBlkNorms\_Mat(nMat, \textcolor{keyword}{nullptr});}
\DoxyCodeLine{1511     }
\DoxyCodeLine{1512     \textcolor{keywordflow}{if} (NonHermitian and not sameBasisSet12)}
\DoxyCodeLine{1513       \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}EPAI Contraction does not support non-\/Hermitian type."{}});}
\DoxyCodeLine{1514     }
\DoxyCodeLine{1515     \textcolor{keywordtype}{size\_t} ShBlkNorms\_Mat\_Off = nMat == 1 ? 0: 1;}
\DoxyCodeLine{1516     }
\DoxyCodeLine{1517     \textcolor{comment}{// \#pragma omp parallel for }}
\DoxyCodeLine{1518     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0; iMat < nMat; iMat++) \{}
\DoxyCodeLine{1519       }
\DoxyCodeLine{1520       ShBlkNorms\_Mat[iMat] = ShBlkNorms\_raw + (iMat+ShBlkNorms\_Mat\_Off)*snShell*snShell;}
\DoxyCodeLine{1521       }
\DoxyCodeLine{1522       \textcolor{keywordtype}{double} * ShBlkNorms\_i = ShBlkNorms\_Mat[iMat];}
\DoxyCodeLine{1523       }
\DoxyCodeLine{1524       \mbox{\hyperlink{namespaceChronusQ_ac444f26163329af7c951db8e6544c499}{ShellBlockNorm}}(basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}},matList[iMat].X,snBasis,ShBlkNorms\_i);}
\DoxyCodeLine{1525       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0; j < snShell*snShell; j++)}
\DoxyCodeLine{1526         ShBlkNorms\_i[j] = std::abs(ShBlkNorms\_i[j]);}
\DoxyCodeLine{1527 }
\DoxyCodeLine{1528       \textcolor{comment}{// symmetrize nonHermitian ShBlkNorms}}
\DoxyCodeLine{1529       \textcolor{keywordflow}{if} (not matList[iMat].HER) \{}
\DoxyCodeLine{1530         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0; k < nShell; k++)}
\DoxyCodeLine{1531         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0; l < k;      l++) \{}
\DoxyCodeLine{1532           \textcolor{keywordtype}{double} mx = std::max(ShBlkNorms\_i[k + l*nShell],}
\DoxyCodeLine{1533                                ShBlkNorms\_i[l + k*nShell]);}
\DoxyCodeLine{1534           ShBlkNorms\_i[k + l*nShell] = mx;}
\DoxyCodeLine{1535           ShBlkNorms\_i[l + k*nShell] = mx;}
\DoxyCodeLine{1536         \}}
\DoxyCodeLine{1537       \}}
\DoxyCodeLine{1538     \}}
\DoxyCodeLine{1539     }
\DoxyCodeLine{1540     \textcolor{comment}{// Get the max over all the matricies for the shell block ∞-\/norms}}
\DoxyCodeLine{1541     \textcolor{keywordflow}{if} (nMat != 1) \{ }
\DoxyCodeLine{1542       memset(ShBlkNorms,0.,snShell*snShell*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double}));}
\DoxyCodeLine{1543 \textcolor{preprocessor}{      \#pragma omp parallel for }}
\DoxyCodeLine{1544       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0; i < snShell*snShell; i++) }
\DoxyCodeLine{1545       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0; iMat < nMat; iMat++)}
\DoxyCodeLine{1546         ShBlkNorms[i] = std::max(ShBlkNorms[i], ShBlkNorms\_Mat[iMat][i]);}
\DoxyCodeLine{1547     \}}
\DoxyCodeLine{1548     }
\DoxyCodeLine{1549     \textcolor{comment}{// Find the max value of shell block ∞-\/norms of all matList.X}}
\DoxyCodeLine{1550     \textcolor{keywordtype}{double} maxShBlkNorm = *std::max\_element(ShBlkNorms, ShBlkNorms + snShell*snShell);}
\DoxyCodeLine{1551 }
\DoxyCodeLine{1552     \textcolor{keywordtype}{size\_t} maxnPrim4 = }
\DoxyCodeLine{1553       basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}} * basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}} * basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}} * }
\DoxyCodeLine{1554       basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}};}
\DoxyCodeLine{1555 }
\DoxyCodeLine{1556     \textcolor{comment}{// Set Libint precision}}
\DoxyCodeLine{1557 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{1558     engines[0].set\_precision(}
\DoxyCodeLine{1559       std::min(}
\DoxyCodeLine{1560         std::numeric\_limits<double>::epsilon(),}
\DoxyCodeLine{1561         threshSchwarz/maxShBlkNorm}
\DoxyCodeLine{1562       )/maxnPrim4}
\DoxyCodeLine{1563     );}
\DoxyCodeLine{1564 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1565     engines[0].set\_precision(}
\DoxyCodeLine{1566       std::max(}
\DoxyCodeLine{1567         std::numeric\_limits<double>::epsilon(),}
\DoxyCodeLine{1568         tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a51ce753ee588706401406d4216c1ba74}{threshSchwarz}}()/(maxShBlkNorm*maxnPrim4))}
\DoxyCodeLine{1569       );}
\DoxyCodeLine{1570 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1571 }
\DoxyCodeLine{1572 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1573     \textcolor{comment}{// Set Linbint precision}}
\DoxyCodeLine{1574     engines[0].set\_precision(std::numeric\_limits<double>::epsilon());}
\DoxyCodeLine{1575 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1576 }
\DoxyCodeLine{1577     \textcolor{comment}{// Copy master thread engine to other threads}}
\DoxyCodeLine{1578     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 1; i < nThreads; i++) engines[i] = engines[0];}
\DoxyCodeLine{1579 }
\DoxyCodeLine{1580 \textcolor{preprocessor}{\#ifdef \_SUB\_TIMINGS}}
\DoxyCodeLine{1581     std::chrono::duration<double> durInner(0.), durCont(0.), durSymm(0.), durZero(0.);}
\DoxyCodeLine{1582 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1583 }
\DoxyCodeLine{1584     \textcolor{comment}{// Keeping track of number of integrals and contration skipped}}
\DoxyCodeLine{1585     std::vector<size\_t> nIntSkip(nThreads,0);}
\DoxyCodeLine{1586 \textcolor{preprocessor}{\#ifdef \_SEPARATED\_SHZ\_SCREEN    }}
\DoxyCodeLine{1587     std::vector<size\_t> nConSkip(nThreads,0);}
\DoxyCodeLine{1588 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1589     \textcolor{comment}{// MPI info}}
\DoxyCodeLine{1590     \textcolor{keywordtype}{size\_t} mpiChunks = (snShell * (snShell + 1) / 2) / mpiSize;}
\DoxyCodeLine{1591     \textcolor{keywordtype}{size\_t} mpiS12St  = mpiRank * mpiChunks;}
\DoxyCodeLine{1592     \textcolor{keywordtype}{size\_t} mpiS12End = (mpiRank + 1) * mpiChunks;}
\DoxyCodeLine{1593     \textcolor{keywordflow}{if}( mpiRank == (mpiSize -\/ 1) ) mpiS12End = (snShell * (snShell + 1) / 2);}
\DoxyCodeLine{1594 }
\DoxyCodeLine{1595     \textcolor{keyword}{auto} topDirect = \mbox{\hyperlink{namespaceChronusQ_a715f671201f0f6e77216fcf1f72adbaf}{tick}}();}
\DoxyCodeLine{1596     }
\DoxyCodeLine{1597 \textcolor{preprocessor}{    \#pragma omp parallel}}
\DoxyCodeLine{1598     \{}
\DoxyCodeLine{1599 }
\DoxyCodeLine{1600 \textcolor{comment}{//    ProgramTimer::setContext(parentId, callLevel);}}
\DoxyCodeLine{1601 }
\DoxyCodeLine{1602     \textcolor{comment}{// Set up thread local storage}}
\DoxyCodeLine{1603 }
\DoxyCodeLine{1604     \textcolor{comment}{// SMP info}}
\DoxyCodeLine{1605     \textcolor{keywordtype}{size\_t} thread\_id = \mbox{\hyperlink{namespaceChronusQ_aa348a017ee78c3450480773ddc542e5c}{GetThreadID}}();}
\DoxyCodeLine{1606 }
\DoxyCodeLine{1607     \textcolor{keyword}{auto} \&engine = engines[thread\_id];}
\DoxyCodeLine{1608     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& buf\_vec = engine.results();}
\DoxyCodeLine{1609     }
\DoxyCodeLine{1610     \textcolor{keyword}{auto} \&AX\_loc = AXthreads[thread\_id];}
\DoxyCodeLine{1611 }
\DoxyCodeLine{1612     \textcolor{keywordtype}{double} * intBuffer\_loc  = intBuffer  + thread\_id*lenIntBuffer;}
\DoxyCodeLine{1613     \textcolor{keywordtype}{double} * intBuffer2\_loc = intBuffer2 + thread\_id*lenIntBuffer;}
\DoxyCodeLine{1614 }
\DoxyCodeLine{1615     \textcolor{keywordtype}{size\_t} n1,n2;}
\DoxyCodeLine{1616     }
\DoxyCodeLine{1617     std::vector<size\_t> contract\_Mat(nMat);}
\DoxyCodeLine{1618     \textcolor{keywordtype}{size\_t} iCon, nCon;}
\DoxyCodeLine{1619 }
\DoxyCodeLine{1620 \textcolor{preprocessor}{\#if defined(\_SHZ\_SCREEN) \&\& defined(\_SEPARATED\_SHZ\_SCREEN)}}
\DoxyCodeLine{1621     std::vector<double> shMax123\_Mat(nMat);}
\DoxyCodeLine{1622     \textcolor{keywordflow}{if} (nMat == 1) \{}
\DoxyCodeLine{1623       contract\_Mat[0] = 0;}
\DoxyCodeLine{1624       nCon = 1;}
\DoxyCodeLine{1625     \}}
\DoxyCodeLine{1626 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1627     std::iota(contract\_Mat.begin(), contract\_Mat.end(), 0);}
\DoxyCodeLine{1628     nCon = nMat;}
\DoxyCodeLine{1629 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1630 }
\DoxyCodeLine{1631     \textcolor{comment}{// Always Loop over s2 <= s1}}
\DoxyCodeLine{1632     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} s1(0ul), bf1\_s(0ul), s12(0ul); s1 < nShell; bf1\_s+=n1, s1++) \{ }
\DoxyCodeLine{1633       n1 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1].size(); \textcolor{comment}{// Size of Shell 1}}
\DoxyCodeLine{1634 }
\DoxyCodeLine{1635     \textcolor{keyword}{auto} sigPair12\_it = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a9ce9c1c8374ab7f969f8fbf661fcd9ac}{shData}}.at(s1).begin();}
\DoxyCodeLine{1636     \textcolor{keywordflow}{for}( \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t}\& s2 : basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a6ec4c9f444b6971af4f7d8a0f833af53}{sigShellPair}}[s1] ) \{}
\DoxyCodeLine{1637       \textcolor{keywordtype}{size\_t} bf2\_s = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a85f991b14d3877ba9dd6d5f3568ce2cc}{mapSh2Bf}}[s2];}
\DoxyCodeLine{1638       n2 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2].size(); \textcolor{comment}{// Size of Shell 2}}
\DoxyCodeLine{1639 }
\DoxyCodeLine{1640       \textcolor{keyword}{const} \textcolor{keyword}{auto} * sigPair12 = sigPair12\_it-\/>get();}
\DoxyCodeLine{1641       sigPair12\_it++;}
\DoxyCodeLine{1642 }
\DoxyCodeLine{1643 \textcolor{preprocessor}{\#ifdef CQ\_ENABLE\_MPI}}
\DoxyCodeLine{1644       \textcolor{comment}{// MPI partition s12 blocks}}
\DoxyCodeLine{1645       \textcolor{keywordflow}{if}( (s12 < mpiS12St) or (s12 >= mpiS12End) ) \{ s12++; \textcolor{keywordflow}{continue}; \}}
\DoxyCodeLine{1646 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1647 }
\DoxyCodeLine{1648       \textcolor{comment}{// Round-\/Robin work distribution}}
\DoxyCodeLine{1649       \textcolor{keywordflow}{if}( (s12++) \% nThreads != thread\_id ) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{1650 }
\DoxyCodeLine{1651       \textcolor{comment}{// Cache variables for shells 1 and 2}}
\DoxyCodeLine{1652         }
\DoxyCodeLine{1653 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{1654       \textcolor{comment}{// Deneneracy factor for s1,s2 pair}}
\DoxyCodeLine{1655       \textcolor{keywordtype}{double} s12\_deg = (s1 == s2) ? 1.0 : 2.0;}
\DoxyCodeLine{1656 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1657 }
\DoxyCodeLine{1658 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{1659       \textcolor{keywordtype}{double} shz12 = 0, shMax12 = 0;}
\DoxyCodeLine{1660       \textcolor{keywordflow}{if}( screen ) \{}
\DoxyCodeLine{1661         shz12 = schwarz1[s1 + s2*nShell];}
\DoxyCodeLine{1662         shMax12 = ShBlkNorms[s1 + s2*nShell];}
\DoxyCodeLine{1663       \}}
\DoxyCodeLine{1664 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1665 }
\DoxyCodeLine{1666 \textcolor{comment}{// The upper bound of s3 is s1 for the 8-\/fold symmetry and}}
\DoxyCodeLine{1667 \textcolor{comment}{// nShell for 4-\/fold.}}
\DoxyCodeLine{1668 \textcolor{preprocessor}{\#ifdef \_USE\_EIGHT\_FOLD}}
\DoxyCodeLine{1669 \textcolor{preprocessor}{  \#define S3\_MAX s1}}
\DoxyCodeLine{1670 \textcolor{preprocessor}{\#elif defined(\_USE\_FOUR\_FOLD)}}
\DoxyCodeLine{1671   \textcolor{comment}{// the "{}-\/"{} is for the <= in the loop}}
\DoxyCodeLine{1672 \textcolor{preprocessor}{  \#define S3\_MAX nShell -\/ 1}}
\DoxyCodeLine{1673 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1674 }
\DoxyCodeLine{1675       \textcolor{keywordtype}{size\_t} n3,n4;}
\DoxyCodeLine{1676       \textcolor{keywordtype}{size\_t} s3\_max = (\&basisSet\_ == \&basisSet2\_) ? \mbox{\hyperlink{contract_2direct_8hpp_ac708ebfb62ad4528bedaeffbe28a3e06}{S3\_MAX}} : snShell -\/ 1;}
\DoxyCodeLine{1677 }
\DoxyCodeLine{1678       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} s3(0ul), bf3\_s(0ul), s34(0ul); s3 <= s3\_max; s3++, bf3\_s += n3) \{ }
\DoxyCodeLine{1679         n3 = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3].size(); \textcolor{comment}{// Size of Shell 3}}
\DoxyCodeLine{1680 }
\DoxyCodeLine{1681 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{1682 }
\DoxyCodeLine{1683         \textcolor{keywordtype}{double} shMax123 = 0;}
\DoxyCodeLine{1684         \textcolor{keywordflow}{if}( screen and sameBasisSet12 ) \{}
\DoxyCodeLine{1685           \textcolor{comment}{// Pre-\/calculate shell-\/block norm max's that only}}
\DoxyCodeLine{1686           \textcolor{comment}{// depend on shells 1,2 and 3}}
\DoxyCodeLine{1687           shMax123 = }
\DoxyCodeLine{1688             std::max(ShBlkNorms[s1 + s3*nShell], }
\DoxyCodeLine{1689                      ShBlkNorms[s2 + s3*nShell]);}
\DoxyCodeLine{1690 }
\DoxyCodeLine{1691           shMax123 = std::max(shMax123,shMax12);}
\DoxyCodeLine{1692 \textcolor{preprocessor}{\#ifdef \_SEPARATED\_SHZ\_SCREEN          }}
\DoxyCodeLine{1693           \textcolor{keywordflow}{if} (nMat != 1)}
\DoxyCodeLine{1694           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} iMat = 0; iMat < nMat; iMat++)}
\DoxyCodeLine{1695             shMax123\_Mat[iMat] = }
\DoxyCodeLine{1696               std::max(ShBlkNorms\_Mat[iMat][s1 + s2*nShell],}
\DoxyCodeLine{1697               std::max(ShBlkNorms\_Mat[iMat][s1 + s3*nShell],}
\DoxyCodeLine{1698                        ShBlkNorms\_Mat[iMat][s2 + s3*nShell]));}
\DoxyCodeLine{1699 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1700         \}}
\DoxyCodeLine{1701 }
\DoxyCodeLine{1702 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1703 }
\DoxyCodeLine{1704 \textcolor{comment}{// The upper bound of s4 is either s2 or s3 based on s1 and s3 for}}
\DoxyCodeLine{1705 \textcolor{comment}{// the 8-\/fold symmetry and s3 for the 4-\/fold symmetry}}
\DoxyCodeLine{1706 \textcolor{preprocessor}{\#ifdef \_USE\_EIGHT\_FOLD}}
\DoxyCodeLine{1707         \textcolor{keywordtype}{size\_t} s4\_max = (s1 == s3) ? s2 : s3;}
\DoxyCodeLine{1708 \textcolor{preprocessor}{\#elif defined(\_USE\_FOUR\_FOLD)}}
\DoxyCodeLine{1709         \textcolor{keywordtype}{size\_t} s4\_max =  s3;}
\DoxyCodeLine{1710 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1711 }
\DoxyCodeLine{1712       \textcolor{keywordflow}{if} (\&basisSet\_ != \&basisSet2\_)}
\DoxyCodeLine{1713         s4\_max =  s3;}
\DoxyCodeLine{1714 }
\DoxyCodeLine{1715       \textcolor{keyword}{auto} sigPair34\_it = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a9ce9c1c8374ab7f969f8fbf661fcd9ac}{shData}}.at(s3).begin();}
\DoxyCodeLine{1716       \textcolor{keywordflow}{for}( \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t}\& s4 : basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a6ec4c9f444b6971af4f7d8a0f833af53}{sigShellPair}}[s3] ) \{}
\DoxyCodeLine{1717 }
\DoxyCodeLine{1718         \textcolor{keywordflow}{if} (s4 > s4\_max)}
\DoxyCodeLine{1719           \textcolor{keywordflow}{break};  \textcolor{comment}{// for each s3, s4 are stored in monotonically increasing}}
\DoxyCodeLine{1720                   \textcolor{comment}{// order}}
\DoxyCodeLine{1721 }
\DoxyCodeLine{1722         \textcolor{keyword}{const} \textcolor{keyword}{auto} * sigPair34 = sigPair34\_it-\/>get();}
\DoxyCodeLine{1723         sigPair34\_it++;}
\DoxyCodeLine{1724                     }
\DoxyCodeLine{1725         \textcolor{keywordtype}{size\_t} bf4\_s = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a85f991b14d3877ba9dd6d5f3568ce2cc}{mapSh2Bf}}[s4];}
\DoxyCodeLine{1726         n4 = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4].size(); \textcolor{comment}{// Size of Shell 4}}
\DoxyCodeLine{1727 }
\DoxyCodeLine{1728 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{1729 }
\DoxyCodeLine{1730         \textcolor{keywordtype}{double} shMax = 0;}
\DoxyCodeLine{1731 }
\DoxyCodeLine{1732         \textcolor{keywordflow}{if}( screen ) \{}
\DoxyCodeLine{1733           \textcolor{comment}{// Compute Shell norm max}}
\DoxyCodeLine{1734           shMax = ShBlkNorms[s3 + s4*snShell];}
\DoxyCodeLine{1735           }
\DoxyCodeLine{1736           \textcolor{keywordflow}{if} (sameBasisSet12) \{}
\DoxyCodeLine{1737             shMax = std::max(shMax,}
\DoxyCodeLine{1738                       std::max(ShBlkNorms[s1 + s4*nShell],}
\DoxyCodeLine{1739                                ShBlkNorms[s2 + s4*nShell]));}
\DoxyCodeLine{1740             shMax = std::max(shMax,shMax123);}
\DoxyCodeLine{1741           \}}
\DoxyCodeLine{1742           }
\DoxyCodeLine{1743           \textcolor{comment}{// for same basissets, schwarz2 has been changed to schwarz1}}
\DoxyCodeLine{1744           \textcolor{keywordflow}{if}((shMax * shz12 * schwarz2[s3 + s4*snShell]) <}
\DoxyCodeLine{1745              tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a51ce753ee588706401406d4216c1ba74}{threshSchwarz}}()) \{ }
\DoxyCodeLine{1746             nIntSkip[thread\_id]++; }
\DoxyCodeLine{1747 \textcolor{preprocessor}{\#ifdef \_SEPARATED\_SHZ\_SCREEN}}
\DoxyCodeLine{1748             nConSkip[thread\_id] += nMat;}
\DoxyCodeLine{1749 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1750             \textcolor{keywordflow}{continue}; }
\DoxyCodeLine{1751           \}}
\DoxyCodeLine{1752 }
\DoxyCodeLine{1753 \textcolor{preprocessor}{\#ifdef \_SEPARATED\_SHZ\_SCREEN}}
\DoxyCodeLine{1754           \textcolor{keywordflow}{if} (nMat != 1) \{}
\DoxyCodeLine{1755             nCon = 0;}
\DoxyCodeLine{1756             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} iMat = 0ul; iMat < nMat; iMat++) \{}
\DoxyCodeLine{1757               shMax = ShBlkNorms\_Mat[iMat][s3 + s4*snShell]; }
\DoxyCodeLine{1758               \textcolor{keywordflow}{if} (sameBasisSet12) \{}
\DoxyCodeLine{1759                 shMax = std::max(shMax, }
\DoxyCodeLine{1760                           std::max(ShBlkNorms\_Mat[iMat][s1 + s4*nShell],}
\DoxyCodeLine{1761                                    ShBlkNorms\_Mat[iMat][s2 + s4*nShell]));}
\DoxyCodeLine{1762                 shMax = std::max(shMax,shMax123\_Mat[iMat]);}
\DoxyCodeLine{1763               \} }
\DoxyCodeLine{1764               }
\DoxyCodeLine{1765               \textcolor{comment}{// for same basissets, schwarz2 has been changed to schwarz1}}
\DoxyCodeLine{1766               \textcolor{keywordflow}{if}((shMax * shz12 * schwarz2[s3 + s4*snShell]) <}
\DoxyCodeLine{1767                  tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a51ce753ee588706401406d4216c1ba74}{threshSchwarz}}()) \{ }
\DoxyCodeLine{1768                  nConSkip[thread\_id]++; }
\DoxyCodeLine{1769               \} \textcolor{keywordflow}{else} \{   }
\DoxyCodeLine{1770                  contract\_Mat[nCon] = iMat;}
\DoxyCodeLine{1771                  nCon++; }
\DoxyCodeLine{1772               \}}
\DoxyCodeLine{1773             \}}
\DoxyCodeLine{1774           \}}
\DoxyCodeLine{1775 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1776         \}}
\DoxyCodeLine{1777       }
\DoxyCodeLine{1778 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1779 }
\DoxyCodeLine{1780 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{1781 }
\DoxyCodeLine{1782         \textcolor{comment}{// Degeneracy factor for s3,s4 pair}}
\DoxyCodeLine{1783         \textcolor{keywordtype}{double} s34\_deg = (s3 == s4) ? 1.0 : 2.0;}
\DoxyCodeLine{1784 }
\DoxyCodeLine{1785         \textcolor{comment}{// Degeneracy factor for s1, s2, s3, s4 quartet}}
\DoxyCodeLine{1786         \textcolor{keywordtype}{double} s12\_34\_deg = 2.0;}
\DoxyCodeLine{1787         \textcolor{keywordflow}{if} (\&basisSet\_ == \&basisSet2\_)}
\DoxyCodeLine{1788           s12\_34\_deg = (s1 == s3) ? (s2 == s4 ? 1.0 : 2.0) : 2.0;}
\DoxyCodeLine{1789 }
\DoxyCodeLine{1790         \textcolor{comment}{// Total degeneracy factor}}
\DoxyCodeLine{1791         \textcolor{keywordtype}{double} s1234\_deg = s12\_deg * s34\_deg * s12\_34\_deg;}
\DoxyCodeLine{1792 }
\DoxyCodeLine{1793 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1794 \textcolor{preprocessor}{\#ifdef \_REPORT\_INTEGRAL\_TIMINGS}}
\DoxyCodeLine{1795 \textcolor{comment}{//        ProgramTimer::tick("{}Direct Int Form"{});}}
\DoxyCodeLine{1796 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1797 }
\DoxyCodeLine{1798 \textcolor{preprocessor}{\#if 1}}
\DoxyCodeLine{1799         \textcolor{comment}{// Evaluate ERI for shell quartet (s1 s2 | s3 s4)}}
\DoxyCodeLine{1800         engine.compute2<}
\DoxyCodeLine{1801           libint2::Operator::coulomb, libint2::BraKet::xx\_xx, 0>(}
\DoxyCodeLine{1802           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1],}
\DoxyCodeLine{1803           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2],}
\DoxyCodeLine{1804           basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3],}
\DoxyCodeLine{1805           basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4]}
\DoxyCodeLine{1806 \textcolor{preprocessor}{\#ifdef \_PRECOMPUTE\_SHELL\_PAIRS}}
\DoxyCodeLine{1807           ,sigPair12,sigPair34}
\DoxyCodeLine{1808 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1809         );}
\DoxyCodeLine{1810 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1811 \textcolor{preprocessor}{\#ifdef \_REPORT\_INTEGRAL\_TIMINGS}}
\DoxyCodeLine{1812 \textcolor{comment}{//        ProgramTimer::tock("{}Direct Int Form"{});}}
\DoxyCodeLine{1813 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1814 }
\DoxyCodeLine{1815         \textcolor{comment}{// Libint2 internal screening}}
\DoxyCodeLine{1816         \textcolor{keyword}{const} \textcolor{keywordtype}{double} *buff = buf\_vec[0];}
\DoxyCodeLine{1817 }
\DoxyCodeLine{1818         \textcolor{keywordflow}{if}(buff == \textcolor{keyword}{nullptr}) \{ }
\DoxyCodeLine{1819           nIntSkip[thread\_id]++; }
\DoxyCodeLine{1820           }
\DoxyCodeLine{1821 \textcolor{preprocessor}{\#ifdef \_SEPARATED\_SHZ\_SCREEN}}
\DoxyCodeLine{1822           nConSkip[thread\_id] += nCon;}
\DoxyCodeLine{1823 \textcolor{preprocessor}{\#endif          }}
\DoxyCodeLine{1824           \textcolor{keywordflow}{continue}; }
\DoxyCodeLine{1825         \}}
\DoxyCodeLine{1826 }
\DoxyCodeLine{1827 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{1828 }
\DoxyCodeLine{1829 \textcolor{comment}{// Flag to turn contraction on and off}}
\DoxyCodeLine{1830 \textcolor{preprocessor}{\#if 1}}
\DoxyCodeLine{1831 }
\DoxyCodeLine{1832 \textcolor{preprocessor}{\#ifdef \_REPORT\_INTEGRAL\_TIMINGS}}
\DoxyCodeLine{1833 \textcolor{comment}{//        ProgramTimer::tick("{}Direct Den Contract"{});}}
\DoxyCodeLine{1834 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1835 }
\DoxyCodeLine{1836         \textcolor{comment}{// Scale the buffer by the degeneracy factor and store}}
\DoxyCodeLine{1837         \textcolor{comment}{// in infBuffer}}
\DoxyCodeLine{1838         std::transform(buff,buff + n1*n2*n3*n4,intBuffer\_loc,}
\DoxyCodeLine{1839           [\&](\textcolor{keyword}{auto}\& x) \{ \textcolor{keywordflow}{return} x*0.5*s1234\_deg; \});}
\DoxyCodeLine{1840 }
\DoxyCodeLine{1841         \textcolor{keywordtype}{size\_t} b1,b2,b3,b4;}
\DoxyCodeLine{1842         \textcolor{keywordtype}{double} *Xp1, *Xp2;}
\DoxyCodeLine{1843         \textcolor{keywordtype}{double} X1,X2;}
\DoxyCodeLine{1844         MatsT      T1,T2,T3,T4;}
\DoxyCodeLine{1845         MatsT      *Tp1,*Tp2;}
\DoxyCodeLine{1846 }
\DoxyCodeLine{1847         \textcolor{keywordflow}{for}(iCon = 0; iCon < nCon; iCon++) \{}
\DoxyCodeLine{1848           }
\DoxyCodeLine{1849           \textcolor{keyword}{auto} iMat = contract\_Mat[iCon]; }
\DoxyCodeLine{1850           }
\DoxyCodeLine{1851           \textcolor{comment}{// Hermetian contraction}}
\DoxyCodeLine{1852           \textcolor{keywordflow}{if} ( matList[iMat].HER ) \{}
\DoxyCodeLine{1853             \textcolor{keywordflow}{if}( matList[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} )}
\DoxyCodeLine{1854             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{1855             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++) \{ }
\DoxyCodeLine{1856               \textcolor{comment}{// Cache i,j variables}}
\DoxyCodeLine{1857               b1 = bf1 + nBasis*bf2; }
\DoxyCodeLine{1858               X1 = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(matList[iMat].X  + b1);}
\DoxyCodeLine{1859               Xp1 = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(AX\_loc[iMat] + b1);}
\DoxyCodeLine{1860             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) }
\DoxyCodeLine{1861             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{1862 }
\DoxyCodeLine{1863               \textcolor{comment}{// J(1,2) += I * X(4,3)}}
\DoxyCodeLine{1864               *Xp1 += *\mbox{\hyperlink{contract_2direct_8hpp_aeabcb643c83e6a65cf0f72831edd377d}{GetRealPtr}}(matList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}},bf4,bf3,snBasis) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1865 }
\DoxyCodeLine{1866               \textcolor{keywordflow}{if} (\&basisSet\_ == \&basisSet2\_)}
\DoxyCodeLine{1867                 *\mbox{\hyperlink{contract_2direct_8hpp_aeabcb643c83e6a65cf0f72831edd377d}{GetRealPtr}}(AX\_loc[iMat],bf4,bf3,nBasis) += X1 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1868 }
\DoxyCodeLine{1869               \textcolor{comment}{// J(2,1) and J(3,4) are handled on symmetrization after}}
\DoxyCodeLine{1870               \textcolor{comment}{// contraction}}
\DoxyCodeLine{1871             \} \textcolor{comment}{// kl loop}}
\DoxyCodeLine{1872             \} \textcolor{comment}{// ij loop}}
\DoxyCodeLine{1873 }
\DoxyCodeLine{1874             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( matList[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} ) \{}
\DoxyCodeLine{1875               \textcolor{keywordflow}{if} (\&basisSet\_ != \&basisSet2\_)}
\DoxyCodeLine{1876                 \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}No exchange contraction between two different basis!"{}}, std::cout);}
\DoxyCodeLine{1877 }
\DoxyCodeLine{1878               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{1879               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++)       }
\DoxyCodeLine{1880               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) \{}
\DoxyCodeLine{1881 }
\DoxyCodeLine{1882                 \textcolor{comment}{// Cache i,j,k variables}}
\DoxyCodeLine{1883                 b1 = bf1 + bf3*nBasis;}
\DoxyCodeLine{1884                 b2 = bf2 + bf3*nBasis;}
\DoxyCodeLine{1885 }
\DoxyCodeLine{1886                 T1 = 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(matList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}}[b1]);}
\DoxyCodeLine{1887                 T2 = 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(matList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}}[b2]);}
\DoxyCodeLine{1888 }
\DoxyCodeLine{1889               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{1890 }
\DoxyCodeLine{1891                 \textcolor{comment}{// Indicies are swapped here to loop over contiguous memory}}
\DoxyCodeLine{1892                   }
\DoxyCodeLine{1893                 \textcolor{comment}{// K(1,3) += 0.5 * I * X(2,4) = 0.5 * I * CONJ(X(4,2)) (**HER**)}}
\DoxyCodeLine{1894                 AX\_loc[iMat][b1]           += 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(matList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}}[bf4+nBasis*bf2]) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1895 }
\DoxyCodeLine{1896                 \textcolor{comment}{// K(4,2) += 0.5 * I * X(3,1) = 0.5 * I * CONJ(X(1,3)) (**HER**)}}
\DoxyCodeLine{1897                 AX\_loc[iMat][bf4 + bf2*nBasis] += T1 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1898 }
\DoxyCodeLine{1899                 \textcolor{comment}{// K(4,1) += 0.5 * I * X(3,2) = 0.5 * I * CONJ(X(2,3)) (**HER**)}}
\DoxyCodeLine{1900                 AX\_loc[iMat][bf4 + bf1*nBasis] += T2 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1901 }
\DoxyCodeLine{1902                 \textcolor{comment}{// K(2,3) += 0.5 * I * X(1,4) = 0.5 * I * CONJ(X(4,1)) (**HER**)}}
\DoxyCodeLine{1903                 AX\_loc[iMat][b2]           += 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(matList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}}[bf4+nBasis*bf1]) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1904 }
\DoxyCodeLine{1905               \} \textcolor{comment}{// l loop}}
\DoxyCodeLine{1906               \} \textcolor{comment}{// ijk}}
\DoxyCodeLine{1907             \}}
\DoxyCodeLine{1908           \textcolor{comment}{// Nonhermetian contraction}}
\DoxyCodeLine{1909           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1910 }
\DoxyCodeLine{1911             \textcolor{keywordflow}{if} (\&basisSet\_ != \&basisSet2\_)}
\DoxyCodeLine{1912               \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}No non-\/Hermitian contraction between two different basis!"{}}, std::cout);}
\DoxyCodeLine{1913 }
\DoxyCodeLine{1914             \textcolor{keywordflow}{if}( matList[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} )}
\DoxyCodeLine{1915             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{1916             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++) \{ }
\DoxyCodeLine{1917               \textcolor{comment}{// Cache i,j variables}}
\DoxyCodeLine{1918               b1 = bf1 + nBasis*bf2; }
\DoxyCodeLine{1919               T1 = *(matList[iMat].X  + b1);}
\DoxyCodeLine{1920               Tp1 = (AX\_loc[iMat] + b1);}
\DoxyCodeLine{1921 }
\DoxyCodeLine{1922               b2 = bf2 + nBasis*bf1; }
\DoxyCodeLine{1923               T2 = *(matList[iMat].X  + b2);}
\DoxyCodeLine{1924               Tp2 = (AX\_loc[iMat] + b2);}
\DoxyCodeLine{1925             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) }
\DoxyCodeLine{1926             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{1927 }
\DoxyCodeLine{1928               \textcolor{comment}{// J(1,2) += I * X(4,3)}}
\DoxyCodeLine{1929               *Tp1 += 0.5*( matList[iMat].X[bf4 + bf3*nBasis] + matList[iMat].X[bf3 + bf4*nBasis]) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1930 }
\DoxyCodeLine{1931               \textcolor{comment}{// J(3,4) += I * X(2,1)}}
\DoxyCodeLine{1932               AX\_loc[iMat][bf3 + bf4*nBasis] +=  0.5*(T2+T1) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1933 }
\DoxyCodeLine{1934               \textcolor{comment}{// J(2,1) += I * X(3,4)}}
\DoxyCodeLine{1935               *Tp2 += 0.5*( matList[iMat].X[bf4 + bf3*nBasis] + matList[iMat].X[bf3 + bf4*nBasis]) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1936 }
\DoxyCodeLine{1937               \textcolor{comment}{// J(4,3) += I * X(1,2)}}
\DoxyCodeLine{1938               AX\_loc[iMat][bf4 + bf3*nBasis] +=  0.5*(T2+T1) * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1939 }
\DoxyCodeLine{1940             \} \textcolor{comment}{// kl loop}}
\DoxyCodeLine{1941             \} \textcolor{comment}{// ij loop}}
\DoxyCodeLine{1942 }
\DoxyCodeLine{1943             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( matList[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} )}
\DoxyCodeLine{1944             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{1945             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++)       }
\DoxyCodeLine{1946             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) \{}
\DoxyCodeLine{1947 }
\DoxyCodeLine{1948               \textcolor{comment}{// Cache i,j,k variables}}
\DoxyCodeLine{1949               b1 = bf1 + bf3*nBasis;}
\DoxyCodeLine{1950               b2 = bf2 + bf3*nBasis;}
\DoxyCodeLine{1951 }
\DoxyCodeLine{1952               T1 = 0.5 * matList[iMat].X[b1];}
\DoxyCodeLine{1953               T2 = 0.5 * matList[iMat].X[b2];}
\DoxyCodeLine{1954 }
\DoxyCodeLine{1955               b3 = bf3 + bf1*nBasis;}
\DoxyCodeLine{1956               b4 = bf3 + bf2*nBasis;}
\DoxyCodeLine{1957 }
\DoxyCodeLine{1958               T3 = 0.5 * matList[iMat].X[b3];}
\DoxyCodeLine{1959               T4 = 0.5 * matList[iMat].X[b4];}
\DoxyCodeLine{1960             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{1961 }
\DoxyCodeLine{1962               \textcolor{comment}{// K(3,1) += 0.5 * I * X(4,2)}}
\DoxyCodeLine{1963               AX\_loc[iMat][b3]           += 0.5 * matList[iMat].X[bf4+nBasis*bf2] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1964 }
\DoxyCodeLine{1965               \textcolor{comment}{// K(4,2) += 0.5 * I * X(3,1)}}
\DoxyCodeLine{1966               AX\_loc[iMat][bf4 + bf2*nBasis] += T3 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1967  }
\DoxyCodeLine{1968               \textcolor{comment}{// K(4,1) += 0.5 * I * X(3,2)}}
\DoxyCodeLine{1969               AX\_loc[iMat][bf4 + bf1*nBasis] += T4 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1970 }
\DoxyCodeLine{1971               \textcolor{comment}{// K(3,2) += 0.5 * I * X(4,1)}}
\DoxyCodeLine{1972               AX\_loc[iMat][b4]           += 0.5 * matList[iMat].X[bf4+nBasis*bf1] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1973 }
\DoxyCodeLine{1974               \textcolor{comment}{// K(1,3) += 0.5 * I * X(2,4)}}
\DoxyCodeLine{1975               AX\_loc[iMat][b1]           += 0.5 * matList[iMat].X[bf2+nBasis*bf4] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1976 }
\DoxyCodeLine{1977               \textcolor{comment}{// K(2,4) += 0.5 * I * X(1,3)}}
\DoxyCodeLine{1978               AX\_loc[iMat][bf2 + bf4*nBasis] += T1 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1979  }
\DoxyCodeLine{1980               \textcolor{comment}{// K(1,4) += 0.5 * I * X(2,3)}}
\DoxyCodeLine{1981               AX\_loc[iMat][bf1 + bf4*nBasis] += T2 * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1982 }
\DoxyCodeLine{1983               \textcolor{comment}{// K(2,3) += 0.5 * I * X(1,4)}}
\DoxyCodeLine{1984               AX\_loc[iMat][b2]           += 0.5 * matList[iMat].X[bf1+nBasis*bf4] * intBuffer\_loc[ijkl];}
\DoxyCodeLine{1985 }
\DoxyCodeLine{1986             \} \textcolor{comment}{// l loop}}
\DoxyCodeLine{1987             \} \textcolor{comment}{// ijk}}
\DoxyCodeLine{1988 }
\DoxyCodeLine{1989           \} \textcolor{comment}{// Symmetry check}}
\DoxyCodeLine{1990 }
\DoxyCodeLine{1991         \} \textcolor{comment}{// iMat loop}}
\DoxyCodeLine{1992 }
\DoxyCodeLine{1993 \textcolor{preprocessor}{\#ifdef \_REPORT\_INTEGRAL\_TIMINGS}}
\DoxyCodeLine{1994 \textcolor{comment}{//        ProgramTimer::tock("{}Direct Den Contract"{});}}
\DoxyCodeLine{1995 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1996 }
\DoxyCodeLine{1997 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1998 }
\DoxyCodeLine{1999 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2000       \} \textcolor{comment}{// loop s4}}
\DoxyCodeLine{2001       \} \textcolor{comment}{// loop s3}}
\DoxyCodeLine{2002 }
\DoxyCodeLine{2003     \}; \textcolor{comment}{// s2}}
\DoxyCodeLine{2004     \}; \textcolor{comment}{// s1}}
\DoxyCodeLine{2005 }
\DoxyCodeLine{2006 }
\DoxyCodeLine{2007     \}; \textcolor{comment}{// OpenMP context}}
\DoxyCodeLine{2008 }
\DoxyCodeLine{2009 }
\DoxyCodeLine{2010 \textcolor{preprocessor}{\#ifdef \_REPORT\_INTEGRAL\_TIMINGS}}
\DoxyCodeLine{2011     \textcolor{keywordtype}{size\_t} nIntSkipAcc = std::accumulate(nIntSkip.begin(),nIntSkip.end(),0);}
\DoxyCodeLine{2012     std::cout << \textcolor{stringliteral}{"{}Skipped Intgral:     "{}} << nIntSkipAcc << std::endl;}
\DoxyCodeLine{2013 \textcolor{preprocessor}{\#ifdef \_SEPARATED\_SHZ\_SCREEN    }}
\DoxyCodeLine{2014     \textcolor{keywordtype}{size\_t} nConSkipAcc = std::accumulate(nConSkip.begin(),nConSkip.end(),0);}
\DoxyCodeLine{2015     std::cout << \textcolor{stringliteral}{"{}Skipped Contraction: "{}} << nConSkipAcc << std::endl;}
\DoxyCodeLine{2016 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2017 }
\DoxyCodeLine{2018     \textcolor{keyword}{auto} durDirect = \mbox{\hyperlink{namespaceChronusQ_a3b2153e93af4532ff5b1e75d8af453b0}{tock}}(topDirect);}
\DoxyCodeLine{2019     std::cout << \textcolor{stringliteral}{"{}Coulomb-\/Exchange AO Direct Contraction took "{}} <<  durDirect << \textcolor{stringliteral}{"{} s\(\backslash\)n"{}}; }
\DoxyCodeLine{2020 }
\DoxyCodeLine{2021     std::cout << std::endl;}
\DoxyCodeLine{2022 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2023 }
\DoxyCodeLine{2024 }
\DoxyCodeLine{2025 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{2026 }
\DoxyCodeLine{2027     MatsT* SCR = memManager\_.malloc<MatsT>(nBasis * nBasis);}
\DoxyCodeLine{2028     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} iMat = 0; iMat < nMat;  iMat++ ) }
\DoxyCodeLine{2029     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} iTh  = 0; iTh < nThreads; iTh++) \{}
\DoxyCodeLine{2030   }
\DoxyCodeLine{2031       \textcolor{keywordflow}{if}( matList[iMat].HER ) \{}
\DoxyCodeLine{2032 }
\DoxyCodeLine{2033         \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'C'},nBasis,nBasis,MatsT(0.5),AXthreads[iTh][iMat],nBasis,MatsT(0.5),}
\DoxyCodeLine{2034           AXthreads[iTh][iMat],nBasis,SCR,nBasis);}
\DoxyCodeLine{2035 }
\DoxyCodeLine{2036         \textcolor{keywordflow}{if}( nThreads != 1 )}
\DoxyCodeLine{2037           \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'N'},nBasis,nBasis,MatsT(1.),SCR,nBasis,MatsT(1.), matList[iMat].AX,nBasis,matList[iMat].AX,nBasis);}
\DoxyCodeLine{2038         \textcolor{keywordflow}{else}}
\DoxyCodeLine{2039           \mbox{\hyperlink{namespaceChronusQ_ae8f5db3509402cc0920cf103d5fb9952}{SetMat}}(\textcolor{charliteral}{'N'},nBasis,nBasis,MatsT(1.),SCR,nBasis,matList[iMat].AX,nBasis);}
\DoxyCodeLine{2040 }
\DoxyCodeLine{2041       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2042         }
\DoxyCodeLine{2043         \textcolor{keywordflow}{if} (\&basisSet\_ != \&basisSet2\_)}
\DoxyCodeLine{2044           \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}No non-\/Hermitian contraction between two different basis!"{}}, std::cout);}
\DoxyCodeLine{2045 }
\DoxyCodeLine{2046         \textcolor{keywordflow}{if}( nThreads != 1 )}
\DoxyCodeLine{2047           \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'N'},nBasis,nBasis,MatsT(0.5),AXthreads[iTh][iMat],nBasis,}
\DoxyCodeLine{2048             MatsT(1.), matList[iMat].AX,nBasis,matList[iMat].AX,nBasis);}
\DoxyCodeLine{2049         \textcolor{keywordflow}{else} }
\DoxyCodeLine{2050           blas::scal(nBasis*nBasis,MatsT(0.5),matList[iMat].AX,1);}
\DoxyCodeLine{2051 }
\DoxyCodeLine{2052       \}}
\DoxyCodeLine{2053 }
\DoxyCodeLine{2054     \};}
\DoxyCodeLine{2055     memManager\_.free(SCR);}
\DoxyCodeLine{2056     }
\DoxyCodeLine{2057 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2058 }
\DoxyCodeLine{2059     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \&C : matList ) \{}
\DoxyCodeLine{2060 }
\DoxyCodeLine{2061       \textcolor{comment}{// Symmetrize J contraction}}
\DoxyCodeLine{2062       \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} ) }
\DoxyCodeLine{2063         \mbox{\hyperlink{namespaceChronusQ_a8de87c3f9b6b79c38f5be581c31dade9}{HerMat}}(\textcolor{charliteral}{'L'},nBasis,C.AX,nBasis);}
\DoxyCodeLine{2064 }
\DoxyCodeLine{2065       \textcolor{comment}{// Inplace transpose of K contraction}}
\DoxyCodeLine{2066       \textcolor{keywordflow}{if}( C.contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} ) }
\DoxyCodeLine{2067         \mbox{\hyperlink{namespaceChronusQ_abbee1773b3f12915d6c51842e34dc06d}{IMatCopy}}(\textcolor{charliteral}{'C'},nBasis,nBasis,MatsT(1.),C.AX,nBasis,nBasis);}
\DoxyCodeLine{2068   }
\DoxyCodeLine{2069     \} \textcolor{comment}{// Loop over contractions}}
\DoxyCodeLine{2070 }
\DoxyCodeLine{2071 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2072 }
\DoxyCodeLine{2073 }
\DoxyCodeLine{2074 \textcolor{preprocessor}{\#ifdef CQ\_ENABLE\_MPI}}
\DoxyCodeLine{2075     \textcolor{comment}{// Combine all G[X] contributions onto Root process}}
\DoxyCodeLine{2076     \textcolor{keywordflow}{if}( mpiSize > 1 ) \{}
\DoxyCodeLine{2077 }
\DoxyCodeLine{2078       \textcolor{comment}{// FIXME: This should be able to be done with MPI\_IN\_PLACE for}}
\DoxyCodeLine{2079       \textcolor{comment}{// the root process}}
\DoxyCodeLine{2080         }
\DoxyCodeLine{2081       MatsT* mpiScr;}
\DoxyCodeLine{2082       \textcolor{keywordflow}{if}( mpiRank == 0 ) mpiScr = memManager\_.malloc<MatsT>(nBasis*nBasis);}
\DoxyCodeLine{2083 }
\DoxyCodeLine{2084       \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} \&C : matList ) \{}
\DoxyCodeLine{2085 \textcolor{comment}{//      prettyPrintSmart(std::cerr,"{}AX in Direct"{},C.AX,nBasis,nBasis,nBasis);}}
\DoxyCodeLine{2086 }
\DoxyCodeLine{2087         mxx::reduce( C.AX, nBasis*nBasis, mpiScr, 0, std::plus<MatsT>(), comm );}
\DoxyCodeLine{2088 }
\DoxyCodeLine{2089         \textcolor{comment}{// Copy over the output buffer on root}}
\DoxyCodeLine{2090         \textcolor{keywordflow}{if}( mpiRank == 0 ) std::copy\_n(mpiScr,nBasis*nBasis,C.AX);}
\DoxyCodeLine{2091 }
\DoxyCodeLine{2092       \}}
\DoxyCodeLine{2093 }
\DoxyCodeLine{2094       \textcolor{keywordflow}{if}( mpiRank == 0 ) memManager\_.free(mpiScr);}
\DoxyCodeLine{2095 }
\DoxyCodeLine{2096     \}}
\DoxyCodeLine{2097 }
\DoxyCodeLine{2098 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2099 }
\DoxyCodeLine{2100     \textcolor{comment}{// Free scratch space}}
\DoxyCodeLine{2101     memManager\_.free(intBuffer);}
\DoxyCodeLine{2102 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{2103     memManager\_.free(ShBlkNorms\_raw);}
\DoxyCodeLine{2104 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2105     \textcolor{keywordflow}{if}(AXRaw) memManager\_.free(AXRaw);}
\DoxyCodeLine{2106 }
\DoxyCodeLine{2107     \textcolor{comment}{// Turn threads for LA back on}}
\DoxyCodeLine{2108     \mbox{\hyperlink{namespaceChronusQ_a7b13ac1d1109f4a015feaab04cb3eaee}{SetLAThreads}}(LAThreads);}
\DoxyCodeLine{2109 }
\DoxyCodeLine{2110 \textcolor{comment}{//    ProgramTimer::tock("{}Contract Total"{});}}
\DoxyCodeLine{2111 }
\DoxyCodeLine{2112   \};}
\DoxyCodeLine{2113 }
\DoxyCodeLine{2114   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatsT, \textcolor{keyword}{typename} IntsT>}
\DoxyCodeLine{2115   \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{classChronusQ_1_1GTODirectTPIContraction}{GTODirectTPIContraction<MatsT,IntsT>::directScaffoldNewSCRSize}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2116 }
\DoxyCodeLine{2117     \textcolor{keywordtype}{size\_t} threadSCRSize  = 0ul;}
\DoxyCodeLine{2118     \textcolor{keywordtype}{size\_t} generalSCRSize = 0ul; }
\DoxyCodeLine{2119     }
\DoxyCodeLine{2120     \textcolor{comment}{// SCR needed for integrals}}
\DoxyCodeLine{2121     \mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<IntsT>}} \&tpi = \textcolor{keyword}{dynamic\_cast<}\mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<IntsT>}}\&\textcolor{keyword}{>}(this-\/>ints\_);}
\DoxyCodeLine{2122     \mbox{\hyperlink{structChronusQ_1_1BasisSet}{BasisSet}}\& basisSet\_  = this-\/>contractSecond ? tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_ae84f994852fca79387512fcfa6143fa4}{basisSet2}}() : tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a4a476a2dc5e606ee34f0a973b9ddce5c}{basisSet}}();}
\DoxyCodeLine{2123     \mbox{\hyperlink{structChronusQ_1_1BasisSet}{BasisSet}}\& basisSet2\_ = this-\/>contractSecond ? tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a4a476a2dc5e606ee34f0a973b9ddce5c}{basisSet}}()  : tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_ae84f994852fca79387512fcfa6143fa4}{basisSet2}}();}
\DoxyCodeLine{2124     }
\DoxyCodeLine{2125     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nBasis   = basisSet\_.\mbox{\hyperlink{classChronusQ_1_1ParticleIntegrals_adfa2fc01b859f9291e4e31e183963f8b}{nBasis}};}
\DoxyCodeLine{2126     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} snBasis  = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a40ad4a89b440bf71e0ef6ba317d8123f}{nBasis}};}
\DoxyCodeLine{2127     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nShell   = basisSet\_.nShell;}
\DoxyCodeLine{2128     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} snShell  = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a936871b121472a416ee6f947ccdea4b4}{nShell}};}
\DoxyCodeLine{2129     \textcolor{keywordtype}{size\_t} nThreads  = \mbox{\hyperlink{namespaceChronusQ_a3320ee560c87921c8d84885db82e9917}{GetNumThreads}}();}
\DoxyCodeLine{2130     }
\DoxyCodeLine{2131     \textcolor{comment}{// create a dummy engine to figure out sizes}}
\DoxyCodeLine{2132     libint2::Engine engine(libint2::Operator::coulomb, }
\DoxyCodeLine{2133       std::max(basisSet\_.maxPrim, basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}}),}
\DoxyCodeLine{2134       std::max(basisSet\_.maxL, basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a90bfe80774a23ae70d381783a1d275ac}{maxL}}),0);}
\DoxyCodeLine{2135 }
\DoxyCodeLine{2136     \textcolor{comment}{// Allocate scratch for raw integral batches}}
\DoxyCodeLine{2137     \textcolor{keywordtype}{size\_t} maxShellSize = }
\DoxyCodeLine{2138       std::max\_element(basisSet\_.shells.begin(),basisSet\_.shells.end(),}
\DoxyCodeLine{2139         [](libint2::Shell \&sh1, libint2::Shell \&sh2) \{}
\DoxyCodeLine{2140           return sh1.size() < sh2.size();}
\DoxyCodeLine{2141         \})-\/>size();}
\DoxyCodeLine{2142 }
\DoxyCodeLine{2143     \textcolor{keywordtype}{size\_t} maxShellSize2 = }
\DoxyCodeLine{2144       std::max\_element(basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.begin(),basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.end(),}
\DoxyCodeLine{2145         [](libint2::Shell \&sh1, libint2::Shell \&sh2) \{}
\DoxyCodeLine{2146           return sh1.size() < sh2.size();}
\DoxyCodeLine{2147         \})-\/>size();}
\DoxyCodeLine{2148 }
\DoxyCodeLine{2149     \textcolor{comment}{// lenIntBuffer is allocated to be able to store EPAI's of the }}
\DoxyCodeLine{2150     \textcolor{comment}{// shell with the highest angular momentum}}
\DoxyCodeLine{2151     \textcolor{comment}{// seems that lenIntBuffer is already in MatsT}}
\DoxyCodeLine{2152     \textcolor{keywordtype}{size\_t} lenIntBuffer = }
\DoxyCodeLine{2153       maxShellSize * maxShellSize * maxShellSize2 * maxShellSize2; }
\DoxyCodeLine{2154 }
\DoxyCodeLine{2155     \textcolor{keywordtype}{size\_t} nBuffer = 2;}
\DoxyCodeLine{2156     }
\DoxyCodeLine{2157     threadSCRSize += nBuffer*lenIntBuffer; }
\DoxyCodeLine{2158     }
\DoxyCodeLine{2159     \textcolor{comment}{// SCR needed for contraction storage in each thread}}
\DoxyCodeLine{2160     \textcolor{keywordflow}{if} (nThreads != 1) threadSCRSize += nBasis*nBasis;}
\DoxyCodeLine{2161 }
\DoxyCodeLine{2162 \textcolor{preprocessor}{\#ifdef \_SHZ\_SCREEN}}
\DoxyCodeLine{2163     \textcolor{comment}{// 1 for general shell block ∞-\/norms and 1 for each matrix}}
\DoxyCodeLine{2164     generalSCRSize += snShell*snShell*2;  }
\DoxyCodeLine{2165 }
\DoxyCodeLine{2166 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2167 }
\DoxyCodeLine{2168     \textcolor{keywordflow}{return} threadSCRSize * nThreads + generalSCRSize;}
\DoxyCodeLine{2169   \}; \textcolor{comment}{// GTODirectTPIContraction::directScaffoldNewSCRSize()}}
\DoxyCodeLine{2170   }
\DoxyCodeLine{2171   \textcolor{keywordtype}{void} GIAODirectERIContraction::twoBodyContract(}
\DoxyCodeLine{2172       \mbox{\hyperlink{structChronusQ_1_1MPI__Comm}{MPI\_Comm}} c,}
\DoxyCodeLine{2173       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} screen,}
\DoxyCodeLine{2174       std::vector<\mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction}{TwoBodyContraction<dcomplex>}}> \&list,}
\DoxyCodeLine{2175       \mbox{\hyperlink{structChronusQ_1_1EMPerturbation}{EMPerturbation}} \&pert)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2176     \textcolor{comment}{// Only use GIAOs if GIAOs are selected and if}}
\DoxyCodeLine{2177     \textcolor{comment}{// a Magnetic field is in the EMPerturbation}}
\DoxyCodeLine{2178 }
\DoxyCodeLine{2179     \textcolor{keywordflow}{if}( \mbox{\hyperlink{namespaceChronusQ_a0f814f3c29fcd820aea53f9d3e317e42}{pert\_has\_type}}(pert,\mbox{\hyperlink{namespaceChronusQ_a835c683852c41dbda49a81d46ec94fd9a79930d8d7bb5d90a171f83bdb0a2451f}{Magnetic}}) ) \{}
\DoxyCodeLine{2180       directScaffold(c, screen, list, pert);}
\DoxyCodeLine{2181     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2182       directScaffoldNew(c, screen, list);}
\DoxyCodeLine{2183     \}}
\DoxyCodeLine{2184   \}}
\DoxyCodeLine{2185 }
\DoxyCodeLine{2186 }
\DoxyCodeLine{2187   \textcolor{keyword}{template} <\textcolor{keyword}{typename} MatsT, \textcolor{keyword}{typename} IntsT>}
\DoxyCodeLine{2188   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1DirectGradContraction}{DirectGradContraction<MatsT,IntsT>::directScaffoldGrad}}(}
\DoxyCodeLine{2189       \mbox{\hyperlink{structChronusQ_1_1MPI__Comm}{MPI\_Comm}} comm,}
\DoxyCodeLine{2190       \textcolor{keyword}{const} \textcolor{keywordtype}{bool} screen,}
\DoxyCodeLine{2191       std::vector<std::vector<\mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction}{TwoBodyContraction<MatsT>}}>>\& cList)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2192 }
\DoxyCodeLine{2193     \textcolor{comment}{// This method has no screening right now}}
\DoxyCodeLine{2194     \textcolor{comment}{// Screening should be done according to 10.1002/jcc.540120903}}
\DoxyCodeLine{2195     \textcolor{comment}{//}}
\DoxyCodeLine{2196     \textcolor{comment}{// TODO: MPI is also likely broken for this}}
\DoxyCodeLine{2197     \textcolor{comment}{//}}
\DoxyCodeLine{2198 }
\DoxyCodeLine{2199     \mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<IntsT>}} \&tpi =}
\DoxyCodeLine{2200         \textcolor{keyword}{dynamic\_cast<}\mbox{\hyperlink{classChronusQ_1_1DirectTPI}{DirectTPI<IntsT>}}\&\textcolor{keyword}{>}(*this-\/>grad\_[0]);}
\DoxyCodeLine{2201     \mbox{\hyperlink{classChronusQ_1_1CQMemManager}{CQMemManager}}\& memManager\_ = tpi.\mbox{\hyperlink{classChronusQ_1_1ParticleIntegrals_a4980f581ea843bd4ca6be7ac88064274}{memManager}}();}
\DoxyCodeLine{2202     \mbox{\hyperlink{structChronusQ_1_1BasisSet}{BasisSet}}\& basisSet\_  = this-\/>contractSecond ? tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_ae84f994852fca79387512fcfa6143fa4}{basisSet2}}() : tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a4a476a2dc5e606ee34f0a973b9ddce5c}{basisSet}}();}
\DoxyCodeLine{2203     \mbox{\hyperlink{structChronusQ_1_1BasisSet}{BasisSet}}\& basisSet2\_ = this-\/>contractSecond ? tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_a4a476a2dc5e606ee34f0a973b9ddce5c}{basisSet}}()  : tpi.\mbox{\hyperlink{classChronusQ_1_1DirectTPI_ae84f994852fca79387512fcfa6143fa4}{basisSet2}}();}
\DoxyCodeLine{2204 }
\DoxyCodeLine{2205     \textcolor{keywordtype}{size\_t} nThreads  = \mbox{\hyperlink{namespaceChronusQ_a3320ee560c87921c8d84885db82e9917}{GetNumThreads}}();}
\DoxyCodeLine{2206     \textcolor{keywordtype}{size\_t} LAThreads = \mbox{\hyperlink{namespaceChronusQ_a3152808c4819d6cbf8a29aef92728866}{GetLAThreads}}();}
\DoxyCodeLine{2207     \textcolor{keywordtype}{size\_t} mpiRank   = \mbox{\hyperlink{namespaceChronusQ_ac9433164d43ee9f6f0c49e49698f680f}{MPIRank}}(comm);}
\DoxyCodeLine{2208     \textcolor{keywordtype}{size\_t} mpiSize   = \mbox{\hyperlink{namespaceChronusQ_a6ef99d456575a9727c4d7d4eb8149416}{MPISize}}(comm);}
\DoxyCodeLine{2209 }
\DoxyCodeLine{2210     \mbox{\hyperlink{namespaceChronusQ_a7b13ac1d1109f4a015feaab04cb3eaee}{SetLAThreads}}(1); \textcolor{comment}{// Turn off parallelism in LA functions}}
\DoxyCodeLine{2211 }
\DoxyCodeLine{2212     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nBasis   = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a40ad4a89b440bf71e0ef6ba317d8123f}{nBasis}};}
\DoxyCodeLine{2213     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} snBasis  = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a40ad4a89b440bf71e0ef6ba317d8123f}{nBasis}};}
\DoxyCodeLine{2214     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nShell   = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a936871b121472a416ee6f947ccdea4b4}{nShell}};}
\DoxyCodeLine{2215     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} snShell  = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a936871b121472a416ee6f947ccdea4b4}{nShell}};}
\DoxyCodeLine{2216     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nTotGrad = cList.size();}
\DoxyCodeLine{2217     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nMat     = cList[0].size();}
\DoxyCodeLine{2218 }
\DoxyCodeLine{2219     \textcolor{keywordtype}{bool} NonHermitian = \textcolor{keyword}{false};}
\DoxyCodeLine{2220     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& gradComp: cList)}
\DoxyCodeLine{2221       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}\& x: gradComp)}
\DoxyCodeLine{2222         NonHermitian |= not x.\mbox{\hyperlink{structChronusQ_1_1TwoBodyContraction_a2bc6fb16f318b0e1919da14f76ea77e5}{HER}};}
\DoxyCodeLine{2223 }
\DoxyCodeLine{2224     std::vector<libint2::Engine> engines(nThreads);}
\DoxyCodeLine{2225 }
\DoxyCodeLine{2226     \textcolor{comment}{// Construct engine for master thread}}
\DoxyCodeLine{2227     engines[0] = libint2::Engine(libint2::Operator::coulomb,}
\DoxyCodeLine{2228       std::max(basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}}, basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_aee354d7cf0e3268aed3a136409c23662}{maxPrim}}), }
\DoxyCodeLine{2229       std::max(basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a90bfe80774a23ae70d381783a1d275ac}{maxL}}, basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a90bfe80774a23ae70d381783a1d275ac}{maxL}}),1);}
\DoxyCodeLine{2230 }
\DoxyCodeLine{2231     \textcolor{comment}{// Allocate scratch for raw integral batches}}
\DoxyCodeLine{2232     \textcolor{keywordtype}{size\_t} maxShellSize = }
\DoxyCodeLine{2233       std::max\_element(basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.begin(),basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.end(),}
\DoxyCodeLine{2234         [](libint2::Shell \&sh1, libint2::Shell \&sh2) \{}
\DoxyCodeLine{2235           return sh1.size() < sh2.size();}
\DoxyCodeLine{2236         \})-\/>size();}
\DoxyCodeLine{2237 }
\DoxyCodeLine{2238     \textcolor{keywordtype}{size\_t} maxShellSize2 = }
\DoxyCodeLine{2239       std::max\_element(basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.begin(),basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}.end(),}
\DoxyCodeLine{2240         [](libint2::Shell \&sh1, libint2::Shell \&sh2) \{}
\DoxyCodeLine{2241           return sh1.size() < sh2.size();}
\DoxyCodeLine{2242         \})-\/>size();}
\DoxyCodeLine{2243 }
\DoxyCodeLine{2244     \textcolor{comment}{// lenIntBuffer is allocated to be able to store ERI's of the shell with}}
\DoxyCodeLine{2245     \textcolor{comment}{// the highest angular momentum}}
\DoxyCodeLine{2246     \textcolor{keywordtype}{size\_t} lenIntBuffer = }
\DoxyCodeLine{2247       maxShellSize * maxShellSize * maxShellSize2 * maxShellSize2; }
\DoxyCodeLine{2248 }
\DoxyCodeLine{2249     lenIntBuffer *= \textcolor{keyword}{sizeof}(MatsT) / \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double});}
\DoxyCodeLine{2250 }
\DoxyCodeLine{2251     \textcolor{keywordtype}{size\_t} nBuffer = 2;}
\DoxyCodeLine{2252 }
\DoxyCodeLine{2253     \textcolor{comment}{// 12 derivatives per integral (3 xyz * 4 shells) }}
\DoxyCodeLine{2254     \textcolor{keywordtype}{size\_t} nGrad = 12;}
\DoxyCodeLine{2255 }
\DoxyCodeLine{2256     }
\DoxyCodeLine{2257     \textcolor{keywordtype}{double} * intBuffer = }
\DoxyCodeLine{2258       memManager\_.malloc<\textcolor{keywordtype}{double}>(nGrad*nBuffer*lenIntBuffer*nThreads);}
\DoxyCodeLine{2259    }
\DoxyCodeLine{2260     \textcolor{keywordtype}{double} *intBuffer2 = intBuffer + nGrad*nThreads*lenIntBuffer;}
\DoxyCodeLine{2261 }
\DoxyCodeLine{2262     \textcolor{comment}{// Allocate thread local storage to store integral contractions}}
\DoxyCodeLine{2263     \textcolor{comment}{// Threads, Gradients, Matrices, Basis, Basis}}
\DoxyCodeLine{2264     std::vector<std::vector<std::vector<MatsT*>>> AXthreads;}
\DoxyCodeLine{2265     MatsT *AXRaw = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2266     \textcolor{keywordflow}{if}(nThreads != 1) \{}
\DoxyCodeLine{2267       AXRaw = memManager\_.malloc<MatsT>(nTotGrad*nThreads*nMat*nBasis*nBasis);    }
\DoxyCodeLine{2268       memset(AXRaw,0,nTotGrad*nThreads*nMat*nBasis*nBasis*\textcolor{keyword}{sizeof}(MatsT));}
\DoxyCodeLine{2269     \}}
\DoxyCodeLine{2270 }
\DoxyCodeLine{2271     \textcolor{keywordflow}{if}(nThreads == 1) \{}
\DoxyCodeLine{2272       AXthreads.emplace\_back();}
\DoxyCodeLine{2273       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& gradComp: cList) \{}
\DoxyCodeLine{2274         AXthreads.back().emplace\_back();}
\DoxyCodeLine{2275         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& mat: gradComp) \{}
\DoxyCodeLine{2276           AXthreads.back().back().push\_back(mat.AX);}
\DoxyCodeLine{2277         \}}
\DoxyCodeLine{2278       \}}
\DoxyCodeLine{2279     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2280       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iThread = 0; iThread < nThreads; iThread++) \{}
\DoxyCodeLine{2281         AXthreads.emplace\_back();}
\DoxyCodeLine{2282         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iGrad = 0; iGrad < nTotGrad; iGrad++) \{}
\DoxyCodeLine{2283           AXthreads.back().emplace\_back();}
\DoxyCodeLine{2284           \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0; iMat < nMat; iMat++)}
\DoxyCodeLine{2285             AXthreads.back().back().push\_back(}
\DoxyCodeLine{2286               AXRaw +}
\DoxyCodeLine{2287               iThread*nMat*nBasis*nBasis*nTotGrad +}
\DoxyCodeLine{2288               iGrad*nMat*nBasis*nBasis +}
\DoxyCodeLine{2289               iMat*nBasis*nBasis}
\DoxyCodeLine{2290             );}
\DoxyCodeLine{2291         \}}
\DoxyCodeLine{2292       \}}
\DoxyCodeLine{2293     \}}
\DoxyCodeLine{2294 }
\DoxyCodeLine{2295     \textcolor{comment}{// Set Linbint precision}}
\DoxyCodeLine{2296     engines[0].set\_precision(std::numeric\_limits<double>::epsilon());}
\DoxyCodeLine{2297 }
\DoxyCodeLine{2298     \textcolor{comment}{// Copy master thread engine to other threads}}
\DoxyCodeLine{2299     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 1; i < nThreads; i++) engines[i] = engines[0];}
\DoxyCodeLine{2300 }
\DoxyCodeLine{2301     \textcolor{comment}{// Keeping track of number of integrals skipped}}
\DoxyCodeLine{2302     std::vector<size\_t> nSkip(nThreads,0);}
\DoxyCodeLine{2303 }
\DoxyCodeLine{2304 }
\DoxyCodeLine{2305     \textcolor{comment}{//}}
\DoxyCodeLine{2306     \textcolor{comment}{// Parallel region -\/ start work}}
\DoxyCodeLine{2307     \textcolor{comment}{//}}
\DoxyCodeLine{2308 \textcolor{preprocessor}{    \#pragma omp parallel}}
\DoxyCodeLine{2309     \{}
\DoxyCodeLine{2310 }
\DoxyCodeLine{2311     \textcolor{comment}{// Set up thread local storage}}
\DoxyCodeLine{2312 }
\DoxyCodeLine{2313     \textcolor{comment}{// SMP info}}
\DoxyCodeLine{2314     \textcolor{keywordtype}{size\_t} thread\_id = \mbox{\hyperlink{namespaceChronusQ_aa348a017ee78c3450480773ddc542e5c}{GetThreadID}}();}
\DoxyCodeLine{2315 }
\DoxyCodeLine{2316     \textcolor{keyword}{auto} \&engine = engines[thread\_id];}
\DoxyCodeLine{2317     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& buf\_vec = engine.results();}
\DoxyCodeLine{2318     }
\DoxyCodeLine{2319     \textcolor{keyword}{auto} \&AX\_loc = AXthreads[thread\_id];}
\DoxyCodeLine{2320 }
\DoxyCodeLine{2321 }
\DoxyCodeLine{2322     \textcolor{keywordtype}{double} * intBuffer\_loc  = intBuffer  + thread\_id*nGrad*lenIntBuffer;}
\DoxyCodeLine{2323     \textcolor{keywordtype}{double} * intBuffer2\_loc = intBuffer2 + thread\_id*nGrad*lenIntBuffer;}
\DoxyCodeLine{2324 }
\DoxyCodeLine{2325     \textcolor{keywordtype}{size\_t} n1,n2;}
\DoxyCodeLine{2326     \textcolor{keywordtype}{size\_t} shell\_atoms[4];}
\DoxyCodeLine{2327 }
\DoxyCodeLine{2328     \textcolor{comment}{// Always Loop over s2 <= s1}}
\DoxyCodeLine{2329     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} s1(0ul), bf1\_s(0ul), s12(0ul); s1 < nShell; bf1\_s+=n1, s1++) \{ }
\DoxyCodeLine{2330 }
\DoxyCodeLine{2331       n1 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1].size(); \textcolor{comment}{// Size of Shell 1}}
\DoxyCodeLine{2332       shell\_atoms[0] = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a2e39c31c653bccb44ec140148baa1ea0}{mapSh2Cen}}[s1]; \textcolor{comment}{// Atomic center of shell 1}}
\DoxyCodeLine{2333 }
\DoxyCodeLine{2334     \textcolor{keyword}{auto} sigPair12\_it = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a9ce9c1c8374ab7f969f8fbf661fcd9ac}{shData}}.at(s1).begin();}
\DoxyCodeLine{2335     \textcolor{keywordflow}{for}( \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t}\& s2 : basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a6ec4c9f444b6971af4f7d8a0f833af53}{sigShellPair}}[s1] ) \{}
\DoxyCodeLine{2336       \textcolor{keywordtype}{size\_t} bf2\_s = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a85f991b14d3877ba9dd6d5f3568ce2cc}{mapSh2Bf}}[s2];}
\DoxyCodeLine{2337 }
\DoxyCodeLine{2338       n2 = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2].size(); \textcolor{comment}{// Size of Shell 2}}
\DoxyCodeLine{2339       shell\_atoms[1] = basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a2e39c31c653bccb44ec140148baa1ea0}{mapSh2Cen}}[s2]; \textcolor{comment}{// Atomic center of shell 2}}
\DoxyCodeLine{2340 }
\DoxyCodeLine{2341       \textcolor{keyword}{const} \textcolor{keyword}{auto} * sigPair12 = sigPair12\_it-\/>get();}
\DoxyCodeLine{2342       sigPair12\_it++;}
\DoxyCodeLine{2343 }
\DoxyCodeLine{2344       \textcolor{comment}{// Round-\/Robin work distribution}}
\DoxyCodeLine{2345       \textcolor{keywordflow}{if}( (s12++) \% nThreads != thread\_id ) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{2346 }
\DoxyCodeLine{2347 }
\DoxyCodeLine{2348 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{2349       \textcolor{comment}{// Deneneracy factor for s1,s2 pair}}
\DoxyCodeLine{2350       \textcolor{keywordtype}{double} s12\_deg = (s1 == s2) ? 1.0 : 2.0;}
\DoxyCodeLine{2351 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2352 }
\DoxyCodeLine{2353 \textcolor{comment}{// The upper bound of s3 is s1 for the 8-\/fold symmetry and}}
\DoxyCodeLine{2354 \textcolor{comment}{// nShell for 4-\/fold.}}
\DoxyCodeLine{2355 \textcolor{preprocessor}{\#ifdef \_USE\_EIGHT\_FOLD}}
\DoxyCodeLine{2356 \textcolor{preprocessor}{  \#define S3\_MAX s1}}
\DoxyCodeLine{2357 \textcolor{preprocessor}{\#elif defined(\_USE\_FOUR\_FOLD)}}
\DoxyCodeLine{2358   \textcolor{comment}{// the "{}-\/"{} is for the <= in the loop}}
\DoxyCodeLine{2359 \textcolor{preprocessor}{  \#define S3\_MAX nShell -\/ 1}}
\DoxyCodeLine{2360 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2361 }
\DoxyCodeLine{2362 }
\DoxyCodeLine{2363       \textcolor{keywordtype}{size\_t} n3,n4;}
\DoxyCodeLine{2364       \textcolor{keywordtype}{size\_t} s3\_max = (\&basisSet\_ == \&basisSet2\_) ? \mbox{\hyperlink{contract_2direct_8hpp_ac708ebfb62ad4528bedaeffbe28a3e06}{S3\_MAX}} : snShell -\/ 1;}
\DoxyCodeLine{2365 }
\DoxyCodeLine{2366       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} s3(0ul), bf3\_s(0ul), s34(0ul); s3 <= s3\_max; s3++, bf3\_s += n3) \{ }
\DoxyCodeLine{2367 }
\DoxyCodeLine{2368         n3 = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3].size(); \textcolor{comment}{// Size of Shell 3}}
\DoxyCodeLine{2369         shell\_atoms[2] = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a2e39c31c653bccb44ec140148baa1ea0}{mapSh2Cen}}[s3]; \textcolor{comment}{// Atomic center of shell 3}}
\DoxyCodeLine{2370 }
\DoxyCodeLine{2371 }
\DoxyCodeLine{2372 \textcolor{comment}{// The upper bound of s4 is either s2 or s3 based on s1 and s3 for}}
\DoxyCodeLine{2373 \textcolor{comment}{// the 8-\/fold symmetry and s3 for the 4-\/fold symmetry}}
\DoxyCodeLine{2374 \textcolor{preprocessor}{\#ifdef \_USE\_EIGHT\_FOLD}}
\DoxyCodeLine{2375         \textcolor{keywordtype}{size\_t} s4\_max = (s1 == s3) ? s2 : s3;}
\DoxyCodeLine{2376 \textcolor{preprocessor}{\#elif defined(\_USE\_FOUR\_FOLD)}}
\DoxyCodeLine{2377         \textcolor{keywordtype}{size\_t} s4\_max =  s3;}
\DoxyCodeLine{2378 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2379       \textcolor{keywordflow}{if} (\&basisSet\_ != \&basisSet2\_)}
\DoxyCodeLine{2380         s4\_max =  s3;}
\DoxyCodeLine{2381 }
\DoxyCodeLine{2382       \textcolor{keyword}{auto} sigPair34\_it = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a9ce9c1c8374ab7f969f8fbf661fcd9ac}{shData}}.at(s3).begin();}
\DoxyCodeLine{2383       \textcolor{keywordflow}{for}( \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t}\& s4 : basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a5256ca12a298fe9abdda8e3d574dab24}{shellData}}.\mbox{\hyperlink{structChronusQ_1_1ShellPairData_a6ec4c9f444b6971af4f7d8a0f833af53}{sigShellPair}}[s3] ) \{}
\DoxyCodeLine{2384 }
\DoxyCodeLine{2385         \textcolor{keywordflow}{if} (s4 > s4\_max)}
\DoxyCodeLine{2386           \textcolor{keywordflow}{break};  \textcolor{comment}{// for each s3, s4 are stored in monotonically increasing}}
\DoxyCodeLine{2387                   \textcolor{comment}{// order}}
\DoxyCodeLine{2388 }
\DoxyCodeLine{2389         \textcolor{keyword}{const} \textcolor{keyword}{auto} * sigPair34 = sigPair34\_it-\/>get();}
\DoxyCodeLine{2390         sigPair34\_it++;}
\DoxyCodeLine{2391                     }
\DoxyCodeLine{2392         \textcolor{keywordtype}{size\_t} bf4\_s = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a85f991b14d3877ba9dd6d5f3568ce2cc}{mapSh2Bf}}[s4];}
\DoxyCodeLine{2393 }
\DoxyCodeLine{2394         n4 = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4].size(); \textcolor{comment}{// Size of Shell 4}}
\DoxyCodeLine{2395         shell\_atoms[3] = basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a2e39c31c653bccb44ec140148baa1ea0}{mapSh2Cen}}[s4]; \textcolor{comment}{// Atomic center of shell 4}}
\DoxyCodeLine{2396 }
\DoxyCodeLine{2397 \textcolor{preprocessor}{\#ifdef \_FULL\_DIRECT}}
\DoxyCodeLine{2398 }
\DoxyCodeLine{2399         \textcolor{comment}{// Degeneracy factor for s3,s4 pair}}
\DoxyCodeLine{2400         \textcolor{keywordtype}{double} s34\_deg = (s3 == s4) ? 1.0 : 2.0;}
\DoxyCodeLine{2401 }
\DoxyCodeLine{2402         \textcolor{comment}{// Degeneracy factor for s1, s2, s3, s4 quartet}}
\DoxyCodeLine{2403         \textcolor{keywordtype}{double} s12\_34\_deg = 2.0;}
\DoxyCodeLine{2404         \textcolor{keywordflow}{if} (\&basisSet\_ == \&basisSet2\_)}
\DoxyCodeLine{2405           s12\_34\_deg = (s1 == s3) ? (s2 == s4 ? 1.0 : 2.0) : 2.0;}
\DoxyCodeLine{2406 }
\DoxyCodeLine{2407         \textcolor{comment}{// Total degeneracy factor}}
\DoxyCodeLine{2408         \textcolor{keywordtype}{double} s1234\_deg = s12\_deg * s34\_deg * s12\_34\_deg;}
\DoxyCodeLine{2409 }
\DoxyCodeLine{2410 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2411 }
\DoxyCodeLine{2412         engine.compute2<}
\DoxyCodeLine{2413           libint2::Operator::coulomb, libint2::BraKet::xx\_xx, 1>(}
\DoxyCodeLine{2414           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s1],}
\DoxyCodeLine{2415           basisSet\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s2],}
\DoxyCodeLine{2416           basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s3],}
\DoxyCodeLine{2417           basisSet2\_.\mbox{\hyperlink{structChronusQ_1_1BasisSet_a9be2da981037c46350e698aa0c179330}{shells}}[s4]);}
\DoxyCodeLine{2418 }
\DoxyCodeLine{2419         \textcolor{comment}{// Scale the buffer by the degeneracy factor and store}}
\DoxyCodeLine{2420         \textcolor{comment}{// in infBuffer}}
\DoxyCodeLine{2421         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} d = 0; d < buf\_vec.size(); d++) \{}
\DoxyCodeLine{2422           \textcolor{keywordflow}{if} (buf\_vec[d] == \textcolor{keyword}{nullptr}) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{2423           std::transform(}
\DoxyCodeLine{2424             buf\_vec[d],}
\DoxyCodeLine{2425             buf\_vec[d] + n1*n2*n3*n4,}
\DoxyCodeLine{2426             intBuffer\_loc+d*lenIntBuffer,}
\DoxyCodeLine{2427             std::bind(std::multiplies<double>(),0.5*s1234\_deg,std::placeholders::\_1)}
\DoxyCodeLine{2428           );}
\DoxyCodeLine{2429         \}}
\DoxyCodeLine{2430 }
\DoxyCodeLine{2431         \textcolor{keywordtype}{size\_t} b1,b2,b3,b4;}
\DoxyCodeLine{2432         \textcolor{keywordtype}{double} *Xp1, *Xp2;}
\DoxyCodeLine{2433         \textcolor{keywordtype}{double} X1,X2;}
\DoxyCodeLine{2434         MatsT  T1,T2,T3,T4;}
\DoxyCodeLine{2435         MatsT  *Tp1,*Tp2;}
\DoxyCodeLine{2436 }
\DoxyCodeLine{2437         \textcolor{comment}{// Loop over gradient components}}
\DoxyCodeLine{2438         \textcolor{keywordflow}{for} ( \textcolor{keyword}{auto} iGrad = 0; iGrad < nGrad; iGrad++ ) \{}
\DoxyCodeLine{2439 }
\DoxyCodeLine{2440         \textcolor{comment}{// Libint internal screening (for each gradient component)}}
\DoxyCodeLine{2441         \textcolor{keyword}{const} \textcolor{keywordtype}{double}* buff = buf\_vec[iGrad];}
\DoxyCodeLine{2442         \textcolor{keywordflow}{if} ( buff == \textcolor{keyword}{nullptr} ) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{2443 }
\DoxyCodeLine{2444         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} xyz = iGrad \% 3; \textcolor{comment}{// Cartesian component of gradient}}
\DoxyCodeLine{2445         \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} iSh = iGrad / 3; \textcolor{comment}{// Shell on which the gradient is taken}}
\DoxyCodeLine{2446 }
\DoxyCodeLine{2447         \textcolor{comment}{// Gradient component that is relevant for this contraction}}
\DoxyCodeLine{2448         std::vector<TwoBodyContraction<MatsT>>\& gradList =}
\DoxyCodeLine{2449           cList[shell\_atoms[iSh]*3 + xyz];}
\DoxyCodeLine{2450 }
\DoxyCodeLine{2451         \textcolor{comment}{// Thread local storage for this contraction}}
\DoxyCodeLine{2452         \textcolor{keyword}{auto}\& AX\_Grad\_loc = AX\_loc[shell\_atoms[iSh]*3 + xyz];}
\DoxyCodeLine{2453 }
\DoxyCodeLine{2454         \textcolor{comment}{// Portion of the integral buffer for this gradient}}
\DoxyCodeLine{2455         \textcolor{keywordtype}{double}* intBuffer\_Grad\_loc = intBuffer\_loc + iGrad*lenIntBuffer;}
\DoxyCodeLine{2456 }
\DoxyCodeLine{2457         \textcolor{comment}{// loop over matrices in contraction}}
\DoxyCodeLine{2458         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iMat = 0; iMat < nMat; iMat++) \{}
\DoxyCodeLine{2459 }
\DoxyCodeLine{2460           \textcolor{comment}{// Hermetian contraction}}
\DoxyCodeLine{2461           \textcolor{keywordflow}{if}( gradList[iMat].HER ) \{ }
\DoxyCodeLine{2462             \textcolor{keywordflow}{if} ( gradList[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cba973881f532185390135a2845f80eb3ae}{COULOMB}} ) \{}
\DoxyCodeLine{2463             \textcolor{comment}{// loop over basis functions in the shell quartet}}
\DoxyCodeLine{2464             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)}
\DoxyCodeLine{2465             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++) \{}
\DoxyCodeLine{2466               \textcolor{comment}{// Cache i,j variables}}
\DoxyCodeLine{2467               b1 = bf1 + nBasis*bf2;}
\DoxyCodeLine{2468               X1 = *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(gradList[iMat].X  + b1);}
\DoxyCodeLine{2469               Xp1 = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(AX\_Grad\_loc[iMat] + b1);}
\DoxyCodeLine{2470             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++)}
\DoxyCodeLine{2471             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{}
\DoxyCodeLine{2472 }
\DoxyCodeLine{2473               \textcolor{comment}{// J(1,2) += I * X(4,3)}}
\DoxyCodeLine{2474               *Xp1 += *\mbox{\hyperlink{contract_2direct_8hpp_aeabcb643c83e6a65cf0f72831edd377d}{GetRealPtr}}(gradList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}},bf4,bf3,snBasis) * intBuffer\_Grad\_loc[ijkl];}
\DoxyCodeLine{2475 }
\DoxyCodeLine{2476               \textcolor{comment}{// J(4,3) += I * X(1,2)}}
\DoxyCodeLine{2477               \textcolor{keywordflow}{if} (\&basisSet\_ == \&basisSet2\_)}
\DoxyCodeLine{2478                 *\mbox{\hyperlink{contract_2direct_8hpp_aeabcb643c83e6a65cf0f72831edd377d}{GetRealPtr}}(AX\_Grad\_loc[iMat],bf4,bf3,nBasis) +=  X1 * intBuffer\_Grad\_loc[ijkl];}
\DoxyCodeLine{2479 }
\DoxyCodeLine{2480               \textcolor{comment}{// J(2,1) and J(3,4) are handled on symmetrization after}}
\DoxyCodeLine{2481               \textcolor{comment}{// contraction}}
\DoxyCodeLine{2482             \} \textcolor{comment}{// kl loop}}
\DoxyCodeLine{2483             \} \textcolor{comment}{// ij loop}}
\DoxyCodeLine{2484 }
\DoxyCodeLine{2485             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( gradList[iMat].contType == \mbox{\hyperlink{namespaceChronusQ_a14bbb7fd8ce60d0c69d4985cd7d9c4cbaa095106eab8e9a7a1e33352295d00093}{EXCHANGE}} ) \{}
\DoxyCodeLine{2486               \textcolor{keywordflow}{if} (\&basisSet\_ != \&basisSet2\_)}
\DoxyCodeLine{2487                 \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}No exchange contraction between two different basis!"{}}, std::cout);}
\DoxyCodeLine{2488               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul, bf1 = bf1\_s, ijkl(0ul); i < n1; i++, bf1++)      }
\DoxyCodeLine{2489               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} j = 0ul, bf2 = bf2\_s; j < n2; j++, bf2++)       }
\DoxyCodeLine{2490               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} k = 0ul, bf3 = bf3\_s; k < n3; k++, bf3++) \{}
\DoxyCodeLine{2491 }
\DoxyCodeLine{2492                 \textcolor{comment}{// Cache i,j,k variables}}
\DoxyCodeLine{2493                 b1 = bf1 + bf3*nBasis;}
\DoxyCodeLine{2494                 b2 = bf2 + bf3*nBasis;}
\DoxyCodeLine{2495 }
\DoxyCodeLine{2496                 T1 = 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(gradList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}}[b1]);}
\DoxyCodeLine{2497                 T2 = 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(gradList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}}[b2]);}
\DoxyCodeLine{2498 }
\DoxyCodeLine{2499               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0ul, bf4 = bf4\_s; l < n4; l++, bf4++, ijkl++) \{ }
\DoxyCodeLine{2500 }
\DoxyCodeLine{2501                 \textcolor{comment}{// Indicies are swapped here to loop over contiguous memory}}
\DoxyCodeLine{2502                   }
\DoxyCodeLine{2503                 \textcolor{comment}{// K(1,3) += 0.5 * I * X(2,4) = 0.5 * I * CONJ(X(4,2)) (**HER**)}}
\DoxyCodeLine{2504                 AX\_Grad\_loc[iMat][b1]           += 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(gradList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}}[bf4+nBasis*bf2]) * intBuffer\_Grad\_loc[ijkl];}
\DoxyCodeLine{2505 }
\DoxyCodeLine{2506                 \textcolor{comment}{// K(4,2) += 0.5 * I * X(3,1) = 0.5 * I * CONJ(X(1,3)) (**HER**)}}
\DoxyCodeLine{2507                 AX\_Grad\_loc[iMat][bf4 + bf2*nBasis] += T1 * intBuffer\_Grad\_loc[ijkl];}
\DoxyCodeLine{2508 }
\DoxyCodeLine{2509                 \textcolor{comment}{// K(4,1) += 0.5 * I * X(3,2) = 0.5 * I * CONJ(X(2,3)) (**HER**)}}
\DoxyCodeLine{2510                 AX\_Grad\_loc[iMat][bf4 + bf1*nBasis] += T2 * intBuffer\_Grad\_loc[ijkl];}
\DoxyCodeLine{2511 }
\DoxyCodeLine{2512                 \textcolor{comment}{// K(2,3) += 0.5 * I * X(1,4) = 0.5 * I * CONJ(X(4,1)) (**HER**)}}
\DoxyCodeLine{2513                 AX\_Grad\_loc[iMat][b2]           += 0.5 * \mbox{\hyperlink{namespaceChronusQ_afe3e41cf782d225ede67d9450e48aa34}{SmartConj}}(gradList[iMat].\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa02129bb861061d1a052c592e2dc6b383}{X}}[bf4+nBasis*bf1]) * intBuffer\_Grad\_loc[ijkl];}
\DoxyCodeLine{2514 }
\DoxyCodeLine{2515               \} \textcolor{comment}{// l loop}}
\DoxyCodeLine{2516               \} \textcolor{comment}{// ijk}}
\DoxyCodeLine{2517             \} \textcolor{comment}{// EXCHANGE}}
\DoxyCodeLine{2518 }
\DoxyCodeLine{2519           \textcolor{comment}{// Nonhermitian}}
\DoxyCodeLine{2520           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2521             \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}Nonhermetian NYI!"{}});}
\DoxyCodeLine{2522 }
\DoxyCodeLine{2523           \} \textcolor{comment}{// Symmetry}}
\DoxyCodeLine{2524 }
\DoxyCodeLine{2525         \} \textcolor{comment}{// Matrices}}
\DoxyCodeLine{2526 }
\DoxyCodeLine{2527 }
\DoxyCodeLine{2528         \} \textcolor{comment}{// Gradient components}}
\DoxyCodeLine{2529 }
\DoxyCodeLine{2530       \} \textcolor{comment}{// s4}}
\DoxyCodeLine{2531       \} \textcolor{comment}{// s3}}
\DoxyCodeLine{2532 }
\DoxyCodeLine{2533     \} \textcolor{comment}{// s2}}
\DoxyCodeLine{2534     \} \textcolor{comment}{// s1}}
\DoxyCodeLine{2535     }
\DoxyCodeLine{2536     \} \textcolor{comment}{// omp parallel}}
\DoxyCodeLine{2537 }
\DoxyCodeLine{2538     MatsT* SCR = memManager\_.malloc<MatsT>(nBasis * nBasis);}
\DoxyCodeLine{2539     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} iGrad = 0; iGrad < nTotGrad; iGrad++ )}
\DoxyCodeLine{2540     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} iMat = 0; iMat < nMat;  iMat++ ) }
\DoxyCodeLine{2541     \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} iTh  = 0; iTh < nThreads; iTh++) \{}
\DoxyCodeLine{2542 }
\DoxyCodeLine{2543       \textcolor{keywordflow}{if}( cList[iGrad][iMat].HER ) \{}
\DoxyCodeLine{2544 }
\DoxyCodeLine{2545         \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'C'},nBasis,nBasis,MatsT(0.5),AXthreads[iTh][iGrad][iMat],}
\DoxyCodeLine{2546           nBasis,MatsT(0.5),AXthreads[iTh][iGrad][iMat],nBasis,SCR,nBasis);}
\DoxyCodeLine{2547 }
\DoxyCodeLine{2548         \textcolor{keywordflow}{if}( nThreads != 1 )}
\DoxyCodeLine{2549           \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'N'},nBasis,nBasis,MatsT(1.),SCR,nBasis,MatsT(1.), cList[iGrad][iMat].AX,nBasis,cList[iGrad][iMat].AX,nBasis);}
\DoxyCodeLine{2550         \textcolor{keywordflow}{else}}
\DoxyCodeLine{2551           \mbox{\hyperlink{namespaceChronusQ_ae8f5db3509402cc0920cf103d5fb9952}{SetMat}}(\textcolor{charliteral}{'N'},nBasis,nBasis,MatsT(1.),SCR,nBasis,cList[iGrad][iMat].AX,nBasis);}
\DoxyCodeLine{2552 }
\DoxyCodeLine{2553       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2554 }
\DoxyCodeLine{2555         \textcolor{keywordflow}{if}( nThreads != 1 )}
\DoxyCodeLine{2556           \mbox{\hyperlink{namespaceChronusQ_ac389ba57a99d66c5b26de24a6a58aebb}{MatAdd}}(\textcolor{charliteral}{'N'},\textcolor{charliteral}{'N'},nBasis,nBasis,MatsT(0.5),AXthreads[iTh][iGrad][iMat],nBasis,}
\DoxyCodeLine{2557             MatsT(1.), cList[iGrad][iMat].AX,nBasis,cList[iGrad][iMat].AX,nBasis);}
\DoxyCodeLine{2558         \textcolor{keywordflow}{else} }
\DoxyCodeLine{2559           blas::scal(nBasis*nBasis,MatsT(0.5),cList[iGrad][iMat].AX,1);}
\DoxyCodeLine{2560 }
\DoxyCodeLine{2561       \}}
\DoxyCodeLine{2562 }
\DoxyCodeLine{2563     \};}
\DoxyCodeLine{2564     memManager\_.free(SCR);}
\DoxyCodeLine{2565 }
\DoxyCodeLine{2566     memManager\_.free(intBuffer);}
\DoxyCodeLine{2567     \textcolor{keywordflow}{if}(AXRaw != \textcolor{keyword}{nullptr}) memManager\_.free(AXRaw);}
\DoxyCodeLine{2568     \textcolor{comment}{// Turn threads for LA back on}}
\DoxyCodeLine{2569     \mbox{\hyperlink{namespaceChronusQ_a7b13ac1d1109f4a015feaab04cb3eaee}{SetLAThreads}}(LAThreads);}
\DoxyCodeLine{2570 }
\DoxyCodeLine{2571   \}}
\DoxyCodeLine{2572 }
\DoxyCodeLine{2573 \}; \textcolor{comment}{// namespace ChronusQ}}
\DoxyCodeLine{2574 }

\end{DoxyCode}
