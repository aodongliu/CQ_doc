\hypertarget{gplhr_8hpp_source}{}\doxysection{gplhr.\+hpp}
\label{gplhr_8hpp_source}\index{include/itersolver/gplhr.hpp@{include/itersolver/gplhr.hpp}}
\mbox{\hyperlink{gplhr_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/* }}
\DoxyCodeLine{2 \textcolor{comment}{ *  This file is part of the Chronus Quantum (ChronusQ) software package}}
\DoxyCodeLine{3 \textcolor{comment}{ *  }}
\DoxyCodeLine{4 \textcolor{comment}{ *  Copyright (C) 2014-\/2022 Li Research Group (University of Washington)}}
\DoxyCodeLine{5 \textcolor{comment}{ *  }}
\DoxyCodeLine{6 \textcolor{comment}{ *  This program is free software; you can redistribute it and/or modify}}
\DoxyCodeLine{7 \textcolor{comment}{ *  it under the terms of the GNU General Public License as published by}}
\DoxyCodeLine{8 \textcolor{comment}{ *  the Free Software Foundation; either version 2 of the License, or}}
\DoxyCodeLine{9 \textcolor{comment}{ *  (at your option) any later version.}}
\DoxyCodeLine{10 \textcolor{comment}{ *  }}
\DoxyCodeLine{11 \textcolor{comment}{ *  This program is distributed in the hope that it will be useful,}}
\DoxyCodeLine{12 \textcolor{comment}{ *  but WITHOUT ANY WARRANTY; without even the implied warranty of}}
\DoxyCodeLine{13 \textcolor{comment}{ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}}
\DoxyCodeLine{14 \textcolor{comment}{ *  GNU General Public License for more details.}}
\DoxyCodeLine{15 \textcolor{comment}{ *  }}
\DoxyCodeLine{16 \textcolor{comment}{ *  You should have received a copy of the GNU General Public License along}}
\DoxyCodeLine{17 \textcolor{comment}{ *  with this program; if not, write to the Free Software Foundation, Inc.,}}
\DoxyCodeLine{18 \textcolor{comment}{ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-\/1301 USA.}}
\DoxyCodeLine{19 \textcolor{comment}{ *  }}
\DoxyCodeLine{20 \textcolor{comment}{ *  Contact the Developers:}}
\DoxyCodeLine{21 \textcolor{comment}{ *    E-\/Mail: xsli@uw.edu}}
\DoxyCodeLine{22 \textcolor{comment}{ *  }}
\DoxyCodeLine{23 \textcolor{comment}{ */}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{itersolver_8hpp}{itersolver.hpp}}>}}
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{timer_8hpp}{util/timer.hpp}}>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{matout_8hpp}{util/matout.hpp}}>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{factorization_8hpp}{cqlinalg/factorization.hpp}}>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{blas3_8hpp}{cqlinalg/blas3.hpp}}>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{eig_8hpp}{cqlinalg/eig.hpp}}>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{cqlinalg_8hpp}{cqlinalg.hpp}}>}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{cerr_8hpp}{cerr.hpp}}>}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceChronusQ}{ChronusQ}} \{}
\DoxyCodeLine{36 }
\DoxyCodeLine{37 }
\DoxyCodeLine{38   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{39   \textcolor{keywordtype}{bool} \mbox{\hyperlink{classChronusQ_1_1GPLHR_a5ec192cb9058ecf42cbe643e510a8f84}{GPLHR<\_F>::runMicro}}() \{}
\DoxyCodeLine{40 }
\DoxyCodeLine{41 }
\DoxyCodeLine{42     \textcolor{keywordtype}{bool} isRoot = \mbox{\hyperlink{namespaceChronusQ_ac9433164d43ee9f6f0c49e49698f680f}{MPIRank}}(this-\/>comm\_) == 0;}
\DoxyCodeLine{43     \textcolor{keywordtype}{bool} isConverged = \textcolor{keyword}{false};}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 }
\DoxyCodeLine{46     \textcolor{keywordflow}{if}( isRoot ) \{}
\DoxyCodeLine{47       std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{48       std::cout << \textcolor{stringliteral}{"{}  * GPLHR Settings\(\backslash\)n"{}}}
\DoxyCodeLine{49                 << \textcolor{stringliteral}{"{}    * Sigma                        = "{}} << std::real(sigma) << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{50                 << \textcolor{stringliteral}{"{}    * Min                          = "{}} << std::real(hardLim) << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{51                 << \textcolor{stringliteral}{"{}    * Kyrlov-\/Arnoldi Parameter (M) = "{}} << this-\/>m}
\DoxyCodeLine{52                 << std::endl;}
\DoxyCodeLine{53 }
\DoxyCodeLine{54 }
\DoxyCodeLine{55       std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{56     \}}
\DoxyCodeLine{57     }
\DoxyCodeLine{58     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} N = this-\/>N\_;}
\DoxyCodeLine{59     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} MSS = this-\/>mSS\_;}
\DoxyCodeLine{60     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nR = this-\/>nRoots\_;}
\DoxyCodeLine{61 }
\DoxyCodeLine{62 }
\DoxyCodeLine{63     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} MSS2 = MSS * MSS;}
\DoxyCodeLine{64     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NMSS = N * MSS;}
\DoxyCodeLine{65     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NNR  = N * nR;}
\DoxyCodeLine{66     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} M\_NR = this-\/>m * nR;}
\DoxyCodeLine{67 }
\DoxyCodeLine{68 }
\DoxyCodeLine{69     \textcolor{comment}{// FIXME Reassign sigma (TEMP)}}
\DoxyCodeLine{70     \textcolor{keywordflow}{if}( std::imag(sigma) > 1e-\/10 )}
\DoxyCodeLine{71       \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}GPLHR Only Supports Real Sigma for the Time Being"{}},std::cout);}
\DoxyCodeLine{72     \textcolor{keywordtype}{double} sigmaD   = std::real(sigma);}
\DoxyCodeLine{73     \textcolor{keywordtype}{double} hardLimD = std::real(hardLim);}
\DoxyCodeLine{74     \textcolor{comment}{//sigmaD = hardLimD;}}
\DoxyCodeLine{75 }
\DoxyCodeLine{76 }
\DoxyCodeLine{77     \textcolor{comment}{// Initialize pointers}}
\DoxyCodeLine{78     std::shared\_ptr<SolverVectors<\_F>> V = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{79     std::shared\_ptr<SolverVectors<\_F>> W = nullptr , \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}} = nullptr , P = nullptr ;}
\DoxyCodeLine{80     std::shared\_ptr<SolverVectors<\_F>> AV = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{81     std::shared\_ptr<SolverVectors<\_F>> AW = \textcolor{keyword}{nullptr}, AS = \textcolor{keyword}{nullptr}, AP = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{82     std::shared\_ptr<SolverVectors<\_F>> Q = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{83     std::shared\_ptr<SolverVectors<\_F>> Qp = \textcolor{keyword}{nullptr}, Q1 = \textcolor{keyword}{nullptr}, Q2 = \textcolor{keyword}{nullptr},}
\DoxyCodeLine{84        Q3\_p = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{85 }
\DoxyCodeLine{86 }
\DoxyCodeLine{87     \_F *BETA = \textcolor{keyword}{nullptr}; \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} *ALPHA = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{88     \_F *RMAT = \textcolor{keyword}{nullptr}, *PHI = \textcolor{keyword}{nullptr}, *PSI = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{89     \_F *VSR  = \textcolor{keyword}{nullptr}, *VSL = \textcolor{keyword}{nullptr}, *MA  = \textcolor{keyword}{nullptr}, *MB = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{90     std::shared\_ptr<SolverVectors<\_F>> VSCR = \textcolor{keyword}{nullptr}, VSCR2 = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{91 }
\DoxyCodeLine{92       \textcolor{comment}{// V  = [V W S1...Sm P]}}
\DoxyCodeLine{93 \textcolor{comment}{//      V = this-\/>memManager\_.template malloc<\_F>(NMSS);}}
\DoxyCodeLine{94       V = this-\/>vecGen\_(MSS);}
\DoxyCodeLine{95       W = std::make\_shared<SolverVectorsView<\_F>>(*V, nR);}
\DoxyCodeLine{96       \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}} = std::make\_shared<SolverVectorsView<\_F>>(*W, nR);}
\DoxyCodeLine{97       P = std::make\_shared<SolverVectorsView<\_F>>(*\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}, this-\/>m * nR);}
\DoxyCodeLine{98 }
\DoxyCodeLine{99       \textcolor{comment}{// AV = [AV AW AS1...ASm AP]}}
\DoxyCodeLine{100       AV = this-\/>vecGen\_(MSS);}
\DoxyCodeLine{101       AW = std::make\_shared<SolverVectorsView<\_F>>(*AV, nR);}
\DoxyCodeLine{102       AS = std::make\_shared<SolverVectorsView<\_F>>(*AW, nR);}
\DoxyCodeLine{103       AP = std::make\_shared<SolverVectorsView<\_F>>(*AS, this-\/>m * nR);}
\DoxyCodeLine{104 }
\DoxyCodeLine{105 }
\DoxyCodeLine{106       \textcolor{comment}{// Q = [Q Q1 Q2 Q3]}}
\DoxyCodeLine{107       Q = this-\/>vecGen\_(MSS);}
\DoxyCodeLine{108       Qp = std::make\_shared<SolverVectorsView<\_F>>(*Q, nR);}
\DoxyCodeLine{109 }
\DoxyCodeLine{110       Q1   = std::make\_shared<SolverVectorsView<\_F>>(*Qp);}
\DoxyCodeLine{111       Q2   = std::make\_shared<SolverVectorsView<\_F>>(*Q1, nR);}
\DoxyCodeLine{112       Q3\_p = std::make\_shared<SolverVectorsView<\_F>>(*Q2, this-\/>m * nR);}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 }
\DoxyCodeLine{115 }
\DoxyCodeLine{116 }
\DoxyCodeLine{117 }
\DoxyCodeLine{118 \textcolor{comment}{//      if( isRoot ) \{}}
\DoxyCodeLine{119 }
\DoxyCodeLine{120       \textcolor{comment}{// EVAL(I) = ALPHA(I) / BETA(I)}}
\DoxyCodeLine{121       ALPHA = this-\/>memManager\_.template malloc<dcomplex>(MSS);}
\DoxyCodeLine{122       BETA  = this-\/>memManager\_.template malloc<\_F>(MSS);}
\DoxyCodeLine{123       \textcolor{comment}{//double *RITZ  = this-\/>memManager\_.template malloc<double>(MSS);}}
\DoxyCodeLine{124       \textcolor{comment}{//double *nRITZ = this-\/>memManager\_.template malloc<double>(nR);}}
\DoxyCodeLine{125 }
\DoxyCodeLine{126       RMAT = this-\/>memManager\_.template malloc<\_F>(MSS2); }
\DoxyCodeLine{127       PHI  = this-\/>memManager\_.template malloc<\_F>(MSS2); }
\DoxyCodeLine{128       PSI  = this-\/>memManager\_.template malloc<\_F>(MSS2); }
\DoxyCodeLine{129 }
\DoxyCodeLine{130       VSR = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{131       VSL = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{132       MA  = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{133       MB  = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{134 }
\DoxyCodeLine{135 \textcolor{comment}{//    \} // ROOT only}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 }
\DoxyCodeLine{138 }
\DoxyCodeLine{139 }
\DoxyCodeLine{140 }
\DoxyCodeLine{141 }
\DoxyCodeLine{142     \textcolor{comment}{// Need a NNR scratch on all processes}}
\DoxyCodeLine{143     VSCR  = this-\/>vecGen\_(nR);}
\DoxyCodeLine{144     VSCR2 = this-\/>vecGen\_(nR);}
\DoxyCodeLine{145 }
\DoxyCodeLine{146 }
\DoxyCodeLine{147 }
\DoxyCodeLine{148 }
\DoxyCodeLine{149 }
\DoxyCodeLine{150 }
\DoxyCodeLine{151 }
\DoxyCodeLine{152 }
\DoxyCodeLine{153 \textcolor{comment}{//    if( isRoot ) \{}}
\DoxyCodeLine{154 }
\DoxyCodeLine{155       \textcolor{comment}{// Initailize V as Guess, if no Guess set, init to identity}}
\DoxyCodeLine{156       \textcolor{keywordflow}{if}( Guess ) V-\/>set\_data(0, nR, *Guess, 0);}
\DoxyCodeLine{157       \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{158         V-\/>clear();}
\DoxyCodeLine{159         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul; i < nR; i++) V-\/>set(i, i, 1.0);}
\DoxyCodeLine{160       \}}
\DoxyCodeLine{161 }
\DoxyCodeLine{162 }
\DoxyCodeLine{163       \textcolor{comment}{// V <-\/ QR(V)}}
\DoxyCodeLine{164       V-\/>QR(0, nR, this-\/>memManager\_);}
\DoxyCodeLine{165 }
\DoxyCodeLine{166 \textcolor{comment}{//    \} // ROOT only}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168 }
\DoxyCodeLine{169 }
\DoxyCodeLine{170 }
\DoxyCodeLine{171 }
\DoxyCodeLine{172     \textcolor{comment}{// Sync processes}}
\DoxyCodeLine{173     \mbox{\hyperlink{namespaceChronusQ_a23c2e4eb26f9455d90831342328f3b91}{MPI\_Barrier}}(this-\/>comm\_);}
\DoxyCodeLine{174 }
\DoxyCodeLine{175 }
\DoxyCodeLine{176     std::shared\_ptr<SolverVectors<\_F>> VSend  = V;}
\DoxyCodeLine{177     std::shared\_ptr<SolverVectors<\_F>> AVRecv = AV;}
\DoxyCodeLine{178 }
\DoxyCodeLine{179 }
\DoxyCodeLine{180     \textcolor{comment}{// AV <-\/ A * V}}
\DoxyCodeLine{181     this-\/>linearTrans\_(nR, *VSend, *AVRecv);}
\DoxyCodeLine{182 }
\DoxyCodeLine{183     \textcolor{comment}{// Sync processes}}
\DoxyCodeLine{184     \mbox{\hyperlink{namespaceChronusQ_a23c2e4eb26f9455d90831342328f3b91}{MPI\_Barrier}}(this-\/>comm\_);}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 }
\DoxyCodeLine{187 }
\DoxyCodeLine{188 }
\DoxyCodeLine{189 }
\DoxyCodeLine{190     \textcolor{keywordtype}{double} nrmA = 0.;}
\DoxyCodeLine{191 }
\DoxyCodeLine{192 \textcolor{comment}{//    if( isRoot ) \{}}
\DoxyCodeLine{193 }
\DoxyCodeLine{194 }
\DoxyCodeLine{195       \textcolor{comment}{// Q <-\/ AV -\/ sig * V}}
\DoxyCodeLine{196       Q-\/>set\_data(0, nR, *AV, 0);}
\DoxyCodeLine{197       Q-\/>axpy(0, nR, -\/sigma, *V, 0);}
\DoxyCodeLine{198 }
\DoxyCodeLine{199       \textcolor{comment}{// Q <-\/ QR(Q)}}
\DoxyCodeLine{200       Q-\/>QR(0, nR, this-\/>memManager\_);}
\DoxyCodeLine{201         }
\DoxyCodeLine{202 }
\DoxyCodeLine{203 }
\DoxyCodeLine{204 }
\DoxyCodeLine{205       \textcolor{comment}{// PHI <-\/ Q**H * AV}}
\DoxyCodeLine{206       \textcolor{comment}{// PSI <-\/ Q**H * V}}
\DoxyCodeLine{207       Q-\/>dot\_product(0, *AV, 0, nR,nR,PHI,nR);}
\DoxyCodeLine{208       Q-\/>dot\_product(0, *V, 0, nR,nR,PSI,nR);}
\DoxyCodeLine{209 }
\DoxyCodeLine{210 }
\DoxyCodeLine{211 }
\DoxyCodeLine{212       \textcolor{comment}{// VSR, VSL, ALPHA, BETA <-\/ ORDQZ(PHI,PSI,sigma)}}
\DoxyCodeLine{213       \mbox{\hyperlink{namespaceChronusQ_a2ceeb21fc9097d04ef6c4214d831b173}{OrdQZ2}}(\textcolor{charliteral}{'V'},\textcolor{charliteral}{'V'},nR,PHI,nR,PSI,nR,ALPHA,BETA,hardLimD,sigmaD,}
\DoxyCodeLine{214              VSL,nR,VSR,nR,this-\/>memManager\_);}
\DoxyCodeLine{215 }
\DoxyCodeLine{216 }
\DoxyCodeLine{217       \textcolor{comment}{// Update eigs with ALPHA/BETA}}
\DoxyCodeLine{218       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0ul; i < nR; i++)}
\DoxyCodeLine{219         this-\/>eigVal\_[i] = ALPHA[i] / BETA[i];}
\DoxyCodeLine{220 }
\DoxyCodeLine{221       \textcolor{comment}{// Print warinings if needed}}
\DoxyCodeLine{222       \textcolor{keywordflow}{if}( std::is\_same<double, \_F>::value ) \{}
\DoxyCodeLine{223 }
\DoxyCodeLine{224         \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} i = 0ul; i < nR; i++ )}
\DoxyCodeLine{225           \textcolor{keywordflow}{if}( std::abs(std::imag(this-\/>eigVal\_[i])) > 1e-\/10 )}
\DoxyCodeLine{226             std::cout << \textcolor{stringliteral}{"{}  *** WARNING: INTERMEDIATE COMPLEX EIGENVALUE "{}}}
\DoxyCodeLine{227                       << \textcolor{stringliteral}{"{}INCURRED ***"{}} << std::endl;}
\DoxyCodeLine{228 }
\DoxyCodeLine{229       \}}
\DoxyCodeLine{230 }
\DoxyCodeLine{231       \textcolor{comment}{/*}}
\DoxyCodeLine{232 \textcolor{comment}{      // Adaptive sigma}}
\DoxyCodeLine{233 \textcolor{comment}{      double limDiff = std::numeric\_limits<double>::infinity();}}
\DoxyCodeLine{234 \textcolor{comment}{      double omega0 = 0.;}}
\DoxyCodeLine{235 \textcolor{comment}{      double midPt = 0.;}}
\DoxyCodeLine{236 \textcolor{comment}{      bool belowTh = false;}}
\DoxyCodeLine{237 \textcolor{comment}{      double maxW = -\/std::numeric\_limits<double>::infinity();}}
\DoxyCodeLine{238 \textcolor{comment}{      */}}
\DoxyCodeLine{239 }
\DoxyCodeLine{240 }
\DoxyCodeLine{241       \textcolor{comment}{// Get MA and MB ('Q-\/free' Schur form)}}
\DoxyCodeLine{242       getTriU(nR,PHI,nR,PSI,nR,MA,nR,MB,nR);}
\DoxyCodeLine{243 }
\DoxyCodeLine{244 }
\DoxyCodeLine{245       \textcolor{comment}{// Right and Left Schur Vectors}}
\DoxyCodeLine{246       \textcolor{comment}{// VR  <-\/ VR  * VSR}}
\DoxyCodeLine{247       \textcolor{comment}{// VL  <-\/ VL  * VSL}}
\DoxyCodeLine{248       \textcolor{comment}{// AVR <-\/ AVR * VSR}}
\DoxyCodeLine{249       V-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),VSR,nR,\_F(0.),*VSCR, 0);}
\DoxyCodeLine{250       V-\/>set\_data(0, nR, *VSCR, 0);}
\DoxyCodeLine{251       }
\DoxyCodeLine{252       Q-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),VSL,nR,\_F(0.),*VSCR, 0);}
\DoxyCodeLine{253       Q-\/>set\_data(0, nR, *VSCR, 0);}
\DoxyCodeLine{254       }
\DoxyCodeLine{255       AV-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),VSR,nR,\_F(0.),*VSCR, 0);}
\DoxyCodeLine{256       AV-\/>set\_data(0, nR, *VSCR, 0);}
\DoxyCodeLine{257 }
\DoxyCodeLine{258       \textcolor{comment}{// Form initial residuals in W}}
\DoxyCodeLine{259       \textcolor{comment}{// W = AV * MB -\/ V * MA}}
\DoxyCodeLine{260       AV-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),MB,nR,\_F(0.),*W, 0);}
\DoxyCodeLine{261       V-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(-\/1.),MA,nR,\_F(1.),*W, 0);}
\DoxyCodeLine{262 }
\DoxyCodeLine{263 }
\DoxyCodeLine{264       \textcolor{comment}{// Get Residual Norms}}
\DoxyCodeLine{265       nrmA = AV-\/>norm2F(0, nR);}
\DoxyCodeLine{266       getResidualNorms(N,nR,*W,RelRes,this-\/>eigVal\_,nrmA);}
\DoxyCodeLine{267 }
\DoxyCodeLine{268 }
\DoxyCodeLine{269 }
\DoxyCodeLine{270 }
\DoxyCodeLine{271       std::cout << \textcolor{stringliteral}{"{}  * Initial Matrix Norm Estimate = "{}} << nrmA << std::endl;}
\DoxyCodeLine{272 }
\DoxyCodeLine{273       std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n  * Initial Eigenvalues\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{274       std::cout << std::setprecision(10) << std::scientific;}
\DoxyCodeLine{275       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iRt = 0ul; iRt < nR; iRt++) \{}
\DoxyCodeLine{276 }
\DoxyCodeLine{277         std::cout << \textcolor{stringliteral}{"{}    IRt = "{}} << std::setw(5) << std::left << iRt;}
\DoxyCodeLine{278 }
\DoxyCodeLine{279         std::cout << std::right;}
\DoxyCodeLine{280         \textcolor{keywordflow}{if}( std::is\_same<double, \_F>::value ) std::cout << \textcolor{stringliteral}{"{}EigVal = "{}}; }
\DoxyCodeLine{281         \textcolor{keywordflow}{else}                                  std::cout << \textcolor{stringliteral}{"{}Re(EigVal) = "{}};}
\DoxyCodeLine{282 }
\DoxyCodeLine{283 }
\DoxyCodeLine{284         std::cout << std::setw(20) << std::real(this-\/>eigVal\_[iRt]);}
\DoxyCodeLine{285 }
\DoxyCodeLine{286         \textcolor{keywordflow}{if}( std::is\_same<dcomplex,\_F>::value ) \{}
\DoxyCodeLine{287           std::cout << \textcolor{stringliteral}{"{}    Im(EigVal) = "{}};}
\DoxyCodeLine{288           std::cout << std::setw(20) << std::imag(this-\/>eigVal\_[iRt]);}
\DoxyCodeLine{289         \}}
\DoxyCodeLine{290 }
\DoxyCodeLine{291 }
\DoxyCodeLine{292         std::cout << \textcolor{stringliteral}{"{}    RelResNorm = "{}};}
\DoxyCodeLine{293         std::cout << std::setw(20) << RelRes[iRt];}
\DoxyCodeLine{294 }
\DoxyCodeLine{295 }
\DoxyCodeLine{296         std::cout << std::endl;}
\DoxyCodeLine{297       \}}
\DoxyCodeLine{298 }
\DoxyCodeLine{299 }
\DoxyCodeLine{300       std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{301 }
\DoxyCodeLine{302       std::cout << \textcolor{stringliteral}{"{}  * Starting GPLHR Iterations\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{303 }
\DoxyCodeLine{304 }
\DoxyCodeLine{305 }
\DoxyCodeLine{306 \textcolor{comment}{//    \} // ROOT only}}
\DoxyCodeLine{307 }
\DoxyCodeLine{308     \textcolor{keywordtype}{size\_t} iter = 0;}
\DoxyCodeLine{309 }
\DoxyCodeLine{310     \textcolor{comment}{// ****************************}}
\DoxyCodeLine{311     \textcolor{comment}{// ** Begin GPLHR iterations **}}
\DoxyCodeLine{312     \textcolor{comment}{// ****************************}}
\DoxyCodeLine{313     \textcolor{keywordflow}{for}( iter = 0; iter < this-\/>maxMicroIter\_; iter++ ) \{}
\DoxyCodeLine{314 }
\DoxyCodeLine{315       \mbox{\hyperlink{classChronusQ_1_1ProgramTimer_a9a328014ee423173ec33b1afc29bda4a}{ProgramTimer::tick}}(\textcolor{stringliteral}{"{}Diagonalize Iter"{}});}
\DoxyCodeLine{316 }
\DoxyCodeLine{317 \textcolor{comment}{//      if( isRoot ) \{}}
\DoxyCodeLine{318 }
\DoxyCodeLine{319         std::cout << \textcolor{stringliteral}{"{}    GPLHRIter "{}} << std::setw(5) << iter+1;}
\DoxyCodeLine{320     }
\DoxyCodeLine{321         \textcolor{comment}{// V, RMAT <-\/ QR(V)}}
\DoxyCodeLine{322         V-\/>QR(0, nR, this-\/>memManager\_, RMAT, nR);}
\DoxyCodeLine{323 }
\DoxyCodeLine{324         \textcolor{comment}{// AV <-\/ X : [X * RMAT = AV]}}
\DoxyCodeLine{325         AV-\/>trsm(0, nR,\_F(1.),RMAT,nR);}
\DoxyCodeLine{326 }
\DoxyCodeLine{327         \textcolor{comment}{// Q <-\/ QR(Q)}}
\DoxyCodeLine{328         Q-\/>QR(0, nR, this-\/>memManager\_);}
\DoxyCodeLine{329 }
\DoxyCodeLine{330 }
\DoxyCodeLine{331         \textcolor{comment}{// W = (I -\/ V * V**H) * T * (I -\/ V * V**H) * W }}
\DoxyCodeLine{332         newSMatrix(nR,*V,*V,*W,RMAT,nR);}
\DoxyCodeLine{333 }
\DoxyCodeLine{334         \textcolor{comment}{// W <-\/ QR(W)}}
\DoxyCodeLine{335         W-\/>QR(0, nR, this-\/>memManager\_);}
\DoxyCodeLine{336 }
\DoxyCodeLine{337 \textcolor{comment}{//      \} // ROOT only}}
\DoxyCodeLine{338 }
\DoxyCodeLine{339 }
\DoxyCodeLine{340       \textcolor{comment}{// Sync processes}}
\DoxyCodeLine{341       \mbox{\hyperlink{namespaceChronusQ_a23c2e4eb26f9455d90831342328f3b91}{MPI\_Barrier}}(this-\/>comm\_);}
\DoxyCodeLine{342 }
\DoxyCodeLine{343       \textcolor{comment}{// AW <-\/ A * W}}
\DoxyCodeLine{344       \textcolor{keyword}{auto} LTst = \mbox{\hyperlink{namespaceChronusQ_a715f671201f0f6e77216fcf1f72adbaf}{tick}}();}
\DoxyCodeLine{345 }
\DoxyCodeLine{346       std::shared\_ptr<SolverVectors<\_F>> WSend  = W;}
\DoxyCodeLine{347       std::shared\_ptr<SolverVectors<\_F>> AWRecv = AW;}
\DoxyCodeLine{348 }
\DoxyCodeLine{349       this-\/>linearTrans\_(nR, *WSend, *AWRecv);}
\DoxyCodeLine{350 }
\DoxyCodeLine{351 }
\DoxyCodeLine{352       \textcolor{keywordtype}{double} LTdur = \mbox{\hyperlink{namespaceChronusQ_a3b2153e93af4532ff5b1e75d8af453b0}{tock}}(LTst);}
\DoxyCodeLine{353 }
\DoxyCodeLine{354       \textcolor{comment}{// Sync processes}}
\DoxyCodeLine{355       \mbox{\hyperlink{namespaceChronusQ_a23c2e4eb26f9455d90831342328f3b91}{MPI\_Barrier}}(this-\/>comm\_);}
\DoxyCodeLine{356     }
\DoxyCodeLine{357 }
\DoxyCodeLine{358       \textcolor{comment}{// Form S-\/blocks}}
\DoxyCodeLine{359         }
\DoxyCodeLine{360       \textcolor{comment}{// S(0) = W, AS(0) = AW}}
\DoxyCodeLine{361       \textcolor{keywordflow}{for}( \textcolor{keyword}{auto} k = 1; k <= this-\/>m; k++ ) \{}
\DoxyCodeLine{362 }
\DoxyCodeLine{363         std::shared\_ptr<SolverVectors<\_F>> SSend = \textcolor{keyword}{nullptr}, ASRecv = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{364 }
\DoxyCodeLine{365         \textcolor{comment}{// S(k-\/1) / AS(k-\/1)}}
\DoxyCodeLine{366         std::shared\_ptr<SolverVectors<\_F>> Sprev  = std::make\_shared<SolverVectorsView<\_F>>(*W, (k -\/ 1) * nR);}
\DoxyCodeLine{367         std::shared\_ptr<SolverVectors<\_F>> ASprev = std::make\_shared<SolverVectorsView<\_F>>(*AW, (k -\/ 1) * nR);}
\DoxyCodeLine{368 }
\DoxyCodeLine{369         \textcolor{comment}{// S(k) / AS(k)}}
\DoxyCodeLine{370         std::shared\_ptr<SolverVectors<\_F>> Scur  = std::make\_shared<SolverVectorsView<\_F>>(*W, k * nR);}
\DoxyCodeLine{371         std::shared\_ptr<SolverVectors<\_F>> AScur = std::make\_shared<SolverVectorsView<\_F>>(*AW, k * nR);}
\DoxyCodeLine{372 }
\DoxyCodeLine{373         SSend  = Scur;}
\DoxyCodeLine{374         ASRecv = AScur;}
\DoxyCodeLine{375 }
\DoxyCodeLine{376 }
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \textcolor{comment}{//        if( isRoot ) \{}}
\DoxyCodeLine{379           \textcolor{comment}{// S(k) = AS(k-\/1) * MB -\/ S(k-\/1) * MA}}
\DoxyCodeLine{380           ASprev-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.) ,MB,nR,\_F(0.),*Scur, 0);}
\DoxyCodeLine{381           Sprev-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(-\/1.),MA,nR,\_F(1.),*Scur, 0);}
\DoxyCodeLine{382 }
\DoxyCodeLine{383           \textcolor{comment}{// S(k) = (I -\/ V * V**H) * T * (I -\/ V * V**H) * S(k-\/1) }}
\DoxyCodeLine{384           newSMatrix(nR,*V,*V,*Scur,RMAT,nR);}
\DoxyCodeLine{385 }
\DoxyCodeLine{386 }
\DoxyCodeLine{387           \textcolor{comment}{// Project out previous S's}}
\DoxyCodeLine{388           \textcolor{comment}{// S(k) = (I -\/ S(l) * S(l)**H) * S(k)  for l = [0,k)}}
\DoxyCodeLine{389           \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} l = 0; l < k; l++) }
\DoxyCodeLine{390             halfProj(nR, \mbox{\hyperlink{classChronusQ_1_1SolverVectorsView}{SolverVectorsView<\_F>}}(*W, l * nR), *Scur, RMAT, nR);}
\DoxyCodeLine{391        }
\DoxyCodeLine{392 }
\DoxyCodeLine{393           \textcolor{comment}{// S(k) = QR(S(k))}}
\DoxyCodeLine{394           Scur-\/>QR(0, nR, this-\/>memManager\_);}
\DoxyCodeLine{395 }
\DoxyCodeLine{396 \textcolor{comment}{//        \}}}
\DoxyCodeLine{397 }
\DoxyCodeLine{398 }
\DoxyCodeLine{399 }
\DoxyCodeLine{400         \textcolor{comment}{// Sync processes}}
\DoxyCodeLine{401         \mbox{\hyperlink{namespaceChronusQ_a23c2e4eb26f9455d90831342328f3b91}{MPI\_Barrier}}(this-\/>comm\_);}
\DoxyCodeLine{402 }
\DoxyCodeLine{403         \textcolor{comment}{// AS(k) = A * S(k) }}
\DoxyCodeLine{404         LTst = \mbox{\hyperlink{namespaceChronusQ_a715f671201f0f6e77216fcf1f72adbaf}{tick}}();}
\DoxyCodeLine{405 }
\DoxyCodeLine{406         this-\/>linearTrans\_(nR, *SSend, *ASRecv);}
\DoxyCodeLine{407 }
\DoxyCodeLine{408         LTdur += \mbox{\hyperlink{namespaceChronusQ_a3b2153e93af4532ff5b1e75d8af453b0}{tock}}(LTst);}
\DoxyCodeLine{409 }
\DoxyCodeLine{410         \textcolor{comment}{// Sync processes}}
\DoxyCodeLine{411         \mbox{\hyperlink{namespaceChronusQ_a23c2e4eb26f9455d90831342328f3b91}{MPI\_Barrier}}(this-\/>comm\_);}
\DoxyCodeLine{412 }
\DoxyCodeLine{413       \}}
\DoxyCodeLine{414 }
\DoxyCodeLine{415 }
\DoxyCodeLine{416 }
\DoxyCodeLine{417 }
\DoxyCodeLine{418       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nQp = iter ? 2 + this-\/>m : 1 + this-\/>m;}
\DoxyCodeLine{419       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nQ  = nQp + 1;}
\DoxyCodeLine{420 }
\DoxyCodeLine{421 \textcolor{comment}{//      if( isRoot ) \{}}
\DoxyCodeLine{422 }
\DoxyCodeLine{423         \textcolor{comment}{// Conjugate direction orthogonalization}}
\DoxyCodeLine{424         \textcolor{keywordflow}{if} (iter) \{}
\DoxyCodeLine{425           }
\DoxyCodeLine{426           \textcolor{comment}{// P = (I -\/ V * V**H) * P}}
\DoxyCodeLine{427           \textcolor{comment}{// P = (I -\/ W * W**H) * P}}
\DoxyCodeLine{428           \textcolor{comment}{// P = (I -\/ S * S**H) * P}}
\DoxyCodeLine{429           halfProj2(     nR,*V,*AV,*P,*AP,RMAT,nR  ); \textcolor{comment}{// Project out V}}
\DoxyCodeLine{430           halfProj2(     nR,*W,*AW,*P,*AP,RMAT,nR  ); \textcolor{comment}{// Project out W}}
\DoxyCodeLine{431           halfProj2(M\_NR,nR,*\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}},*AS,*P,*AP,RMAT,M\_NR); \textcolor{comment}{// Project out S}}
\DoxyCodeLine{432 }
\DoxyCodeLine{433           \textcolor{comment}{// P, RMAT <-\/ QR(P)}}
\DoxyCodeLine{434           P-\/>QR(0, nR, this-\/>memManager\_, RMAT, nR);}
\DoxyCodeLine{435 }
\DoxyCodeLine{436           \textcolor{comment}{// AP <-\/ X : [X * RMAT = AP]}}
\DoxyCodeLine{437           AP-\/>trsm(0, nR,\_F(1.),RMAT,nR);}
\DoxyCodeLine{438 }
\DoxyCodeLine{439         \}}
\DoxyCodeLine{440 }
\DoxyCodeLine{441         std::shared\_ptr<SolverVectors<\_F>> Q3 = iter ? Q3\_p : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{442 }
\DoxyCodeLine{443         \textcolor{comment}{// Q' = (A -\/ sigma * I) [W, S, [P]]}}
\DoxyCodeLine{444         Qp-\/>set\_data(0, nQp*nR, *AW, 0);}
\DoxyCodeLine{445         Qp-\/>axpy(0, nQp * nR, -\/sigma, *W, 0);}
\DoxyCodeLine{446 }
\DoxyCodeLine{447 }
\DoxyCodeLine{448 }
\DoxyCodeLine{449 }
\DoxyCodeLine{450         \textcolor{comment}{// Q1 = (I -\/ Q * Q**H) * Q1}}
\DoxyCodeLine{451         \textcolor{comment}{// Q1 = QR(Q1)}}
\DoxyCodeLine{452         halfProj(nR,*Q,*Q1,RMAT,nR);}
\DoxyCodeLine{453         Q1-\/>QR(0, nR, this-\/>memManager\_);}
\DoxyCodeLine{454 }
\DoxyCodeLine{455         \textcolor{comment}{// Q2 = (I -\/ Q  * Q**H ) * Q2}}
\DoxyCodeLine{456         \textcolor{comment}{// Q2 = (I -\/ Q1 * Q1**H) * Q2}}
\DoxyCodeLine{457         \textcolor{comment}{// Q2 = QR(Q2)}}
\DoxyCodeLine{458         halfProj(nR,M\_NR,*Q,*Q2,RMAT,nR);}
\DoxyCodeLine{459         halfProj(nR,M\_NR,*Q1,*Q2,RMAT,nR);}
\DoxyCodeLine{460         Q2-\/>QR(0, M\_NR, this-\/>memManager\_);}
\DoxyCodeLine{461 }
\DoxyCodeLine{462 }
\DoxyCodeLine{463         \textcolor{keywordflow}{if}( Q3 ) \{}
\DoxyCodeLine{464           \textcolor{comment}{// Q3 = (I -\/ Q  * Q**H ) * Q3}}
\DoxyCodeLine{465           \textcolor{comment}{// Q3 = (I -\/ Q1 * Q1**H) * Q3}}
\DoxyCodeLine{466           \textcolor{comment}{// Q3 = (I -\/ Q2 * Q2**H) * Q3}}
\DoxyCodeLine{467           \textcolor{comment}{// Q3 = QR(Q3)}}
\DoxyCodeLine{468           halfProj(nR,*Q,*Q3,RMAT,nR);}
\DoxyCodeLine{469           halfProj(nR,*Q1,*Q3,RMAT,nR);}
\DoxyCodeLine{470           halfProj(M\_NR,nR,*Q2,*Q3,RMAT,M\_NR);}
\DoxyCodeLine{471           Q3-\/>QR(0, nR, this-\/>memManager\_);}
\DoxyCodeLine{472         \}}
\DoxyCodeLine{473 }
\DoxyCodeLine{474 }
\DoxyCodeLine{475 }
\DoxyCodeLine{476         \textcolor{comment}{// PHI <-\/ Q**H * AV}}
\DoxyCodeLine{477         \textcolor{comment}{// PSI <-\/ Q**H * V}}
\DoxyCodeLine{478         Q-\/>dot\_product(0, *AV, 0, nQ*nR, nQ*nR, PHI, nQ*nR);}
\DoxyCodeLine{479         Q-\/>dot\_product(0, *V, 0, nQ*nR, nQ*nR, PSI, nQ*nR);}
\DoxyCodeLine{480 }
\DoxyCodeLine{481         \textcolor{comment}{// VSR, VSL, ALPHA, BETA <-\/ ORDQZ(PHI,PSI,sigma)}}
\DoxyCodeLine{482         \mbox{\hyperlink{namespaceChronusQ_a2ceeb21fc9097d04ef6c4214d831b173}{OrdQZ2}}(\textcolor{charliteral}{'V'},\textcolor{charliteral}{'V'},nQ*nR,PHI,nQ*nR,PSI,nQ*nR,ALPHA,BETA,hardLimD,sigmaD,}
\DoxyCodeLine{483           VSL,nQ*nR,VSR,nQ*nR,this-\/>memManager\_);}
\DoxyCodeLine{484 }
\DoxyCodeLine{485 }
\DoxyCodeLine{486         \textcolor{comment}{// VSRt is thick-\/restart}}
\DoxyCodeLine{487         \_F * VSRt = VSR + nR * (nQ * nR);}
\DoxyCodeLine{488 }
\DoxyCodeLine{489         \_F * VSR\_V = VSR;}
\DoxyCodeLine{490         \_F * VSR\_W = VSR\_V + nR;}
\DoxyCodeLine{491         \_F * VSR\_S = VSR\_W + nR;}
\DoxyCodeLine{492         \_F * VSR\_P = VSR\_S + M\_NR;}
\DoxyCodeLine{493 }
\DoxyCodeLine{494         \_F * VSL\_V = VSL;}
\DoxyCodeLine{495         \_F * VSL\_W = VSL\_V + nR;}
\DoxyCodeLine{496         \_F * VSL\_S = VSL\_W + nR;}
\DoxyCodeLine{497         \_F * VSL\_P = VSL\_S + M\_NR;}
\DoxyCodeLine{498 }
\DoxyCodeLine{499         \_F * VSRt\_V = VSRt;}
\DoxyCodeLine{500         \_F * VSRt\_W = VSRt\_V + nR;}
\DoxyCodeLine{501         \_F * VSRt\_S = VSRt\_W + nR;}
\DoxyCodeLine{502         \_F * VSRt\_P = VSRt\_S + M\_NR;}
\DoxyCodeLine{503 }
\DoxyCodeLine{504         \textcolor{comment}{// VSCR = V * VSR\_V + W * VSR\_W + S * VSR\_S + P * VSR\_P}}
\DoxyCodeLine{505         V-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSR\_V,nQ*nR,\_F(0.),*VSCR, 0);}
\DoxyCodeLine{506         W-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSR\_W,nQ*nR,\_F(1.),*VSCR, 0);}
\DoxyCodeLine{507         \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,M\_NR,\_F(1.),VSR\_S,nQ*nR,\_F(1.),*VSCR, 0);}
\DoxyCodeLine{508         \textcolor{keywordflow}{if}( iter )}
\DoxyCodeLine{509           P-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),VSR\_P,nQ*nR,\_F(1.),*VSCR, 0);}
\DoxyCodeLine{510 }
\DoxyCodeLine{511 }
\DoxyCodeLine{512         \textcolor{comment}{// VSCR2 = V * VSRt\_V + W * VSRt\_W + S * VSRt\_S + P * VSRt\_P}}
\DoxyCodeLine{513         V-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSRt\_V,nQ*nR,\_F(0.),*VSCR2, 0);}
\DoxyCodeLine{514         W-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSRt\_W,nQ*nR,\_F(1.),*VSCR2, 0);}
\DoxyCodeLine{515         \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,M\_NR,\_F(1.),VSRt\_S,nQ*nR,\_F(1.),*VSCR2, 0);}
\DoxyCodeLine{516         \textcolor{keywordflow}{if}( iter )}
\DoxyCodeLine{517           P-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),VSRt\_P,nQ*nR,\_F(1.),*VSCR2, 0);}
\DoxyCodeLine{518 }
\DoxyCodeLine{519         \textcolor{comment}{// V = VSCR}}
\DoxyCodeLine{520         \textcolor{comment}{// P = VSCR2}}
\DoxyCodeLine{521         V-\/>set\_data(0, nR, *VSCR, 0);}
\DoxyCodeLine{522         P-\/>set\_data(0, nR, *VSCR2, 0);}
\DoxyCodeLine{523 }
\DoxyCodeLine{524 }
\DoxyCodeLine{525         \textcolor{comment}{// VSCR = AV * VSR\_V + AW * VSR\_W + AS * VSR\_S + AP * VSR\_P}}
\DoxyCodeLine{526         AV-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSR\_V,nQ*nR,\_F(0.),*VSCR, 0);}
\DoxyCodeLine{527         AW-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSR\_W,nQ*nR,\_F(1.),*VSCR, 0);}
\DoxyCodeLine{528         AS-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,M\_NR,\_F(1.),VSR\_S,nQ*nR,\_F(1.),*VSCR, 0);}
\DoxyCodeLine{529         \textcolor{keywordflow}{if}( iter )}
\DoxyCodeLine{530           AP-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),VSR\_P,nQ*nR,\_F(1.),*VSCR, 0);}
\DoxyCodeLine{531 }
\DoxyCodeLine{532         \textcolor{comment}{// VSCR2 = AV * VSRt\_V + AW * VSRt\_W + AS * VSRt\_S + AP * VSRt\_P}}
\DoxyCodeLine{533         AV-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSRt\_V,nQ*nR,\_F(0.),*VSCR2, 0);}
\DoxyCodeLine{534         AW-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSRt\_W,nQ*nR,\_F(1.),*VSCR2, 0);}
\DoxyCodeLine{535         AS-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,M\_NR,\_F(1.),VSRt\_S,nQ*nR,\_F(1.),*VSCR2, 0);}
\DoxyCodeLine{536         \textcolor{keywordflow}{if}( iter )}
\DoxyCodeLine{537           AP-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),VSRt\_P,nQ*nR,\_F(1.),*VSCR2, 0);}
\DoxyCodeLine{538 }
\DoxyCodeLine{539 }
\DoxyCodeLine{540         \textcolor{comment}{// AV = VSCR}}
\DoxyCodeLine{541         \textcolor{comment}{// AP = VSCR2}}
\DoxyCodeLine{542         AV-\/>set\_data(0, nR, *VSCR, 0);}
\DoxyCodeLine{543         AP-\/>set\_data(0, nR, *VSCR2, 0);}
\DoxyCodeLine{544 }
\DoxyCodeLine{545         \textcolor{comment}{// VSCR = Q * VSR\_V + Q1 * VSR\_W + Q2 * VSR\_S + Q3 * VSR\_P}}
\DoxyCodeLine{546         Q-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSL\_V,nQ*nR,\_F(0.),*VSCR, 0);}
\DoxyCodeLine{547         Q1-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR  ,\_F(1.),VSL\_W,nQ*nR,\_F(1.),*VSCR, 0);}
\DoxyCodeLine{548         Q2-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,M\_NR,\_F(1.),VSL\_S,nQ*nR,\_F(1.),*VSCR, 0);}
\DoxyCodeLine{549         \textcolor{keywordflow}{if}( Q3 )}
\DoxyCodeLine{550           Q3-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),VSL\_P,nQ*nR,\_F(1.),*VSCR, 0);}
\DoxyCodeLine{551 }
\DoxyCodeLine{552         \textcolor{comment}{// Q = VSCR}}
\DoxyCodeLine{553         Q-\/>set\_data(0, nR, *VSCR, 0);}
\DoxyCodeLine{554 }
\DoxyCodeLine{555 \textcolor{comment}{//      \} // ROOT only}}
\DoxyCodeLine{556 }
\DoxyCodeLine{557       \textcolor{comment}{// Refresh AV}}
\DoxyCodeLine{558       \textcolor{keywordflow}{if}( (iter+1) \% 100 == 0 ) \{}
\DoxyCodeLine{559 }
\DoxyCodeLine{560         \textcolor{keywordflow}{if}( isRoot ) }
\DoxyCodeLine{561           std::cout << \textcolor{stringliteral}{"{}  * Refreshing AV at iteration "{}} << iter+1 }
\DoxyCodeLine{562             << std::endl;}
\DoxyCodeLine{563 }
\DoxyCodeLine{564         \textcolor{comment}{// Sync processes}}
\DoxyCodeLine{565         \mbox{\hyperlink{namespaceChronusQ_a23c2e4eb26f9455d90831342328f3b91}{MPI\_Barrier}}(this-\/>comm\_);}
\DoxyCodeLine{566 }
\DoxyCodeLine{567         LTst = \mbox{\hyperlink{namespaceChronusQ_a715f671201f0f6e77216fcf1f72adbaf}{tick}}();}
\DoxyCodeLine{568 }
\DoxyCodeLine{569 }
\DoxyCodeLine{570         this-\/>linearTrans\_(nR,*VSend,*AVRecv);}
\DoxyCodeLine{571 }
\DoxyCodeLine{572         LTdur += \mbox{\hyperlink{namespaceChronusQ_a3b2153e93af4532ff5b1e75d8af453b0}{tock}}(LTst);}
\DoxyCodeLine{573 }
\DoxyCodeLine{574         \textcolor{comment}{// Sync processes}}
\DoxyCodeLine{575         \mbox{\hyperlink{namespaceChronusQ_a23c2e4eb26f9455d90831342328f3b91}{MPI\_Barrier}}(this-\/>comm\_);}
\DoxyCodeLine{576       \}}
\DoxyCodeLine{577 }
\DoxyCodeLine{578 \textcolor{comment}{//      if( isRoot ) \{}}
\DoxyCodeLine{579 }
\DoxyCodeLine{580         \textcolor{comment}{// Update MA, MB}}
\DoxyCodeLine{581         getTriU(nR,PHI,nQ*nR,PSI,nQ*nR,MA,nR,MB,nR);}
\DoxyCodeLine{582         }
\DoxyCodeLine{583         \textcolor{comment}{// Update eigenvalues}}
\DoxyCodeLine{584         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0; i < nR; i++)}
\DoxyCodeLine{585           this-\/>eigVal\_[i] = ALPHA[i] / BETA[i];}
\DoxyCodeLine{586         }
\DoxyCodeLine{587 }
\DoxyCodeLine{588         \textcolor{comment}{// W = AV * MB -\/ V * MA}}
\DoxyCodeLine{589         AV-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.) ,MB,nR,\_F(0.),*W, 0);}
\DoxyCodeLine{590         V-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(-\/1.),MA,nR,\_F(1.),*W, 0);}
\DoxyCodeLine{591         }
\DoxyCodeLine{592         \textcolor{comment}{/*}}
\DoxyCodeLine{593 \textcolor{comment}{        // Adaptive sigma}}
\DoxyCodeLine{594 \textcolor{comment}{        limDiff = std::numeric\_limits<double>::infinity();}}
\DoxyCodeLine{595 \textcolor{comment}{        maxW = -\/std::numeric\_limits<double>::infinity();}}
\DoxyCodeLine{596 \textcolor{comment}{}}
\DoxyCodeLine{597 \textcolor{comment}{        }}
\DoxyCodeLine{598 \textcolor{comment}{        for(auto i = 0ul; i < nQ*nR; i++)}}
\DoxyCodeLine{599 \textcolor{comment}{          RITZ[i] = std::real(ALPHA[i] / BETA[i]);}}
\DoxyCodeLine{600 \textcolor{comment}{}}
\DoxyCodeLine{601 \textcolor{comment}{        std::sort(RITZ,RITZ + nQ*nR);}}
\DoxyCodeLine{602 \textcolor{comment}{        //prettyPrintSmart(std::cout,"{}RITZ SORT"{},RITZ,MSS,1,MSS);}}
\DoxyCodeLine{603 \textcolor{comment}{}}
\DoxyCodeLine{604 \textcolor{comment}{        for( auto i = 0ul; i < MSS; i++ ) \{    }}
\DoxyCodeLine{605 \textcolor{comment}{          if( RITZ[i] > hardLimD) \{}}
\DoxyCodeLine{606 \textcolor{comment}{            std::copy(RITZ + i, RITZ + i + nR, nRITZ);}}
\DoxyCodeLine{607 \textcolor{comment}{            omega0 = RITZ[i-\/1];}}
\DoxyCodeLine{608 \textcolor{comment}{            maxW = nRITZ[nR-\/1];}}
\DoxyCodeLine{609 \textcolor{comment}{            break;}}
\DoxyCodeLine{610 \textcolor{comment}{          \}}}
\DoxyCodeLine{611 \textcolor{comment}{        \}}}
\DoxyCodeLine{612 \textcolor{comment}{        }}
\DoxyCodeLine{613 \textcolor{comment}{        belowTh = true;}}
\DoxyCodeLine{614 \textcolor{comment}{        }}
\DoxyCodeLine{615 \textcolor{comment}{}}
\DoxyCodeLine{616 \textcolor{comment}{        }}
\DoxyCodeLine{617 \textcolor{comment}{        midPt = (maxW + omega0) / 2.;}}
\DoxyCodeLine{618 \textcolor{comment}{        if (midPt > hardLimD and belowTh) \{}}
\DoxyCodeLine{619 \textcolor{comment}{          sigmaD = midPt;}}
\DoxyCodeLine{620 \textcolor{comment}{        \} else \{}}
\DoxyCodeLine{621 \textcolor{comment}{          sigmaD = hardLimD;}}
\DoxyCodeLine{622 \textcolor{comment}{        \}}}
\DoxyCodeLine{623 \textcolor{comment}{        std::cout << "{}midPt: "{} << midPt << std::endl;}}
\DoxyCodeLine{624 \textcolor{comment}{        std::cout << "{}New Sigma: "{} << sigmaD << std::endl;}}
\DoxyCodeLine{625 \textcolor{comment}{}}
\DoxyCodeLine{626 \textcolor{comment}{        */}}
\DoxyCodeLine{627 }
\DoxyCodeLine{628 }
\DoxyCodeLine{629         \textcolor{comment}{// Get Residual norms}}
\DoxyCodeLine{630         getResidualNorms(N,nR,*W,RelRes,this-\/>eigVal\_,nrmA);}
\DoxyCodeLine{631         }
\DoxyCodeLine{632 }
\DoxyCodeLine{633         \textcolor{comment}{// Check convergence}}
\DoxyCodeLine{634         isConverged = checkConv(nR,RelRes);}
\DoxyCodeLine{635 }
\DoxyCodeLine{636 \textcolor{comment}{//      \} // ROOT only}}
\DoxyCodeLine{637 }
\DoxyCodeLine{638 }
\DoxyCodeLine{639       \textcolor{comment}{// Bcast converged}}
\DoxyCodeLine{640       \mbox{\hyperlink{namespaceChronusQ_a32fff0e1bd45dafd5f0fe782f216da29}{MPIBCast}}(isConverged,0,this-\/>comm\_);}
\DoxyCodeLine{641 }
\DoxyCodeLine{642 }
\DoxyCodeLine{643 }
\DoxyCodeLine{644 }
\DoxyCodeLine{645 }
\DoxyCodeLine{646       \mbox{\hyperlink{classChronusQ_1_1ProgramTimer_a596d67507317c2c8b2dfb92d99e48425}{ProgramTimer::tock}}(\textcolor{stringliteral}{"{}Diagonalize Iter"{}});}
\DoxyCodeLine{647 }
\DoxyCodeLine{648 }
\DoxyCodeLine{649       \textcolor{keywordflow}{if}( isRoot ) \{}
\DoxyCodeLine{650 }
\DoxyCodeLine{651         \textcolor{keyword}{auto} GPLHRdur = ProgramTimer::getDurationTotal<CQSecond>(}
\DoxyCodeLine{652           \textcolor{stringliteral}{"{}Diagonalize Iter"{}}).count();}
\DoxyCodeLine{653 }
\DoxyCodeLine{654         \textcolor{keywordtype}{double} perLT = LTdur * 100 / GPLHRdur;}
\DoxyCodeLine{655 }
\DoxyCodeLine{656         std::cout << \textcolor{stringliteral}{"{}  DURATION = "{}} << std::setprecision(8) << GPLHRdur }
\DoxyCodeLine{657           << \textcolor{stringliteral}{"{} s  ( "{}} << perLT << \textcolor{stringliteral}{"{} \% LT )"{}} << std::endl;}
\DoxyCodeLine{658 }
\DoxyCodeLine{659         std::cout << std::setprecision(10) << std::scientific;}
\DoxyCodeLine{660         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} iRt = 0ul; iRt < nR; iRt++) \{}
\DoxyCodeLine{661 }
\DoxyCodeLine{662           std::cout << \textcolor{stringliteral}{"{}      IRt = "{}} << std::setw(5) << std::left << iRt;}
\DoxyCodeLine{663 }
\DoxyCodeLine{664           std::cout << std::right;}
\DoxyCodeLine{665           \textcolor{keywordflow}{if}( std::is\_same<double, \_F>::value ) std::cout << \textcolor{stringliteral}{"{}EigVal = "{}}; }
\DoxyCodeLine{666           \textcolor{keywordflow}{else}                                  std::cout << \textcolor{stringliteral}{"{}Re(EigVal) = "{}};}
\DoxyCodeLine{667 }
\DoxyCodeLine{668 }
\DoxyCodeLine{669           std::cout << std::setw(20) << std::real(this-\/>eigVal\_[iRt]);}
\DoxyCodeLine{670 }
\DoxyCodeLine{671           \textcolor{keywordflow}{if}( std::is\_same<dcomplex,\_F>::value ) \{}
\DoxyCodeLine{672             std::cout << \textcolor{stringliteral}{"{}    Im(EigVal) = "{}};}
\DoxyCodeLine{673             std::cout << std::setw(20) << std::imag(this-\/>eigVal\_[iRt]);}
\DoxyCodeLine{674           \}}
\DoxyCodeLine{675 }
\DoxyCodeLine{676 }
\DoxyCodeLine{677           std::cout << \textcolor{stringliteral}{"{}    RelResNorm = "{}};}
\DoxyCodeLine{678           std::cout << std::setw(20) << RelRes[iRt];}
\DoxyCodeLine{679 }
\DoxyCodeLine{680 }
\DoxyCodeLine{681           std::cout << std::endl;}
\DoxyCodeLine{682         \}}
\DoxyCodeLine{683 }
\DoxyCodeLine{684         std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{685 }
\DoxyCodeLine{686       \} \textcolor{comment}{// ROOR only}}
\DoxyCodeLine{687 }
\DoxyCodeLine{688 }
\DoxyCodeLine{689 }
\DoxyCodeLine{690       \textcolor{keywordflow}{if}( isConverged ) \textcolor{keywordflow}{break}; \textcolor{comment}{// Break loop on convergence}}
\DoxyCodeLine{691 }
\DoxyCodeLine{692 }
\DoxyCodeLine{693       }
\DoxyCodeLine{694 }
\DoxyCodeLine{695     \} \textcolor{comment}{// end for}}
\DoxyCodeLine{696 }
\DoxyCodeLine{697 }
\DoxyCodeLine{698     \mbox{\hyperlink{namespaceChronusQ_a23c2e4eb26f9455d90831342328f3b91}{MPI\_Barrier}}(this-\/>comm\_); \textcolor{comment}{// Sync processes}}
\DoxyCodeLine{699 }
\DoxyCodeLine{700     }
\DoxyCodeLine{701 }
\DoxyCodeLine{702 }
\DoxyCodeLine{703 \textcolor{comment}{//    if( isRoot ) \{}}
\DoxyCodeLine{704 }
\DoxyCodeLine{705       \textcolor{comment}{// Reconstruct Eigen vectors}}
\DoxyCodeLine{706       V-\/>dot\_product(0, *AV, 0, nR, nR, PSI, nR);}
\DoxyCodeLine{707       \mbox{\hyperlink{namespaceChronusQ_a5d3260732d7f2c9102c6974ea3a04d4a}{GeneralEigen}}(\textcolor{charliteral}{'N'}, \textcolor{charliteral}{'V'}, nR, PSI, nR, ALPHA, VSL, nR, VSR, nR);}
\DoxyCodeLine{708       V-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nR,\_F(1.),VSR,nR,\_F(0.),*this-\/>VR\_, 0);}
\DoxyCodeLine{709 }
\DoxyCodeLine{710 \textcolor{comment}{//    \}}}
\DoxyCodeLine{711 }
\DoxyCodeLine{712 }
\DoxyCodeLine{713     \textcolor{comment}{// Free Scratch space}}
\DoxyCodeLine{714 }
\DoxyCodeLine{715     \textcolor{keywordflow}{if}(ALPHA)  this-\/>memManager\_.free(ALPHA);}
\DoxyCodeLine{716     \textcolor{keywordflow}{if}(BETA)   this-\/>memManager\_.free(BETA);}
\DoxyCodeLine{717     \textcolor{keywordflow}{if}(RMAT)   this-\/>memManager\_.free(RMAT);}
\DoxyCodeLine{718     \textcolor{keywordflow}{if}(PHI)    this-\/>memManager\_.free(PHI);}
\DoxyCodeLine{719     \textcolor{keywordflow}{if}(PSI)    this-\/>memManager\_.free(PSI);}
\DoxyCodeLine{720     \textcolor{keywordflow}{if}(VSL)    this-\/>memManager\_.free(VSL);}
\DoxyCodeLine{721     \textcolor{keywordflow}{if}(VSR)    this-\/>memManager\_.free(VSR);}
\DoxyCodeLine{722     \textcolor{keywordflow}{if}(MA)     this-\/>memManager\_.free(MA);}
\DoxyCodeLine{723     \textcolor{keywordflow}{if}(MB)     this-\/>memManager\_.free(MB);}
\DoxyCodeLine{724 }
\DoxyCodeLine{725     \textcolor{keywordflow}{if}( isRoot ) \{}
\DoxyCodeLine{726 }
\DoxyCodeLine{727       std::cout << \textcolor{stringliteral}{"{}  * "{}};}
\DoxyCodeLine{728       \textcolor{keywordflow}{if}( isConverged )}
\DoxyCodeLine{729         std::cout << \textcolor{stringliteral}{"{}GPLHR Converged in "{}} << iter+1 << \textcolor{stringliteral}{"{} Iterations"{}} }
\DoxyCodeLine{730                   << std::endl;}
\DoxyCodeLine{731       \textcolor{keywordflow}{else}}
\DoxyCodeLine{732         std::cout << \textcolor{stringliteral}{"{}GPLHR Failed to Converged in "{}} << iter+1 << \textcolor{stringliteral}{"{} Iterations"{}} }
\DoxyCodeLine{733                   << std::endl;}
\DoxyCodeLine{734 }
\DoxyCodeLine{735     \}}
\DoxyCodeLine{736 }
\DoxyCodeLine{737 }
\DoxyCodeLine{738     \textcolor{keywordflow}{return} isConverged;}
\DoxyCodeLine{739 }
\DoxyCodeLine{740   \}}
\DoxyCodeLine{741 }
\DoxyCodeLine{742 }
\DoxyCodeLine{743 }
\DoxyCodeLine{744   \textcolor{comment}{/*}}
\DoxyCodeLine{745 \textcolor{comment}{    Calculate relative norm for each residual vector }}
\DoxyCodeLine{746 \textcolor{comment}{    Assuming B = Identity.}}
\DoxyCodeLine{747 \textcolor{comment}{    Assuming eigenvalues are finite.}}
\DoxyCodeLine{748 \textcolor{comment}{  */}}
\DoxyCodeLine{749   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{750   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GPLHR_a2094422b66d1977d583a398846f29fa9}{GPLHR<\_F>::getResidualNorms}}(\textcolor{keywordtype}{size\_t} N, \textcolor{keywordtype}{size\_t} nR, \textcolor{keyword}{const} \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&WMAT, \textcolor{keywordtype}{double} *RelRes, \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} *LAMBDA, \textcolor{keywordtype}{double} nrmA) \{}
\DoxyCodeLine{751 }
\DoxyCodeLine{752     \textcolor{comment}{// ROOT\_ONLY(this-\/>comm\_);}}
\DoxyCodeLine{753 }
\DoxyCodeLine{754 }
\DoxyCodeLine{755     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < nR; i++) \{}
\DoxyCodeLine{756 }
\DoxyCodeLine{757       \textcolor{keywordtype}{double} nrmI = WMAT.\mbox{\hyperlink{classChronusQ_1_1SolverVectors_a853a642934a30f087fac8fd7ecea3f80}{norm2F}}(i, 1);}
\DoxyCodeLine{758       RelRes[i] = nrmI / (nrmA + std::abs(LAMBDA[i]));}
\DoxyCodeLine{759 }
\DoxyCodeLine{760     \}}
\DoxyCodeLine{761 }
\DoxyCodeLine{762   \}}
\DoxyCodeLine{763 }
\DoxyCodeLine{764   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{765   \textcolor{keywordtype}{bool} \mbox{\hyperlink{classChronusQ_1_1GPLHR_a792e489ec97152f988197981b6310dc3}{GPLHR<\_F>::checkConv}}(\textcolor{keywordtype}{size\_t} nR, \textcolor{keywordtype}{double} *RelRes) \{ }
\DoxyCodeLine{766 }
\DoxyCodeLine{767     \textcolor{keyword}{const} \textcolor{keywordtype}{bool} conv = std::none\_of(RelRes,RelRes + nR,}
\DoxyCodeLine{768         [\&]( \textcolor{keywordtype}{double} x ) -\/> \textcolor{keywordtype}{bool} \{ }
\DoxyCodeLine{769           \textcolor{keywordflow}{return} x > this-\/>convCrit\_ or std::isnan(x);}
\DoxyCodeLine{770         \});}
\DoxyCodeLine{771 }
\DoxyCodeLine{772     \textcolor{keywordflow}{return} conv;}
\DoxyCodeLine{773   \}}
\DoxyCodeLine{774 }
\DoxyCodeLine{775 }
\DoxyCodeLine{776 }
\DoxyCodeLine{777   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{778   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GPLHR_a8fd7e026149f4a57a8e96c562773b0a8}{GPLHR<\_F>::getTriU}}(\textcolor{keywordtype}{size\_t} N, \_F *TRIUA, \textcolor{keywordtype}{size\_t} LDTRIUA, \_F *TRIUB, }
\DoxyCodeLine{779     \textcolor{keywordtype}{size\_t} LDTRIUB, \_F *MA, \textcolor{keywordtype}{size\_t} LDMA, \_F *MB, \textcolor{keywordtype}{size\_t} LDMB)\{}
\DoxyCodeLine{780 }
\DoxyCodeLine{781     \textcolor{comment}{// ROOT\_ONLY(this-\/>comm\_);}}
\DoxyCodeLine{782 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{783 }
\DoxyCodeLine{784     \textcolor{comment}{// G(TRIUB) = TRIUA * CA + TRIUB * CB}}
\DoxyCodeLine{785     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul; i < N; i++)\{ }
\DoxyCodeLine{786       blas::scal(N,CB[i*(N+1)],                TRIUB + i*ldm,1);}
\DoxyCodeLine{787       blas::axpy( N,CA[i*(N+1)],TRIUA + i*ldm,1,TRIUB + i*ldm,1);}
\DoxyCodeLine{788     \}}
\DoxyCodeLine{789 }
\DoxyCodeLine{790     \textcolor{comment}{// TRIUA = inv(TRIUB) * TRIUA}}
\DoxyCodeLine{791     blas::trsm(blas::Layout::ColMajor,blas::Side::Left,blas::Uplo::Upper,blas::Op::NoTrans,blas::Diag::NonUnit,}
\DoxyCodeLine{792       N,N,\_F(1.),TRIUB,ldm,TRIUA,ldm);}
\DoxyCodeLine{793 }
\DoxyCodeLine{794     \textcolor{comment}{//for(auto i = 0ul; i < N; i++)\{ }}
\DoxyCodeLine{795 }
\DoxyCodeLine{796     \textcolor{comment}{//  std::copy\_n(TRIUA + i*ldm, N, MA + i*N);}}
\DoxyCodeLine{797     \textcolor{comment}{//  std::copy\_n(TRIUA + i*ldm, N, MB + i*N);}}
\DoxyCodeLine{798 }
\DoxyCodeLine{799     \textcolor{comment}{//  blas::scal(N, CB[i*(N+1)],MA + i*N,1);}}
\DoxyCodeLine{800     \textcolor{comment}{//  blas::scal(N,-\/CA[i*(N+1)],MB + i*N,1);}}
\DoxyCodeLine{801 }
\DoxyCodeLine{802     \textcolor{comment}{//  MB[ i*(N + 1) ] += 1.;}}
\DoxyCodeLine{803 }
\DoxyCodeLine{804     \textcolor{comment}{//\}}}
\DoxyCodeLine{805 }
\DoxyCodeLine{806 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{807 }
\DoxyCodeLine{808     \textcolor{comment}{// Initialize CA and CB as identity FIXME: memory}}
\DoxyCodeLine{809     \_F *CA    = this-\/>memManager\_.template malloc<\_F>(N*N);}
\DoxyCodeLine{810     \_F *CB    = this-\/>memManager\_.template malloc<\_F>(N*N);}
\DoxyCodeLine{811     \_F *Ident = this-\/>memManager\_.template malloc<\_F>(N*N);}
\DoxyCodeLine{812     \_F *G     = this-\/>memManager\_.template malloc<\_F>(N*N);}
\DoxyCodeLine{813     std::fill\_n(CA,N*N,\_F(0.)); }
\DoxyCodeLine{814     std::fill\_n(CB,N*N,\_F(0.)); }
\DoxyCodeLine{815     std::fill\_n(Ident,N*N,\_F(0.)); }
\DoxyCodeLine{816     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < N; i++) \{}
\DoxyCodeLine{817       CA[i + i*N]    = \_F(1.0);}
\DoxyCodeLine{818       CB[i + i*N]    = \_F(1.0);}
\DoxyCodeLine{819       Ident[i + i*N] = \_F(1.0);}
\DoxyCodeLine{820     \}}
\DoxyCodeLine{821 }
\DoxyCodeLine{822     \textcolor{comment}{// Create CA and CB}}
\DoxyCodeLine{823     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < N; i++) \{}
\DoxyCodeLine{824       \textcolor{keywordflow}{if} (std::abs(TRIUA[i + i*LDTRIUA]) >= std::abs(TRIUB[i + i*LDTRIUB])) \{}
\DoxyCodeLine{825         CA[i + i*N] = (\_F(1.) -\/ TRIUB[i + i*LDTRIUB]) / TRIUA[i + i*LDTRIUA];}
\DoxyCodeLine{826       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{827         CA[i + i*N] = \_F(0.);}
\DoxyCodeLine{828         CB[i + i*N] = \_F(1.) / TRIUB[i + i*LDTRIUA];}
\DoxyCodeLine{829       \}}
\DoxyCodeLine{830     \}}
\DoxyCodeLine{831 }
\DoxyCodeLine{832     \textcolor{comment}{// Form G}}
\DoxyCodeLine{833     blas::gemm(blas::Layout::ColMajor,blas::Op::NoTrans,blas::Op::NoTrans,N,N,N,\_F(1.),TRIUA,LDTRIUA,CA,N,\_F(0.),G,N);  }
\DoxyCodeLine{834     blas::gemm(blas::Layout::ColMajor,blas::Op::NoTrans,blas::Op::NoTrans,N,N,N,\_F(1.),TRIUB,LDTRIUB,CB,N,\_F(1.),G,N);}
\DoxyCodeLine{835     }
\DoxyCodeLine{836     \textcolor{comment}{// Form MA}}
\DoxyCodeLine{837     blas::trsm(blas::Layout::ColMajor,blas::Side::Right,blas::Uplo::Upper,blas::Op::NoTrans,blas::Diag::NonUnit,}
\DoxyCodeLine{838       N,N,\_F(1.),G,N,CB,N);}
\DoxyCodeLine{839     blas::gemm(blas::Layout::ColMajor,blas::Op::NoTrans,blas::Op::NoTrans,N,N,N,\_F(1.),CB,N,TRIUA,LDTRIUA,\_F(0.),MA,LDMA);}
\DoxyCodeLine{840 }
\DoxyCodeLine{841     \textcolor{comment}{// Form MB   }}
\DoxyCodeLine{842     blas::trsm(blas::Layout::ColMajor,blas::Side::Right,blas::Uplo::Upper,blas::Op::NoTrans,blas::Diag::NonUnit,}
\DoxyCodeLine{843       N,N,\_F(1.),G,N,CA,N);}
\DoxyCodeLine{844     blas::gemm(blas::Layout::ColMajor,blas::Op::NoTrans,blas::Op::NoTrans,N,N,N,\_F(1.),CA,N,TRIUA,LDTRIUA,\_F(0.),MB,LDMB);}
\DoxyCodeLine{845     blas::axpy(N*N,\_F(-\/1.),MB,1,Ident,1);}
\DoxyCodeLine{846     std::copy\_n(Ident, N*N, MB);}
\DoxyCodeLine{847 }
\DoxyCodeLine{848 }
\DoxyCodeLine{849     \textcolor{comment}{// Free SCR Mem}}
\DoxyCodeLine{850     this-\/>memManager\_.free(CA);}
\DoxyCodeLine{851     this-\/>memManager\_.free(CB);}
\DoxyCodeLine{852     this-\/>memManager\_.free(G);}
\DoxyCodeLine{853 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{854 }
\DoxyCodeLine{855 }
\DoxyCodeLine{856   \}}
\DoxyCodeLine{857 }
\DoxyCodeLine{858 }
\DoxyCodeLine{859 }
\DoxyCodeLine{860 }
\DoxyCodeLine{861 }
\DoxyCodeLine{862 }
\DoxyCodeLine{863 }
\DoxyCodeLine{864 }
\DoxyCodeLine{870   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{871   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GPLHR_a053f72b362f79cef44b210daaf442512}{GPLHR<\_F>::halfProj}}(\textcolor{keywordtype}{size\_t} nV, \textcolor{keywordtype}{size\_t} nS, \textcolor{keyword}{const} \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&V,}
\DoxyCodeLine{872                            \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&S, \_F *SCR, \textcolor{keywordtype}{size\_t} LDSCR) \{}
\DoxyCodeLine{873 }
\DoxyCodeLine{874     \textcolor{keywordflow}{if}( LDSCR < nV ) \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}nV MUST be >= LDSCR"{}});}
\DoxyCodeLine{875 }
\DoxyCodeLine{876     \textcolor{comment}{// ROOT\_ONLY(this-\/>comm\_);}}
\DoxyCodeLine{877 }
\DoxyCodeLine{878     \textcolor{comment}{// SCR = V**H * S}}
\DoxyCodeLine{879     V.\mbox{\hyperlink{classChronusQ_1_1SolverVectors_ab88de13a712f69b8255a786431542956}{dot\_product}}(0, \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}, 0, nV, nS, SCR, LDSCR);}
\DoxyCodeLine{880 }
\DoxyCodeLine{881     \textcolor{comment}{// S = S -\/ V * SCR}}
\DoxyCodeLine{882     V.\mbox{\hyperlink{classChronusQ_1_1SolverVectors_a1214b21ba6da9c3d030f19f9ef170088}{multiply\_matrix}}(0, blas::Op::NoTrans, nS, nV, \_F(-\/1.), SCR, LDSCR, \_F(1.), \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}, 0);}
\DoxyCodeLine{883 }
\DoxyCodeLine{884   \}}
\DoxyCodeLine{885 }
\DoxyCodeLine{893   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{894   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GPLHR_a761ddf087e9cd46c1069a39358a7fe6e}{GPLHR<\_F>::halfProj2}}(\textcolor{keywordtype}{size\_t} nV, \textcolor{keywordtype}{size\_t} nS, \textcolor{keyword}{const} \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&V, \textcolor{keyword}{const} \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&AV,}
\DoxyCodeLine{895                             \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&S, \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&AS, \_F *SCR, \textcolor{keywordtype}{size\_t} LDSCR) \{}
\DoxyCodeLine{896 }
\DoxyCodeLine{897     \textcolor{keywordflow}{if}( LDSCR < nV ) \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}nV MUST be >= LDSCR"{}});}
\DoxyCodeLine{898 }
\DoxyCodeLine{899     \textcolor{comment}{// ROOT\_ONLY(this-\/>comm\_);}}
\DoxyCodeLine{900 }
\DoxyCodeLine{901     \textcolor{comment}{// SCR = V**H * S}}
\DoxyCodeLine{902     V.\mbox{\hyperlink{classChronusQ_1_1SolverVectors_ab88de13a712f69b8255a786431542956}{dot\_product}}(0, \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}, 0, nV, nS, SCR, LDSCR);}
\DoxyCodeLine{903 }
\DoxyCodeLine{904     \textcolor{comment}{// S = S -\/ V * SCR}}
\DoxyCodeLine{905     V.\mbox{\hyperlink{classChronusQ_1_1SolverVectors_a1214b21ba6da9c3d030f19f9ef170088}{multiply\_matrix}}(0, blas::Op::NoTrans, nS, nV, \_F(-\/1.), SCR, LDSCR, \_F(1.), \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}, 0);}
\DoxyCodeLine{906 }
\DoxyCodeLine{907     \textcolor{comment}{// AS = AS -\/ AV * SCR}}
\DoxyCodeLine{908     AV.\mbox{\hyperlink{classChronusQ_1_1SolverVectors_a1214b21ba6da9c3d030f19f9ef170088}{multiply\_matrix}}(0, blas::Op::NoTrans, nS, nV, \_F(-\/1.), SCR, LDSCR, \_F(1.), AS, 0);}
\DoxyCodeLine{909 }
\DoxyCodeLine{910   \}}
\DoxyCodeLine{911 }
\DoxyCodeLine{912 }
\DoxyCodeLine{913 }
\DoxyCodeLine{921   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{922   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GPLHR_ad1860dfb1d8511495744be6bb708b1f1}{GPLHR<\_F>::newSMatrix}}(\textcolor{keywordtype}{size\_t} nR, \textcolor{keyword}{const} \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&V, \textcolor{keyword}{const} \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&Q,}
\DoxyCodeLine{923                              \mbox{\hyperlink{classChronusQ_1_1SolverVectors}{SolverVectors<\_F>}} \&S, \_F *SCR, \textcolor{keywordtype}{size\_t} LDSCR) \{}
\DoxyCodeLine{924 }
\DoxyCodeLine{925 }
\DoxyCodeLine{926     \textcolor{comment}{// ROOT\_ONLY(this-\/>comm\_);}}
\DoxyCodeLine{927 }
\DoxyCodeLine{928     halfProj(nR,V,\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}},SCR,LDSCR);}
\DoxyCodeLine{929     this-\/>preCondWShift\_(nR,sigma,\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}},\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}});}
\DoxyCodeLine{930     halfProj(nR,Q,\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}},SCR,LDSCR);}
\DoxyCodeLine{931 }
\DoxyCodeLine{932   \}}
\DoxyCodeLine{933 }
\DoxyCodeLine{934 }
\DoxyCodeLine{935 }
\DoxyCodeLine{936   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{937   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1GPLHR_ab82793dbe0112cb7f29400312727a00d}{GPLHR<\_F>::restart}}() \{ \}}
\DoxyCodeLine{938 }
\DoxyCodeLine{939 \}; \textcolor{comment}{// namespace ChronusQ}}
\DoxyCodeLine{940 }

\end{DoxyCode}
