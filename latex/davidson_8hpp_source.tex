\hypertarget{davidson_8hpp_source}{}\doxysection{davidson.\+hpp}
\label{davidson_8hpp_source}\index{include/itersolver/davidson.hpp@{include/itersolver/davidson.hpp}}
\mbox{\hyperlink{davidson_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/* }}
\DoxyCodeLine{2 \textcolor{comment}{ *  This file is part of the Chronus Quantum (ChronusQ) software package}}
\DoxyCodeLine{3 \textcolor{comment}{ *  }}
\DoxyCodeLine{4 \textcolor{comment}{ *  Copyright (C) 2014-\/2022 Li Research Group (University of Washington)}}
\DoxyCodeLine{5 \textcolor{comment}{ *  }}
\DoxyCodeLine{6 \textcolor{comment}{ *  This program is free software; you can redistribute it and/or modify}}
\DoxyCodeLine{7 \textcolor{comment}{ *  it under the terms of the GNU General Public License as published by}}
\DoxyCodeLine{8 \textcolor{comment}{ *  the Free Software Foundation; either version 2 of the License, or}}
\DoxyCodeLine{9 \textcolor{comment}{ *  (at your option) any later version.}}
\DoxyCodeLine{10 \textcolor{comment}{ *  }}
\DoxyCodeLine{11 \textcolor{comment}{ *  This program is distributed in the hope that it will be useful,}}
\DoxyCodeLine{12 \textcolor{comment}{ *  but WITHOUT ANY WARRANTY; without even the implied warranty of}}
\DoxyCodeLine{13 \textcolor{comment}{ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}}
\DoxyCodeLine{14 \textcolor{comment}{ *  GNU General Public License for more details.}}
\DoxyCodeLine{15 \textcolor{comment}{ *  }}
\DoxyCodeLine{16 \textcolor{comment}{ *  You should have received a copy of the GNU General Public License along}}
\DoxyCodeLine{17 \textcolor{comment}{ *  with this program; if not, write to the Free Software Foundation, Inc.,}}
\DoxyCodeLine{18 \textcolor{comment}{ *  51 Franklin Street, Fifth Floor, Boston, MA 02110-\/1301 USA.}}
\DoxyCodeLine{19 \textcolor{comment}{ *  }}
\DoxyCodeLine{20 \textcolor{comment}{ *  Contact the Developers:}}
\DoxyCodeLine{21 \textcolor{comment}{ *    E-\/Mail: xsli@uw.edu}}
\DoxyCodeLine{22 \textcolor{comment}{ *  }}
\DoxyCodeLine{23 \textcolor{comment}{ */}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#ifndef \_\_INCLUDED\_DAVIDSON\_HPP\_\_}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#define \_\_INCLUDED\_DAVIDSON\_HPP\_\_}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{itersolver_8hpp}{itersolver.hpp}}>}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{timer_8hpp}{util/timer.hpp}}>}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{matout_8hpp}{util/matout.hpp}}>}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{factorization_8hpp}{cqlinalg/factorization.hpp}}>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{blas3_8hpp}{cqlinalg/blas3.hpp}}>}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{blasext_8hpp}{cqlinalg/blasext.hpp}}>}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{ortho_8hpp}{cqlinalg/ortho.hpp}}>}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{eig_8hpp}{cqlinalg/eig.hpp}}>}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#include <\mbox{\hyperlink{cerr_8hpp}{cerr.hpp}}>}}
\DoxyCodeLine{36 }
\DoxyCodeLine{37 \textcolor{comment}{// \#define DEBUG\_DAVIDSON}}
\DoxyCodeLine{38 }
\DoxyCodeLine{39 }
\DoxyCodeLine{40 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespaceChronusQ}{ChronusQ}} \{}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 }
\DoxyCodeLine{43   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{44   \textcolor{keywordtype}{bool} \mbox{\hyperlink{classChronusQ_1_1Davidson_a024e3122197eebc0a3819c980468c424}{Davidson<\_F>::runMicro}}() \{}
\DoxyCodeLine{45     }
\DoxyCodeLine{46     \textcolor{keywordtype}{bool} isRoot = \mbox{\hyperlink{namespaceChronusQ_ac9433164d43ee9f6f0c49e49698f680f}{MPIRank}}(this-\/>comm\_) == 0;}
\DoxyCodeLine{47     \textcolor{keywordtype}{bool} isConverged = \textcolor{keyword}{false};}
\DoxyCodeLine{48     }
\DoxyCodeLine{49     \textcolor{keywordflow}{if}( isRoot ) \{}
\DoxyCodeLine{50       std::cout  << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}};}
\DoxyCodeLine{51       std::cout  << \textcolor{stringliteral}{"{}  * Davidson Settings:\(\backslash\)n"{}};}
\DoxyCodeLine{52       std::cout  << \textcolor{stringliteral}{"{}    * Right Eigenvector is Requested. \(\backslash\)n"{}};}
\DoxyCodeLine{53       }
\DoxyCodeLine{54       \textcolor{keywordflow}{if}(this-\/>DoLeftEigVec) \{}
\DoxyCodeLine{55         std::cout  << \textcolor{stringliteral}{"{}    * Left Eigenvector is Requested.\(\backslash\)n"{}};}
\DoxyCodeLine{56         \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}Do Left Eig Vec is not implemented yet"{}});}
\DoxyCodeLine{57       \}}
\DoxyCodeLine{58       }
\DoxyCodeLine{59       \textcolor{keywordflow}{if} (this-\/>EnergySpecific) \{          }
\DoxyCodeLine{60         std::cout<< \textcolor{stringliteral}{"{}    * Use Energy Specific:           "{}} << (this-\/>EnergySpecific ? \textcolor{stringliteral}{"{}True"{}} : \textcolor{stringliteral}{"{}False"{}}) << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{61                  << \textcolor{stringliteral}{"{}      * Number of Low  Energy Roots = "{}} << this-\/>nHighERoots    << \textcolor{stringliteral}{"{}\(\backslash\)n"{}}}
\DoxyCodeLine{62                  << \textcolor{stringliteral}{"{}      * Number of High Energy Roots = "{}} << this-\/> nLowERoots    << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{63         \textcolor{keywordflow}{if}(this-\/>adaptiveERef) \{}
\DoxyCodeLine{64           std::cout<< \textcolor{stringliteral}{"{}      * Use Ground State Energy in each iteration as Reference \(\backslash\)n"{}};}
\DoxyCodeLine{65         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{66           std::cout<< \textcolor{stringliteral}{"{}      * Energy Referene  = "{}} << this-\/>EnergyRef    << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{67         \}}
\DoxyCodeLine{68       \}          }
\DoxyCodeLine{69       std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n"{}} << std::endl;}
\DoxyCodeLine{70     \}}
\DoxyCodeLine{71     }
\DoxyCodeLine{72     std::cout << std::setprecision(10) << std::scientific;}
\DoxyCodeLine{73     }
\DoxyCodeLine{74     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} N   = this-\/>N\_;}
\DoxyCodeLine{75     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} MSS = this-\/>mSS\_;}
\DoxyCodeLine{76     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nR  = this-\/>nRoots\_;}
\DoxyCodeLine{77     }
\DoxyCodeLine{78     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} MSS2 = MSS * MSS;}
\DoxyCodeLine{79     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NMSS = N * MSS;}
\DoxyCodeLine{80     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NNR  = N * nR;}
\DoxyCodeLine{81     }
\DoxyCodeLine{82     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} nG  = this-\/>nGuess\_;}
\DoxyCodeLine{83     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} NNG = N * nG;  }
\DoxyCodeLine{84     }
\DoxyCodeLine{85     \textcolor{comment}{// Initialize pointers}}
\DoxyCodeLine{86     std::shared\_ptr<SolverVectors<\_F>> VR  = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{87     \_F *XR  = \textcolor{keyword}{nullptr}, *XRPrev = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{88     std::shared\_ptr<SolverVectors<\_F>> VL  = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{89     \_F *XL  = \textcolor{keyword}{nullptr}; \textcolor{comment}{// for left search space}}
\DoxyCodeLine{90     std::shared\_ptr<SolverVectors<\_F>> AVR = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{91     \_F *Ovlp = \textcolor{keyword}{nullptr}; \textcolor{comment}{// overlap is using right eigenvectors}}
\DoxyCodeLine{92     std::shared\_ptr<SolverVectors<\_F>> R   = \textcolor{keyword}{nullptr}, \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}} = \textcolor{keyword}{nullptr}; \textcolor{comment}{// Scratch space for residue and perturbed vector}}
\DoxyCodeLine{93     \_F *SubA = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{94     \_F *SCR = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{95 }
\DoxyCodeLine{96     \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} *Eig = \textcolor{keyword}{nullptr}, *EPrev = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{97 }
\DoxyCodeLine{98     VR     = this-\/>vecGen\_(MSS);}
\DoxyCodeLine{99     AVR    = this-\/>vecGen\_(MSS);}
\DoxyCodeLine{100     R      = this-\/>vecGen\_(nG);}
\DoxyCodeLine{101     \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}      = this-\/>vecGen\_(nG);}
\DoxyCodeLine{102     SubA   = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{103     \textcolor{keywordflow}{if}(this-\/>DoLeftEigVec) \{}
\DoxyCodeLine{104       VL   = this-\/>vecGen\_(MSS);}
\DoxyCodeLine{105     \}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107     XR     = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{108     XRPrev = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{109     Eig    = this-\/>memManager\_.template malloc<dcomplex>(MSS);}
\DoxyCodeLine{110     EPrev  = this-\/>memManager\_.template malloc<dcomplex>(MSS);}
\DoxyCodeLine{111     Ovlp   = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{112     SCR    = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{113 }
\DoxyCodeLine{114     \textcolor{keywordflow}{if}(this-\/>DoLeftEigVec) \{}
\DoxyCodeLine{115       XL   = this-\/>memManager\_.template malloc<\_F>(MSS2);}
\DoxyCodeLine{116     \}}
\DoxyCodeLine{117 }
\DoxyCodeLine{118     \textcolor{comment}{// variables during iteration}}
\DoxyCodeLine{119     std::vector<bool> SiConv(nG); \textcolor{comment}{// state\_i converged?}}
\DoxyCodeLine{120     \textcolor{keywordtype}{size\_t} iter   = 0;}
\DoxyCodeLine{121     \textcolor{keywordtype}{size\_t} nDo    = nG;}
\DoxyCodeLine{122     \textcolor{keywordtype}{size\_t} nExam  = nG;}
\DoxyCodeLine{123     \textcolor{keywordtype}{size\_t} nVPrev = 0;     \textcolor{comment}{// number of vectors at previous iteration}}
\DoxyCodeLine{124     \textcolor{keywordtype}{size\_t} nVCur  = nG;    \textcolor{comment}{// number of vectors at current iteration}}
\DoxyCodeLine{125     \textcolor{keywordtype}{char}   JOBVL  = this-\/>DoLeftEigVec ? \textcolor{charliteral}{'V'}: \textcolor{charliteral}{'N'};}
\DoxyCodeLine{126     \textcolor{keywordtype}{double} VecNear = 0.1;  \textcolor{comment}{// criterion to determine if two vector are similar by their overlap}}
\DoxyCodeLine{127     \textcolor{keywordtype}{double} VecConv = this-\/>convCrit\_;}
\DoxyCodeLine{128     \textcolor{keywordtype}{double} EConv   = VecConv * 0.01;}
\DoxyCodeLine{129 }
\DoxyCodeLine{130     \textcolor{comment}{// generate guess}}
\DoxyCodeLine{131     \textcolor{comment}{// Initailize VR as Guess, if no Guess set,}}
\DoxyCodeLine{132     \textcolor{keywordflow}{if}( Guess ) \{}
\DoxyCodeLine{133       VR-\/>set\_data(0, nG, *Guess, 0);}
\DoxyCodeLine{134 }
\DoxyCodeLine{135 \textcolor{preprocessor}{\#ifndef DEBUG\_DAVIDSON}}
\DoxyCodeLine{136       std::cout.setstate(std::ios\_base::failbit);}
\DoxyCodeLine{137 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{138       nVCur = VR-\/>GramSchmidt(0,0,nG,this-\/>memManager\_,GramSchmidt\_NRe,GramSchmidt\_eps);}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#ifndef DEBUG\_DAVIDSON}}
\DoxyCodeLine{140       std::cout.clear();}
\DoxyCodeLine{141 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{142     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{143       std::cout << \textcolor{stringliteral}{"{}  * use unit vector guess"{}} << std::endl;}
\DoxyCodeLine{144       VR-\/>clear();}
\DoxyCodeLine{145       \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul; i < nG; i++) VR-\/>set(i, i, 1.0);}
\DoxyCodeLine{146     \} \textcolor{comment}{// right vector guess}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148     \textcolor{comment}{// left vector guess}}
\DoxyCodeLine{149     \textcolor{keywordflow}{if}(this-\/>DoLeftEigVec) \{}
\DoxyCodeLine{150       \textcolor{comment}{// VL and VR should be biothogonalized}}
\DoxyCodeLine{151       \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}Do Left Eig Vec is not implemented yet"{}});}
\DoxyCodeLine{152     \}}
\DoxyCodeLine{153 }
\DoxyCodeLine{154     \textcolor{keywordflow}{if}( isRoot ) \{}
\DoxyCodeLine{155       std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n\(\backslash\)n  * Starting Davidson Iterations"{}} << std::endl;}
\DoxyCodeLine{156     \} \textcolor{comment}{// Root Only}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158     \textcolor{comment}{// ****************************}}
\DoxyCodeLine{159     \textcolor{comment}{// ** Begin Davidson iterations **}}
\DoxyCodeLine{160     \textcolor{comment}{// ****************************}}
\DoxyCodeLine{161     \textcolor{keywordflow}{for}( iter = 0; iter < this-\/>maxMicroIter\_; iter++) \{}
\DoxyCodeLine{162       }
\DoxyCodeLine{163       \textcolor{keyword}{auto} DavidsonSt = \mbox{\hyperlink{namespaceChronusQ_a715f671201f0f6e77216fcf1f72adbaf}{tick}}();}
\DoxyCodeLine{164       }
\DoxyCodeLine{165       \textcolor{keywordflow}{if}( isRoot ) \{}
\DoxyCodeLine{166         std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n    DavidsonIter "{}} << std::setw(5) << iter+1  }
\DoxyCodeLine{167                   << \textcolor{stringliteral}{"{}: Number of new vectors = "{}} << std::setw(5) << nDo << std::endl;}
\DoxyCodeLine{168       \} \textcolor{comment}{// Root Only}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170       \textcolor{keyword}{auto} LTst = \mbox{\hyperlink{namespaceChronusQ_a715f671201f0f6e77216fcf1f72adbaf}{tick}}();}
\DoxyCodeLine{171       }
\DoxyCodeLine{172       \textcolor{comment}{// AVR <-\/ A * VR}}
\DoxyCodeLine{173 \textcolor{comment}{//      if (isRoot) \{}}
\DoxyCodeLine{174         \mbox{\hyperlink{classChronusQ_1_1SolverVectorsView}{SolverVectorsView<\_F>}} VRSend(*VR, nVPrev), AVRRecv(*AVR, nVPrev);}
\DoxyCodeLine{175         this-\/>linearTrans\_(nDo, VRSend, AVRRecv);}
\DoxyCodeLine{176 \textcolor{comment}{//      \}}}
\DoxyCodeLine{177       }
\DoxyCodeLine{178       \textcolor{keywordtype}{double} LTdur = \mbox{\hyperlink{namespaceChronusQ_a3b2153e93af4532ff5b1e75d8af453b0}{tock}}(LTst);}
\DoxyCodeLine{179 }
\DoxyCodeLine{180 \textcolor{preprocessor}{\#ifdef DEBUG\_DAVIDSON}}
\DoxyCodeLine{181       VR-\/>print(std::cout, \textcolor{stringliteral}{"{}VR"{}});}
\DoxyCodeLine{182       AVR-\/>print(std::cout, \textcolor{stringliteral}{"{}AVR"{}});}
\DoxyCodeLine{183 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{184         }
\DoxyCodeLine{185       \textcolor{comment}{// Construct submatrix of A}}
\DoxyCodeLine{186       \textcolor{keywordflow}{if}(this-\/>DoLeftEigVec) \{}
\DoxyCodeLine{187       \textcolor{comment}{//SubA <-\/ VL * AVR}}
\DoxyCodeLine{188         \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}Do Left Eig Vec is not implemented yet"{}});}
\DoxyCodeLine{189       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{190       \textcolor{comment}{// SubA <-\/ VR\_\(\backslash\)dagger * AVR}}
\DoxyCodeLine{191         VR-\/>dot\_product(0, *AVR, 0, nVCur,nVCur,SubA,nVCur);}
\DoxyCodeLine{192       \}}
\DoxyCodeLine{193 }
\DoxyCodeLine{194 \textcolor{comment}{//      if( isRoot ) \{}}
\DoxyCodeLine{195     }
\DoxyCodeLine{196 \textcolor{preprocessor}{\#ifdef DEBUG\_DAVIDSON}}
\DoxyCodeLine{197         \mbox{\hyperlink{namespaceChronusQ_a43999d7848dab8e641410257f6bc0321}{prettyPrintSmart}}(std::cout,\textcolor{stringliteral}{"{}HH Davidson SubMatix "{}},SubA,nVCur,nVCur,nVCur);}
\DoxyCodeLine{198 \textcolor{preprocessor}{\#endif }}
\DoxyCodeLine{199 }
\DoxyCodeLine{200         \textcolor{comment}{// Diagonalize SubA }}
\DoxyCodeLine{201         \mbox{\hyperlink{namespaceChronusQ_a5d3260732d7f2c9102c6974ea3a04d4a}{GeneralEigen}}(JOBVL, \textcolor{charliteral}{'V'}, nVCur, SubA, nVCur, Eig, XL, nVCur, XR, nVCur);}
\DoxyCodeLine{202 }
\DoxyCodeLine{203         \textcolor{comment}{// swap high energy roots for energy specific}}
\DoxyCodeLine{204         \textcolor{keywordflow}{if}(this-\/>EnergySpecific) \{}
\DoxyCodeLine{205 }
\DoxyCodeLine{206           \textcolor{keywordflow}{if}(this-\/>adaptiveERef)}
\DoxyCodeLine{207             this-\/>EnergyRef = std::real(Eig[0]);}
\DoxyCodeLine{208 }
\DoxyCodeLine{209           std::vector<size\_t> indx(nVCur,0);}
\DoxyCodeLine{210           std::iota(indx.begin(), indx.end(), 0);}
\DoxyCodeLine{211 }
\DoxyCodeLine{212           Eigen::Map<}
\DoxyCodeLine{213           Eigen::Matrix<\_F,Eigen::Dynamic,Eigen::Dynamic,Eigen::ColMajor>}
\DoxyCodeLine{214           > XRMap(XR,nVCur,nVCur);}
\DoxyCodeLine{215 }
\DoxyCodeLine{216 }
\DoxyCodeLine{217           \textcolor{keywordflow}{if} ( this-\/>sortByDistance )\{}
\DoxyCodeLine{218             std::stable\_sort(indx.begin(), indx.end(),}
\DoxyCodeLine{219                              [\&] (\textcolor{keywordtype}{size\_t} i , \textcolor{keywordtype}{size\_t} j) \{}
\DoxyCodeLine{220               return std::abs(Eig[i] -\/ this-\/>EnergyRef) < std::abs(Eig[j] -\/ this-\/>EnergyRef);}
\DoxyCodeLine{221             \}}
\DoxyCodeLine{222             );}
\DoxyCodeLine{223           \}}
\DoxyCodeLine{224           \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{225             std::stable\_sort(indx.begin(), indx.end(),}
\DoxyCodeLine{226                              [\&] (\textcolor{keywordtype}{size\_t} i , \textcolor{keywordtype}{size\_t} j) \{}
\DoxyCodeLine{227               if ((std::real(Eig[i]) > this-\/>EnergyRef  and std::real(Eig[j]) > this-\/>EnergyRef)}
\DoxyCodeLine{228               or (std::real(Eig[i]) < this-\/>EnergyRef  and std::real(Eig[j]) < this-\/>EnergyRef))}
\DoxyCodeLine{229                 return std::real(Eig[i]) < std::real(Eig[j]);}
\DoxyCodeLine{230               else if (std::real(Eig[i]) < this-\/>EnergyRef  and std::real(Eig[j]) > this-\/>EnergyRef )}
\DoxyCodeLine{231                 return false;}
\DoxyCodeLine{232               else}
\DoxyCodeLine{233                 return true;}
\DoxyCodeLine{234             \}}
\DoxyCodeLine{235             );}
\DoxyCodeLine{236           \}}
\DoxyCodeLine{237 }
\DoxyCodeLine{238 }
\DoxyCodeLine{239 }
\DoxyCodeLine{240           \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul; i < nVCur -\/ 1; i++)\{}
\DoxyCodeLine{241             \textcolor{keywordtype}{size\_t} ind = indx[i];}
\DoxyCodeLine{242             \textcolor{keywordflow}{while}(ind < i) ind = indx[ind];}
\DoxyCodeLine{243 }
\DoxyCodeLine{244             \textcolor{keywordflow}{if} (ind > i) \{}
\DoxyCodeLine{245               std::swap(Eig[i],Eig[ind]);}
\DoxyCodeLine{246               XRMap.col(i).swap(XRMap.col(ind));}
\DoxyCodeLine{247             \}}
\DoxyCodeLine{248           \}}
\DoxyCodeLine{249 }
\DoxyCodeLine{250 \textcolor{comment}{//          REMOVING LINEAR DEPENDENCY?}}
\DoxyCodeLine{251 \textcolor{comment}{//          for (auto i = 0ul; i < nVCur; i++)\{}}
\DoxyCodeLine{252 \textcolor{comment}{//            if (std::abs(Eig[i]) < 1e-\/8) \{}}
\DoxyCodeLine{253 \textcolor{comment}{//              nVCur = i;}}
\DoxyCodeLine{254 \textcolor{comment}{//              std::cout << "{} Reducing nVCur: "{} << std::endl;}}
\DoxyCodeLine{255 \textcolor{comment}{//              std::cout << nVCur << "{}  "{} << Eig[i] << std::endl;}}
\DoxyCodeLine{256 \textcolor{comment}{//              break;}}
\DoxyCodeLine{257 \textcolor{comment}{//            \}}}
\DoxyCodeLine{258 \textcolor{comment}{//          \}}}
\DoxyCodeLine{259 \textcolor{comment}{//          if (nVCur == 0) CErr("{}Not enough eigenpairs to proceed! "{});}}
\DoxyCodeLine{260         \}   }
\DoxyCodeLine{261 }
\DoxyCodeLine{262         \textcolor{comment}{// print eigenvalues at current iteration}}
\DoxyCodeLine{263         std::cout << \textcolor{stringliteral}{"{}      -\/ Eigenvalues at the current iteration:"{}} << std::endl;}
\DoxyCodeLine{264         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0; i < nExam; i++) \{}
\DoxyCodeLine{265           std::cout << \textcolor{stringliteral}{"{}        Root "{}} << std::setw(5) << std::right << i << \textcolor{stringliteral}{"{}:"{}}}
\DoxyCodeLine{266                     << std::right << std::setw(20) << std::real(Eig[i]);}
\DoxyCodeLine{267               }
\DoxyCodeLine{268           \textcolor{keywordflow}{if}( std::is\_same<dcomplex,\_F>::value ) \{}
\DoxyCodeLine{269             std::cout << \textcolor{stringliteral}{"{} + "{}} << std::setw(20) << std::imag(Eig[i]) << \textcolor{stringliteral}{"{} i"{}};}
\DoxyCodeLine{270           \}}
\DoxyCodeLine{271               }
\DoxyCodeLine{272           std::cout << std::endl;}
\DoxyCodeLine{273         \}}
\DoxyCodeLine{274           }
\DoxyCodeLine{275         \textcolor{comment}{// Exam Eigenvalues and eigenvectors and do mapping if iter > 0}}
\DoxyCodeLine{276         std::fill\_n(SiConv.begin(),nExam,\textcolor{keyword}{false});}
\DoxyCodeLine{277         \textcolor{keywordflow}{if}( iter > 0) \{}
\DoxyCodeLine{278             }
\DoxyCodeLine{279           \textcolor{comment}{// overlap = (VR XR)\_old \string^\(\backslash\)dagger * (VR XR)\_new}}
\DoxyCodeLine{280           std::fill\_n(Ovlp, nVCur*nVPrev, \_F(0.)); }
\DoxyCodeLine{281               \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i = 0ul; i < nVCur; i++) Ovlp[i + i*nVPrev] = \_F(1.); }
\DoxyCodeLine{282               }
\DoxyCodeLine{283           blas::gemm(blas::Layout::ColMajor,blas::Op::ConjTrans,blas::Op::NoTrans,nExam,nVCur,nVPrev,\_F(1.),XRPrev,nVPrev,Ovlp,nVPrev,\_F(0.),SCR,nExam);}
\DoxyCodeLine{284           blas::gemm(blas::Layout::ColMajor,blas::Op::NoTrans,blas::Op::NoTrans,nExam,nExam,nVCur ,\_F(1.),SCR,nExam,XR,nVCur,\_F(0.),Ovlp,nExam);}
\DoxyCodeLine{285           }
\DoxyCodeLine{286           \textcolor{comment}{// mapping old vector to new vectors based on overlap}}
\DoxyCodeLine{287           std::vector<int> StMap(nExam);}
\DoxyCodeLine{288           std::fill\_n(StMap.begin(),nExam,-\/1);}
\DoxyCodeLine{289           std::copy\_n(Ovlp,nExam*nExam,SCR);}
\DoxyCodeLine{290               }
\DoxyCodeLine{291           \textcolor{comment}{// i -\/> new state, j -\/> old state}}
\DoxyCodeLine{292           \textcolor{keywordtype}{int} i = 0, j = 0;}
\DoxyCodeLine{293           \textcolor{keywordflow}{for}(i = 0; i < nExam; i++) \{}
\DoxyCodeLine{294             \textcolor{keyword}{auto} iO = Ovlp + i*nExam;}
\DoxyCodeLine{295             j = std::distance(iO, std::max\_element(iO, iO+nExam, }
\DoxyCodeLine{296                   [\&] (\_F A, \_F B) \{\textcolor{keywordflow}{return} std::norm(A) < std::norm(B); }
\DoxyCodeLine{297                                   \}));}
\DoxyCodeLine{298             \textcolor{keywordflow}{if}( std::abs(iO[j]) > VecNear) \{}
\DoxyCodeLine{299               StMap[i] = j;}
\DoxyCodeLine{300               \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} k = i+1; k < nExam; k++) Ovlp[j + k*nExam] = \_F(0.);}
\DoxyCodeLine{301             \}}
\DoxyCodeLine{302           \}}
\DoxyCodeLine{303         }
\DoxyCodeLine{304           std::copy\_n(SCR,nExam*nExam,Ovlp);}
\DoxyCodeLine{305           }
\DoxyCodeLine{306 \textcolor{preprocessor}{\#ifdef DEBUG\_DAVIDSON}}
\DoxyCodeLine{307           \mbox{\hyperlink{namespaceChronusQ_a43999d7848dab8e641410257f6bc0321}{prettyPrintSmart}}(std::cout,\textcolor{stringliteral}{"{}HH Davidson States Overlap"{}},Ovlp,nExam,nExam,nExam);}
\DoxyCodeLine{308 \textcolor{preprocessor}{\#endif }}
\DoxyCodeLine{309       }
\DoxyCodeLine{310           std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n      -\/ Comparison to the previous iteration: "{}} << std::endl;  }
\DoxyCodeLine{311           \textcolor{comment}{// exam eigenvectors}}
\DoxyCodeLine{312           \textcolor{comment}{// R and S as scratch space to hold full vector old and new repectively}}
\DoxyCodeLine{313           VR-\/>multiply\_matrix(0, blas::Op::NoTrans,nExam,nVPrev,\_F(1.),XRPrev,nVPrev,\_F(0.),*R, 0);}
\DoxyCodeLine{314           VR-\/>multiply\_matrix(0, blas::Op::NoTrans,nExam,nVCur,\_F(1.),XR,nVCur,\_F(0.),*\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}, 0);}
\DoxyCodeLine{315               }
\DoxyCodeLine{316           \_F phase;}
\DoxyCodeLine{317           \textcolor{keywordtype}{double} maxDel;  \textcolor{comment}{// maximum differece in vectors}}
\DoxyCodeLine{318           \textcolor{keywordflow}{for}(i = 0; i < nExam; i++) \{}
\DoxyCodeLine{319             j = StMap[i];}
\DoxyCodeLine{320             \textcolor{keywordflow}{if}(j < 0) \{}
\DoxyCodeLine{321               std::cout << \textcolor{stringliteral}{"{}          New root"{}} << std::setw(5) << i << \textcolor{stringliteral}{"{} is brand new"{}} << std::endl;}
\DoxyCodeLine{322               \textcolor{keywordflow}{continue}; }
\DoxyCodeLine{323             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (j!=i) \{ }
\DoxyCodeLine{324               std::cout << \textcolor{stringliteral}{"{}          New root"{}} << std::setw(5) << i}
\DoxyCodeLine{325                         << \textcolor{stringliteral}{"{} was old root"{}} << std::setw(5) << j << std::endl; }
\DoxyCodeLine{326             \}}
\DoxyCodeLine{327 }
\DoxyCodeLine{328             phase = Ovlp[j + i*nExam];}
\DoxyCodeLine{329             phase /= std::abs(phase);}
\DoxyCodeLine{330 }
\DoxyCodeLine{331             std::shared\_ptr<SolverVectors<\_F>> iNew = std::make\_shared<SolverVectorsView<\_F>>(*\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}, i);}
\DoxyCodeLine{332             std::shared\_ptr<SolverVectors<\_F>> jOld = std::make\_shared<SolverVectorsView<\_F>>(*R, j);}
\DoxyCodeLine{333 }
\DoxyCodeLine{334             jOld-\/>scale(-\/phase, 0, 1);}
\DoxyCodeLine{335             jOld-\/>axpy(0, 1, \_F(1.), *iNew, 0);}
\DoxyCodeLine{336             maxDel = jOld-\/>maxNormElement(0, 1);}
\DoxyCodeLine{337  }
\DoxyCodeLine{338             SiConv[i] = maxDel < VecConv;}
\DoxyCodeLine{339             \textcolor{keywordflow}{if}(SiConv[i]) std::cout << \textcolor{stringliteral}{"{}        Root "{}}   << std::setw(5) << std::right << i}
\DoxyCodeLine{340                                     << \textcolor{stringliteral}{"{} has converged"{}}  << std::endl;}
\DoxyCodeLine{341             \textcolor{keywordflow}{else} std::cout << \textcolor{stringliteral}{"{}        Root "{}} <<  std::right << std::setw(5) << i}
\DoxyCodeLine{342                            << \textcolor{stringliteral}{"{} has not converged, maximum delta is"{}}<<  std::right  }
\DoxyCodeLine{343                            << std::setw(20) << maxDel << std::endl;}
\DoxyCodeLine{344           \}}
\DoxyCodeLine{345 }
\DoxyCodeLine{346           \textcolor{comment}{// exam eigenvalues}}
\DoxyCodeLine{347           \mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}} EDiff;}
\DoxyCodeLine{348           \textcolor{keywordflow}{for}(i = 0; i < nExam; i++) \{}
\DoxyCodeLine{349             j = StMap[i];}
\DoxyCodeLine{350             EDiff = Eig[i] -\/ EPrev[j];}
\DoxyCodeLine{351             SiConv[i] = SiConv[i] and (std::abs(EDiff) < EConv);  }
\DoxyCodeLine{352           \} }
\DoxyCodeLine{353         \}   \textcolor{comment}{// Exam eigenvales and eigenvectors}}
\DoxyCodeLine{354           }
\DoxyCodeLine{355         isConverged = std::all\_of(SiConv.begin(), SiConv.begin()+nExam, [\&] (\textcolor{keywordtype}{bool} i) \{ return i; \});}
\DoxyCodeLine{356         \textcolor{keywordflow}{if}(isConverged or nVCur >= MSS) \{}
\DoxyCodeLine{357         }
\DoxyCodeLine{358           \textcolor{keywordtype}{double} DavidsonDur = \mbox{\hyperlink{namespaceChronusQ_a3b2153e93af4532ff5b1e75d8af453b0}{tock}}(DavidsonSt);}
\DoxyCodeLine{359           \textcolor{keywordtype}{double} perLT = LTdur * 100 / DavidsonDur;}
\DoxyCodeLine{360         }
\DoxyCodeLine{361           std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n      -\/ DURATION = "{}} << std::setprecision(8) << DavidsonDur }
\DoxyCodeLine{362             << \textcolor{stringliteral}{"{} s  ( "{}} << perLT << \textcolor{stringliteral}{"{} \% LT )"{}} << std::endl;}
\DoxyCodeLine{363           \textcolor{keywordflow}{break};}
\DoxyCodeLine{364         \}}
\DoxyCodeLine{365 }
\DoxyCodeLine{366         \textcolor{comment}{// Form residue vectors only for unconverged vectors}}
\DoxyCodeLine{367         std::vector<int> unConvS(nExam);}
\DoxyCodeLine{368         nDo = 0ul;}
\DoxyCodeLine{369         std::fill\_n(unConvS.begin(),nExam,-\/1);}
\DoxyCodeLine{370         std::fill\_n(SCR,nVCur*nExam,\_F(0.));}
\DoxyCodeLine{371         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0ul; i < nExam; i++) \{}
\DoxyCodeLine{372           \textcolor{keywordflow}{if}(not SiConv[i]) \{}
\DoxyCodeLine{373             unConvS[nDo] = i;}
\DoxyCodeLine{374             std::copy\_n(XR + i*nVCur,nVCur,SCR + nDo*nVCur);}
\DoxyCodeLine{375             nDo++;}
\DoxyCodeLine{376           \}}
\DoxyCodeLine{377         \}}
\DoxyCodeLine{378 }
\DoxyCodeLine{379         \textcolor{keywordflow}{if}(nVCur+nDo > MSS)  nDo = MSS -\/ nVCur;}
\DoxyCodeLine{380         }
\DoxyCodeLine{381         \textcolor{comment}{// R <-\/ AVR * XR}}
\DoxyCodeLine{382         AVR-\/>multiply\_matrix(0, blas::Op::NoTrans,nDo,nVCur,\_F(1.),SCR,nVCur,\_F(0.),*R, 0);}
\DoxyCodeLine{383 }
\DoxyCodeLine{384         \textcolor{comment}{// S as scratch space, <-\/ eig\_i * (VR * XR\_i)}}
\DoxyCodeLine{385         VR-\/>multiply\_matrix(0, blas::Op::NoTrans,nDo,nVCur,\_F(1.),SCR,nVCur,\_F(0.),*\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}, 0);}
\DoxyCodeLine{386             }
\DoxyCodeLine{387         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0ul; i < nDo; i++)}
\DoxyCodeLine{388           \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}-\/>scale(this-\/>dcomplexTo\_F(Eig[unConvS[i]]), i, 1);}
\DoxyCodeLine{389             }
\DoxyCodeLine{390         \textcolor{comment}{// Compute the residue norm and generate perturbbed vectors}}
\DoxyCodeLine{391         \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}-\/>scale(\_F(-\/1.), 0, nDo);}
\DoxyCodeLine{392         \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}-\/>axpy(0, nDo, \_F(1.), *R, 0);}
\DoxyCodeLine{393         std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n      -\/ Residues of non-\/converged roots: "{}} << std::endl;  }
\DoxyCodeLine{394         }
\DoxyCodeLine{395         \textcolor{keywordflow}{if}(EigForT) std::fill\_n(EigForT,nG,\mbox{\hyperlink{chronusq__sys_8hpp_aa7b4cfa83fe868296abd1ba4d67d9563}{dcomplex}}(0.));}
\DoxyCodeLine{396         std::fill\_n(RelRes, nG, 0.);}
\DoxyCodeLine{397         \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0ul; i < nDo; i++) \{}
\DoxyCodeLine{398           \textcolor{keyword}{auto} j = unConvS[i];}
\DoxyCodeLine{399           RelRes[i] = \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}-\/>norm2F(i, 1);}
\DoxyCodeLine{400           std::cout << \textcolor{stringliteral}{"{}        Root "{}} << std::setw(5) << std::right << j+1 }
\DoxyCodeLine{401                     << \textcolor{stringliteral}{"{} 2nd order lowering "{}} << std::right << std::setw(20) << RelRes[i]*RelRes[i] }
\DoxyCodeLine{402                     << \textcolor{stringliteral}{"{} norm "{}} << std::right << std::setw(20) << RelRes[i] << std::endl;}
\DoxyCodeLine{403               }
\DoxyCodeLine{404           \textcolor{keywordflow}{if}(EigForT) this-\/>EigForT[i] = Eig[j];}
\DoxyCodeLine{405         \}}
\DoxyCodeLine{406 }
\DoxyCodeLine{407 \textcolor{preprocessor}{\#ifdef DEBUG\_DAVIDSON}}
\DoxyCodeLine{408         \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}-\/>print(std::cout, \textcolor{stringliteral}{"{}S before preCond"{}});}
\DoxyCodeLine{409 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{410         this-\/>preCondNoShift\_(nDo,*\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}},*\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}});}
\DoxyCodeLine{411 }
\DoxyCodeLine{412 \textcolor{preprocessor}{\#ifdef DEBUG\_DAVIDSON}}
\DoxyCodeLine{413         \mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}-\/>print(std::cout, \textcolor{stringliteral}{"{}S after preCond"{}});}
\DoxyCodeLine{414 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{415         \textcolor{comment}{// Append the new vectors to VR and orthogoalize against existing ones }}
\DoxyCodeLine{416         \textcolor{comment}{// Also update the dimensions and save the XRPrev}}
\DoxyCodeLine{417         VR-\/>set\_data(nVCur, nDo, *\mbox{\hyperlink{namespaceChronusQ_a56ff0c04bad8a04cb96ea01fdec98e8fa5dbc98dcc983a70728bd082d1a47546e}{S}}, 0);}
\DoxyCodeLine{418         std::copy\_n(XR,nVCur*nVCur,XRPrev);}
\DoxyCodeLine{419         std::copy\_n(Eig,nVCur,EPrev);}
\DoxyCodeLine{420         nVPrev = nVCur;}
\DoxyCodeLine{421         \textcolor{keywordflow}{if}(this-\/>DoLeftEigVec) \{}
\DoxyCodeLine{422           \mbox{\hyperlink{namespaceChronusQ_afbba655765a7a40e19e2bea928a687c7}{CErr}}(\textcolor{stringliteral}{"{}Do Left Eig Vec is not implemented yet"{}});}
\DoxyCodeLine{423         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{424           \textcolor{comment}{// disable printing from GramSchmidt}}
\DoxyCodeLine{425           }
\DoxyCodeLine{426 \textcolor{preprocessor}{\#ifndef DEBUG\_DAVIDSON}}
\DoxyCodeLine{427           std::cout.setstate(std::ios\_base::failbit);}
\DoxyCodeLine{428 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{429 }
\DoxyCodeLine{430 \textcolor{preprocessor}{\#ifdef DEBUG\_DAVIDSON}}
\DoxyCodeLine{431           VR-\/>print(std::cout, \textcolor{stringliteral}{"{}VR before GramSchmidt"{}});}
\DoxyCodeLine{432 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{433           nVCur = VR-\/>GramSchmidt(0, nVCur,nDo,this-\/>memManager\_,GramSchmidt\_NRe,GramSchmidt\_eps);}
\DoxyCodeLine{434 \textcolor{preprocessor}{\#ifdef DEBUG\_DAVIDSON}}
\DoxyCodeLine{435           VR-\/>print(std::cout, \textcolor{stringliteral}{"{}VR after GramSchmidt"{}});}
\DoxyCodeLine{436 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{437           }
\DoxyCodeLine{438 \textcolor{preprocessor}{\#ifndef DEBUG\_DAVIDSON}}
\DoxyCodeLine{439           std::cout.clear();}
\DoxyCodeLine{440 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{441           }
\DoxyCodeLine{442           nDo   = nVCur -\/ nVPrev;}
\DoxyCodeLine{443         \}}
\DoxyCodeLine{444          }
\DoxyCodeLine{445         \textcolor{keywordflow}{if}(iter+1 == this-\/>whenSc) \{ }
\DoxyCodeLine{446           nExam = nR; }
\DoxyCodeLine{447           nDo   = std::min(nDo, nExam);}
\DoxyCodeLine{448           nVCur = nVPrev + nDo;}
\DoxyCodeLine{449         \}}
\DoxyCodeLine{450         }
\DoxyCodeLine{451         \textcolor{keywordtype}{double} DavidsonDur = \mbox{\hyperlink{namespaceChronusQ_a3b2153e93af4532ff5b1e75d8af453b0}{tock}}(DavidsonSt);}
\DoxyCodeLine{452         \textcolor{keywordtype}{double} perLT = LTdur * 100 / DavidsonDur;}
\DoxyCodeLine{453     }
\DoxyCodeLine{454         std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n      -\/ DURATION = "{}} << std::setprecision(8) << DavidsonDur }
\DoxyCodeLine{455           << \textcolor{stringliteral}{"{} s  ( "{}} << perLT << \textcolor{stringliteral}{"{} \% LT )"{}} << std::endl;}
\DoxyCodeLine{456     }
\DoxyCodeLine{457         \textcolor{keywordflow}{if}(nDo == 0) \{}
\DoxyCodeLine{458           isConverged = \textcolor{keyword}{true};}
\DoxyCodeLine{459           \textcolor{keywordflow}{break};}
\DoxyCodeLine{460         \}}
\DoxyCodeLine{461 \textcolor{comment}{//      \} // Root Only}}
\DoxyCodeLine{462     }
\DoxyCodeLine{463     \} \textcolor{comment}{// Davidson iteration    }}
\DoxyCodeLine{464 }
\DoxyCodeLine{465 \textcolor{comment}{//    if( isRoot ) \{}}
\DoxyCodeLine{466 }
\DoxyCodeLine{467       \textcolor{comment}{// move data before exit runMicro      }}
\DoxyCodeLine{468       std::copy\_n(Eig,nR,this-\/>eigVal\_);}
\DoxyCodeLine{469       VR-\/>multiply\_matrix(0, blas::Op::NoTrans,nR,nVCur,\_F(1.),XR,nVCur,\_F(0.),*this-\/>VR\_, 0);}
\DoxyCodeLine{470       \textcolor{comment}{//size\_t nVSave = isConverged ? nR: nG;  }}
\DoxyCodeLine{471       \textcolor{comment}{//std::copy\_n(Eig,nVSave,this-\/>eigVal\_);}}
\DoxyCodeLine{472       \textcolor{comment}{//blas::gemm(blas::Layout::ColMajor,blas::Op::NoTrans,blas::Op::NoTrans,N,nVSave,nVCur,\_F(1.),VR,N,XR,nVCur,\_F(0.),this-\/>VR\_,N);}}
\DoxyCodeLine{473 }
\DoxyCodeLine{474     \textcolor{keywordflow}{if}( isRoot ) \{}
\DoxyCodeLine{475       std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n  * "{}};}
\DoxyCodeLine{476       \textcolor{keywordflow}{if}( isConverged and nDo !=0)}
\DoxyCodeLine{477         std::cout << \textcolor{stringliteral}{"{}Davidson Converged in "{}} << iter+1 << \textcolor{stringliteral}{"{} Iterations"{}} }
\DoxyCodeLine{478                   << std::endl;}
\DoxyCodeLine{479       \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nDo ==0) \{}
\DoxyCodeLine{480         \textcolor{keywordtype}{double} maxResDel = *std::max\_element(RelRes, RelRes+nR);}
\DoxyCodeLine{481         std::cout << \textcolor{stringliteral}{"{}Davidson expansion finished, and wavefunction converged "{}}}
\DoxyCodeLine{482           << \textcolor{stringliteral}{"{}below "{}} << std::setw(20) << std::right << maxResDel << std::endl;}
\DoxyCodeLine{483       \} \textcolor{keywordflow}{else}}
\DoxyCodeLine{484         std::cout << \textcolor{stringliteral}{"{}Davidson Failed to Converged in "{}} << iter+1 << \textcolor{stringliteral}{"{} Iterations"{}} }
\DoxyCodeLine{485                   << std::endl;}
\DoxyCodeLine{486     \} \textcolor{comment}{// Root Only }}
\DoxyCodeLine{487 }
\DoxyCodeLine{488     \textcolor{comment}{// Free Scratch space}}
\DoxyCodeLine{489 }
\DoxyCodeLine{490     \textcolor{keywordflow}{if}(XR)       this-\/>memManager\_.template free(XR);    }
\DoxyCodeLine{491     \textcolor{keywordflow}{if}(XRPrev)   this-\/>memManager\_.template free(XRPrev);}
\DoxyCodeLine{492     \textcolor{keywordflow}{if}(SubA)     this-\/>memManager\_.template free(SubA);}
\DoxyCodeLine{493     \textcolor{keywordflow}{if}(Eig)      this-\/>memManager\_.template free(Eig);}
\DoxyCodeLine{494     \textcolor{keywordflow}{if}(EPrev)    this-\/>memManager\_.template free(EPrev); }
\DoxyCodeLine{495     \textcolor{keywordflow}{if}(Ovlp)     this-\/>memManager\_.template free(Ovlp);}
\DoxyCodeLine{496     \textcolor{keywordflow}{if}(SCR)      this-\/>memManager\_.template free(SCR);}
\DoxyCodeLine{497     \textcolor{keywordflow}{if}(XL)       this-\/>memManager\_.template free(XL);    }
\DoxyCodeLine{498     }
\DoxyCodeLine{499     \textcolor{keywordflow}{return} isConverged;}
\DoxyCodeLine{500   }
\DoxyCodeLine{501   \} \textcolor{comment}{// Davidson::runMicro}}
\DoxyCodeLine{502 }
\DoxyCodeLine{503   \textcolor{keyword}{template} <\textcolor{keyword}{typename} \_F>}
\DoxyCodeLine{504   \textcolor{keywordtype}{void} \mbox{\hyperlink{classChronusQ_1_1Davidson_a609f85c9ea755b4f01ae8c29faccdd7d}{Davidson<\_F>::restart}}() \{}
\DoxyCodeLine{505     \textcolor{comment}{// copy full vectors as new guess  }}
\DoxyCodeLine{506     std::cout << \textcolor{stringliteral}{"{}\(\backslash\)n  * Restarting Davidson..."{}} << std::endl;}
\DoxyCodeLine{507     }
\DoxyCodeLine{508     \textcolor{comment}{// restart with only nRoots\_ of guess}}
\DoxyCodeLine{509     \textcolor{comment}{// as now it's more close to the solution}}
\DoxyCodeLine{510     this-\/>kG      = 1;}
\DoxyCodeLine{511     this-\/>whenSc  = 1;}
\DoxyCodeLine{512     this-\/>nGuess\_ = this-\/>nRoots\_;}
\DoxyCodeLine{513 }
\DoxyCodeLine{514     Guess = this-\/>vecGen\_(this-\/>nGuess\_);}
\DoxyCodeLine{515 }
\DoxyCodeLine{516     \textcolor{comment}{// NO MPI}}
\DoxyCodeLine{517     \textcolor{comment}{// ROOT\_ONLY(this-\/>comm\_);}}
\DoxyCodeLine{518     this-\/>Guess-\/>set\_data(0, this-\/>nGuess\_, *this-\/>VR\_, 0);}
\DoxyCodeLine{519   \} \textcolor{comment}{// Davidson::restart}}
\DoxyCodeLine{520   }
\DoxyCodeLine{521 \}; \textcolor{comment}{// namespace ChronusQ}}
\DoxyCodeLine{522 }
\DoxyCodeLine{523 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
